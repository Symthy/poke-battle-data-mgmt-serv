// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/abilities"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/battleopponentparty"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/battlerecords"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/forms"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/helditems"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/moves"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/party"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/partyresultrecord"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/pokemons"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/predicate"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/tags"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/trainedpokemondetails"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/trainedpokemons"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/typecompatibility"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/users"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/property"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbilities             = "Abilities"
	TypeBattleOpponentParty   = "BattleOpponentParty"
	TypeBattleRecords         = "BattleRecords"
	TypeForms                 = "Forms"
	TypeHeldItems             = "HeldItems"
	TypeMoves                 = "Moves"
	TypeParty                 = "Party"
	TypePartyResultRecord     = "PartyResultRecord"
	TypePokemons              = "Pokemons"
	TypeTags                  = "Tags"
	TypeTrainedPokemonDetails = "TrainedPokemonDetails"
	TypeTrainedPokemons       = "TrainedPokemons"
	TypeTypeCompatibility     = "TypeCompatibility"
	TypeUsers                 = "Users"
)

// AbilitiesMutation represents an operation that mutates the Abilities nodes in the graph.
type AbilitiesMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	physical_move_power_correction_value     *int
	addphysical_move_power_correction_value  *int
	special_move_power_correction_value      *int
	addspecial_move_power_correction_value   *int
	attack_power_correction_value            *int
	addattack_power_correction_value         *int
	special_attack_power_correction_value    *int
	addspecial_attack_power_correction_value *int
	attack_correction_value                  *int
	addattack_correction_value               *int
	special_attack_correction_value          *int
	addspecial_attack_correction_value       *int
	deffense_correction_value                *int
	adddeffense_correction_value             *int
	special_deffense_correction_value        *int
	addspecial_deffense_correction_value     *int
	damage_correction_type1                  *property.Types
	damage_correction_value1                 *int
	adddamage_correction_value1              *int
	damage_correction_type2                  *property.Types
	damage_correction_value2                 *int
	adddamage_correction_value2              *int
	weight_correction_value                  *int
	addweight_correction_value               *int
	name                                     *string
	description                              *string
	clearedFields                            map[string]struct{}
	ability_holder1                          map[int]struct{}
	removedability_holder1                   map[int]struct{}
	clearedability_holder1                   bool
	ability_holder2                          map[int]struct{}
	removedability_holder2                   map[int]struct{}
	clearedability_holder2                   bool
	hidden_ability_holder                    map[int]struct{}
	removedhidden_ability_holder             map[int]struct{}
	clearedhidden_ability_holder             bool
	to_trained_pokemon_ability               map[int]struct{}
	removedto_trained_pokemon_ability        map[int]struct{}
	clearedto_trained_pokemon_ability        bool
	done                                     bool
	oldValue                                 func(context.Context) (*Abilities, error)
	predicates                               []predicate.Abilities
}

var _ ent.Mutation = (*AbilitiesMutation)(nil)

// abilitiesOption allows management of the mutation configuration using functional options.
type abilitiesOption func(*AbilitiesMutation)

// newAbilitiesMutation creates new mutation for the Abilities entity.
func newAbilitiesMutation(c config, op Op, opts ...abilitiesOption) *AbilitiesMutation {
	m := &AbilitiesMutation{
		config:        c,
		op:            op,
		typ:           TypeAbilities,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbilitiesID sets the ID field of the mutation.
func withAbilitiesID(id int) abilitiesOption {
	return func(m *AbilitiesMutation) {
		var (
			err   error
			once  sync.Once
			value *Abilities
		)
		m.oldValue = func(ctx context.Context) (*Abilities, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Abilities.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbilities sets the old Abilities of the mutation.
func withAbilities(node *Abilities) abilitiesOption {
	return func(m *AbilitiesMutation) {
		m.oldValue = func(context.Context) (*Abilities, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbilitiesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbilitiesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbilitiesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPhysicalMovePowerCorrectionValue sets the "physical_move_power_correction_value" field.
func (m *AbilitiesMutation) SetPhysicalMovePowerCorrectionValue(i int) {
	m.physical_move_power_correction_value = &i
	m.addphysical_move_power_correction_value = nil
}

// PhysicalMovePowerCorrectionValue returns the value of the "physical_move_power_correction_value" field in the mutation.
func (m *AbilitiesMutation) PhysicalMovePowerCorrectionValue() (r int, exists bool) {
	v := m.physical_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicalMovePowerCorrectionValue returns the old "physical_move_power_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldPhysicalMovePowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhysicalMovePowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhysicalMovePowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicalMovePowerCorrectionValue: %w", err)
	}
	return oldValue.PhysicalMovePowerCorrectionValue, nil
}

// AddPhysicalMovePowerCorrectionValue adds i to the "physical_move_power_correction_value" field.
func (m *AbilitiesMutation) AddPhysicalMovePowerCorrectionValue(i int) {
	if m.addphysical_move_power_correction_value != nil {
		*m.addphysical_move_power_correction_value += i
	} else {
		m.addphysical_move_power_correction_value = &i
	}
}

// AddedPhysicalMovePowerCorrectionValue returns the value that was added to the "physical_move_power_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedPhysicalMovePowerCorrectionValue() (r int, exists bool) {
	v := m.addphysical_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetPhysicalMovePowerCorrectionValue resets all changes to the "physical_move_power_correction_value" field.
func (m *AbilitiesMutation) ResetPhysicalMovePowerCorrectionValue() {
	m.physical_move_power_correction_value = nil
	m.addphysical_move_power_correction_value = nil
}

// SetSpecialMovePowerCorrectionValue sets the "special_move_power_correction_value" field.
func (m *AbilitiesMutation) SetSpecialMovePowerCorrectionValue(i int) {
	m.special_move_power_correction_value = &i
	m.addspecial_move_power_correction_value = nil
}

// SpecialMovePowerCorrectionValue returns the value of the "special_move_power_correction_value" field in the mutation.
func (m *AbilitiesMutation) SpecialMovePowerCorrectionValue() (r int, exists bool) {
	v := m.special_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialMovePowerCorrectionValue returns the old "special_move_power_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldSpecialMovePowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialMovePowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialMovePowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialMovePowerCorrectionValue: %w", err)
	}
	return oldValue.SpecialMovePowerCorrectionValue, nil
}

// AddSpecialMovePowerCorrectionValue adds i to the "special_move_power_correction_value" field.
func (m *AbilitiesMutation) AddSpecialMovePowerCorrectionValue(i int) {
	if m.addspecial_move_power_correction_value != nil {
		*m.addspecial_move_power_correction_value += i
	} else {
		m.addspecial_move_power_correction_value = &i
	}
}

// AddedSpecialMovePowerCorrectionValue returns the value that was added to the "special_move_power_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedSpecialMovePowerCorrectionValue() (r int, exists bool) {
	v := m.addspecial_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialMovePowerCorrectionValue resets all changes to the "special_move_power_correction_value" field.
func (m *AbilitiesMutation) ResetSpecialMovePowerCorrectionValue() {
	m.special_move_power_correction_value = nil
	m.addspecial_move_power_correction_value = nil
}

// SetAttackPowerCorrectionValue sets the "attack_power_correction_value" field.
func (m *AbilitiesMutation) SetAttackPowerCorrectionValue(i int) {
	m.attack_power_correction_value = &i
	m.addattack_power_correction_value = nil
}

// AttackPowerCorrectionValue returns the value of the "attack_power_correction_value" field in the mutation.
func (m *AbilitiesMutation) AttackPowerCorrectionValue() (r int, exists bool) {
	v := m.attack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAttackPowerCorrectionValue returns the old "attack_power_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldAttackPowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttackPowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttackPowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttackPowerCorrectionValue: %w", err)
	}
	return oldValue.AttackPowerCorrectionValue, nil
}

// AddAttackPowerCorrectionValue adds i to the "attack_power_correction_value" field.
func (m *AbilitiesMutation) AddAttackPowerCorrectionValue(i int) {
	if m.addattack_power_correction_value != nil {
		*m.addattack_power_correction_value += i
	} else {
		m.addattack_power_correction_value = &i
	}
}

// AddedAttackPowerCorrectionValue returns the value that was added to the "attack_power_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedAttackPowerCorrectionValue() (r int, exists bool) {
	v := m.addattack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttackPowerCorrectionValue resets all changes to the "attack_power_correction_value" field.
func (m *AbilitiesMutation) ResetAttackPowerCorrectionValue() {
	m.attack_power_correction_value = nil
	m.addattack_power_correction_value = nil
}

// SetSpecialAttackPowerCorrectionValue sets the "special_attack_power_correction_value" field.
func (m *AbilitiesMutation) SetSpecialAttackPowerCorrectionValue(i int) {
	m.special_attack_power_correction_value = &i
	m.addspecial_attack_power_correction_value = nil
}

// SpecialAttackPowerCorrectionValue returns the value of the "special_attack_power_correction_value" field in the mutation.
func (m *AbilitiesMutation) SpecialAttackPowerCorrectionValue() (r int, exists bool) {
	v := m.special_attack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialAttackPowerCorrectionValue returns the old "special_attack_power_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldSpecialAttackPowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialAttackPowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialAttackPowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialAttackPowerCorrectionValue: %w", err)
	}
	return oldValue.SpecialAttackPowerCorrectionValue, nil
}

// AddSpecialAttackPowerCorrectionValue adds i to the "special_attack_power_correction_value" field.
func (m *AbilitiesMutation) AddSpecialAttackPowerCorrectionValue(i int) {
	if m.addspecial_attack_power_correction_value != nil {
		*m.addspecial_attack_power_correction_value += i
	} else {
		m.addspecial_attack_power_correction_value = &i
	}
}

// AddedSpecialAttackPowerCorrectionValue returns the value that was added to the "special_attack_power_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedSpecialAttackPowerCorrectionValue() (r int, exists bool) {
	v := m.addspecial_attack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialAttackPowerCorrectionValue resets all changes to the "special_attack_power_correction_value" field.
func (m *AbilitiesMutation) ResetSpecialAttackPowerCorrectionValue() {
	m.special_attack_power_correction_value = nil
	m.addspecial_attack_power_correction_value = nil
}

// SetAttackCorrectionValue sets the "attack_correction_value" field.
func (m *AbilitiesMutation) SetAttackCorrectionValue(i int) {
	m.attack_correction_value = &i
	m.addattack_correction_value = nil
}

// AttackCorrectionValue returns the value of the "attack_correction_value" field in the mutation.
func (m *AbilitiesMutation) AttackCorrectionValue() (r int, exists bool) {
	v := m.attack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAttackCorrectionValue returns the old "attack_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldAttackCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttackCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttackCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttackCorrectionValue: %w", err)
	}
	return oldValue.AttackCorrectionValue, nil
}

// AddAttackCorrectionValue adds i to the "attack_correction_value" field.
func (m *AbilitiesMutation) AddAttackCorrectionValue(i int) {
	if m.addattack_correction_value != nil {
		*m.addattack_correction_value += i
	} else {
		m.addattack_correction_value = &i
	}
}

// AddedAttackCorrectionValue returns the value that was added to the "attack_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedAttackCorrectionValue() (r int, exists bool) {
	v := m.addattack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttackCorrectionValue resets all changes to the "attack_correction_value" field.
func (m *AbilitiesMutation) ResetAttackCorrectionValue() {
	m.attack_correction_value = nil
	m.addattack_correction_value = nil
}

// SetSpecialAttackCorrectionValue sets the "special_attack_correction_value" field.
func (m *AbilitiesMutation) SetSpecialAttackCorrectionValue(i int) {
	m.special_attack_correction_value = &i
	m.addspecial_attack_correction_value = nil
}

// SpecialAttackCorrectionValue returns the value of the "special_attack_correction_value" field in the mutation.
func (m *AbilitiesMutation) SpecialAttackCorrectionValue() (r int, exists bool) {
	v := m.special_attack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialAttackCorrectionValue returns the old "special_attack_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldSpecialAttackCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialAttackCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialAttackCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialAttackCorrectionValue: %w", err)
	}
	return oldValue.SpecialAttackCorrectionValue, nil
}

// AddSpecialAttackCorrectionValue adds i to the "special_attack_correction_value" field.
func (m *AbilitiesMutation) AddSpecialAttackCorrectionValue(i int) {
	if m.addspecial_attack_correction_value != nil {
		*m.addspecial_attack_correction_value += i
	} else {
		m.addspecial_attack_correction_value = &i
	}
}

// AddedSpecialAttackCorrectionValue returns the value that was added to the "special_attack_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedSpecialAttackCorrectionValue() (r int, exists bool) {
	v := m.addspecial_attack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialAttackCorrectionValue resets all changes to the "special_attack_correction_value" field.
func (m *AbilitiesMutation) ResetSpecialAttackCorrectionValue() {
	m.special_attack_correction_value = nil
	m.addspecial_attack_correction_value = nil
}

// SetDeffenseCorrectionValue sets the "deffense_correction_value" field.
func (m *AbilitiesMutation) SetDeffenseCorrectionValue(i int) {
	m.deffense_correction_value = &i
	m.adddeffense_correction_value = nil
}

// DeffenseCorrectionValue returns the value of the "deffense_correction_value" field in the mutation.
func (m *AbilitiesMutation) DeffenseCorrectionValue() (r int, exists bool) {
	v := m.deffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDeffenseCorrectionValue returns the old "deffense_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldDeffenseCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeffenseCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeffenseCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeffenseCorrectionValue: %w", err)
	}
	return oldValue.DeffenseCorrectionValue, nil
}

// AddDeffenseCorrectionValue adds i to the "deffense_correction_value" field.
func (m *AbilitiesMutation) AddDeffenseCorrectionValue(i int) {
	if m.adddeffense_correction_value != nil {
		*m.adddeffense_correction_value += i
	} else {
		m.adddeffense_correction_value = &i
	}
}

// AddedDeffenseCorrectionValue returns the value that was added to the "deffense_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedDeffenseCorrectionValue() (r int, exists bool) {
	v := m.adddeffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeffenseCorrectionValue resets all changes to the "deffense_correction_value" field.
func (m *AbilitiesMutation) ResetDeffenseCorrectionValue() {
	m.deffense_correction_value = nil
	m.adddeffense_correction_value = nil
}

// SetSpecialDeffenseCorrectionValue sets the "special_deffense_correction_value" field.
func (m *AbilitiesMutation) SetSpecialDeffenseCorrectionValue(i int) {
	m.special_deffense_correction_value = &i
	m.addspecial_deffense_correction_value = nil
}

// SpecialDeffenseCorrectionValue returns the value of the "special_deffense_correction_value" field in the mutation.
func (m *AbilitiesMutation) SpecialDeffenseCorrectionValue() (r int, exists bool) {
	v := m.special_deffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialDeffenseCorrectionValue returns the old "special_deffense_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldSpecialDeffenseCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialDeffenseCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialDeffenseCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialDeffenseCorrectionValue: %w", err)
	}
	return oldValue.SpecialDeffenseCorrectionValue, nil
}

// AddSpecialDeffenseCorrectionValue adds i to the "special_deffense_correction_value" field.
func (m *AbilitiesMutation) AddSpecialDeffenseCorrectionValue(i int) {
	if m.addspecial_deffense_correction_value != nil {
		*m.addspecial_deffense_correction_value += i
	} else {
		m.addspecial_deffense_correction_value = &i
	}
}

// AddedSpecialDeffenseCorrectionValue returns the value that was added to the "special_deffense_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedSpecialDeffenseCorrectionValue() (r int, exists bool) {
	v := m.addspecial_deffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialDeffenseCorrectionValue resets all changes to the "special_deffense_correction_value" field.
func (m *AbilitiesMutation) ResetSpecialDeffenseCorrectionValue() {
	m.special_deffense_correction_value = nil
	m.addspecial_deffense_correction_value = nil
}

// SetDamageCorrectionType1 sets the "damage_correction_type1" field.
func (m *AbilitiesMutation) SetDamageCorrectionType1(pr property.Types) {
	m.damage_correction_type1 = &pr
}

// DamageCorrectionType1 returns the value of the "damage_correction_type1" field in the mutation.
func (m *AbilitiesMutation) DamageCorrectionType1() (r property.Types, exists bool) {
	v := m.damage_correction_type1
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionType1 returns the old "damage_correction_type1" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldDamageCorrectionType1(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionType1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionType1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionType1: %w", err)
	}
	return oldValue.DamageCorrectionType1, nil
}

// ResetDamageCorrectionType1 resets all changes to the "damage_correction_type1" field.
func (m *AbilitiesMutation) ResetDamageCorrectionType1() {
	m.damage_correction_type1 = nil
}

// SetDamageCorrectionValue1 sets the "damage_correction_value1" field.
func (m *AbilitiesMutation) SetDamageCorrectionValue1(i int) {
	m.damage_correction_value1 = &i
	m.adddamage_correction_value1 = nil
}

// DamageCorrectionValue1 returns the value of the "damage_correction_value1" field in the mutation.
func (m *AbilitiesMutation) DamageCorrectionValue1() (r int, exists bool) {
	v := m.damage_correction_value1
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionValue1 returns the old "damage_correction_value1" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldDamageCorrectionValue1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionValue1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionValue1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionValue1: %w", err)
	}
	return oldValue.DamageCorrectionValue1, nil
}

// AddDamageCorrectionValue1 adds i to the "damage_correction_value1" field.
func (m *AbilitiesMutation) AddDamageCorrectionValue1(i int) {
	if m.adddamage_correction_value1 != nil {
		*m.adddamage_correction_value1 += i
	} else {
		m.adddamage_correction_value1 = &i
	}
}

// AddedDamageCorrectionValue1 returns the value that was added to the "damage_correction_value1" field in this mutation.
func (m *AbilitiesMutation) AddedDamageCorrectionValue1() (r int, exists bool) {
	v := m.adddamage_correction_value1
	if v == nil {
		return
	}
	return *v, true
}

// ResetDamageCorrectionValue1 resets all changes to the "damage_correction_value1" field.
func (m *AbilitiesMutation) ResetDamageCorrectionValue1() {
	m.damage_correction_value1 = nil
	m.adddamage_correction_value1 = nil
}

// SetDamageCorrectionType2 sets the "damage_correction_type2" field.
func (m *AbilitiesMutation) SetDamageCorrectionType2(pr property.Types) {
	m.damage_correction_type2 = &pr
}

// DamageCorrectionType2 returns the value of the "damage_correction_type2" field in the mutation.
func (m *AbilitiesMutation) DamageCorrectionType2() (r property.Types, exists bool) {
	v := m.damage_correction_type2
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionType2 returns the old "damage_correction_type2" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldDamageCorrectionType2(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionType2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionType2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionType2: %w", err)
	}
	return oldValue.DamageCorrectionType2, nil
}

// ClearDamageCorrectionType2 clears the value of the "damage_correction_type2" field.
func (m *AbilitiesMutation) ClearDamageCorrectionType2() {
	m.damage_correction_type2 = nil
	m.clearedFields[abilities.FieldDamageCorrectionType2] = struct{}{}
}

// DamageCorrectionType2Cleared returns if the "damage_correction_type2" field was cleared in this mutation.
func (m *AbilitiesMutation) DamageCorrectionType2Cleared() bool {
	_, ok := m.clearedFields[abilities.FieldDamageCorrectionType2]
	return ok
}

// ResetDamageCorrectionType2 resets all changes to the "damage_correction_type2" field.
func (m *AbilitiesMutation) ResetDamageCorrectionType2() {
	m.damage_correction_type2 = nil
	delete(m.clearedFields, abilities.FieldDamageCorrectionType2)
}

// SetDamageCorrectionValue2 sets the "damage_correction_value2" field.
func (m *AbilitiesMutation) SetDamageCorrectionValue2(i int) {
	m.damage_correction_value2 = &i
	m.adddamage_correction_value2 = nil
}

// DamageCorrectionValue2 returns the value of the "damage_correction_value2" field in the mutation.
func (m *AbilitiesMutation) DamageCorrectionValue2() (r int, exists bool) {
	v := m.damage_correction_value2
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionValue2 returns the old "damage_correction_value2" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldDamageCorrectionValue2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionValue2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionValue2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionValue2: %w", err)
	}
	return oldValue.DamageCorrectionValue2, nil
}

// AddDamageCorrectionValue2 adds i to the "damage_correction_value2" field.
func (m *AbilitiesMutation) AddDamageCorrectionValue2(i int) {
	if m.adddamage_correction_value2 != nil {
		*m.adddamage_correction_value2 += i
	} else {
		m.adddamage_correction_value2 = &i
	}
}

// AddedDamageCorrectionValue2 returns the value that was added to the "damage_correction_value2" field in this mutation.
func (m *AbilitiesMutation) AddedDamageCorrectionValue2() (r int, exists bool) {
	v := m.adddamage_correction_value2
	if v == nil {
		return
	}
	return *v, true
}

// ClearDamageCorrectionValue2 clears the value of the "damage_correction_value2" field.
func (m *AbilitiesMutation) ClearDamageCorrectionValue2() {
	m.damage_correction_value2 = nil
	m.adddamage_correction_value2 = nil
	m.clearedFields[abilities.FieldDamageCorrectionValue2] = struct{}{}
}

// DamageCorrectionValue2Cleared returns if the "damage_correction_value2" field was cleared in this mutation.
func (m *AbilitiesMutation) DamageCorrectionValue2Cleared() bool {
	_, ok := m.clearedFields[abilities.FieldDamageCorrectionValue2]
	return ok
}

// ResetDamageCorrectionValue2 resets all changes to the "damage_correction_value2" field.
func (m *AbilitiesMutation) ResetDamageCorrectionValue2() {
	m.damage_correction_value2 = nil
	m.adddamage_correction_value2 = nil
	delete(m.clearedFields, abilities.FieldDamageCorrectionValue2)
}

// SetWeightCorrectionValue sets the "weight_correction_value" field.
func (m *AbilitiesMutation) SetWeightCorrectionValue(i int) {
	m.weight_correction_value = &i
	m.addweight_correction_value = nil
}

// WeightCorrectionValue returns the value of the "weight_correction_value" field in the mutation.
func (m *AbilitiesMutation) WeightCorrectionValue() (r int, exists bool) {
	v := m.weight_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightCorrectionValue returns the old "weight_correction_value" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldWeightCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightCorrectionValue: %w", err)
	}
	return oldValue.WeightCorrectionValue, nil
}

// AddWeightCorrectionValue adds i to the "weight_correction_value" field.
func (m *AbilitiesMutation) AddWeightCorrectionValue(i int) {
	if m.addweight_correction_value != nil {
		*m.addweight_correction_value += i
	} else {
		m.addweight_correction_value = &i
	}
}

// AddedWeightCorrectionValue returns the value that was added to the "weight_correction_value" field in this mutation.
func (m *AbilitiesMutation) AddedWeightCorrectionValue() (r int, exists bool) {
	v := m.addweight_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightCorrectionValue resets all changes to the "weight_correction_value" field.
func (m *AbilitiesMutation) ResetWeightCorrectionValue() {
	m.weight_correction_value = nil
	m.addweight_correction_value = nil
}

// SetName sets the "name" field.
func (m *AbilitiesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AbilitiesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AbilitiesMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AbilitiesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AbilitiesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Abilities entity.
// If the Abilities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilitiesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AbilitiesMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[abilities.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AbilitiesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[abilities.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AbilitiesMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, abilities.FieldDescription)
}

// AddAbilityHolder1IDs adds the "ability_holder1" edge to the Pokemons entity by ids.
func (m *AbilitiesMutation) AddAbilityHolder1IDs(ids ...int) {
	if m.ability_holder1 == nil {
		m.ability_holder1 = make(map[int]struct{})
	}
	for i := range ids {
		m.ability_holder1[ids[i]] = struct{}{}
	}
}

// ClearAbilityHolder1 clears the "ability_holder1" edge to the Pokemons entity.
func (m *AbilitiesMutation) ClearAbilityHolder1() {
	m.clearedability_holder1 = true
}

// AbilityHolder1Cleared reports if the "ability_holder1" edge to the Pokemons entity was cleared.
func (m *AbilitiesMutation) AbilityHolder1Cleared() bool {
	return m.clearedability_holder1
}

// RemoveAbilityHolder1IDs removes the "ability_holder1" edge to the Pokemons entity by IDs.
func (m *AbilitiesMutation) RemoveAbilityHolder1IDs(ids ...int) {
	if m.removedability_holder1 == nil {
		m.removedability_holder1 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ability_holder1, ids[i])
		m.removedability_holder1[ids[i]] = struct{}{}
	}
}

// RemovedAbilityHolder1 returns the removed IDs of the "ability_holder1" edge to the Pokemons entity.
func (m *AbilitiesMutation) RemovedAbilityHolder1IDs() (ids []int) {
	for id := range m.removedability_holder1 {
		ids = append(ids, id)
	}
	return
}

// AbilityHolder1IDs returns the "ability_holder1" edge IDs in the mutation.
func (m *AbilitiesMutation) AbilityHolder1IDs() (ids []int) {
	for id := range m.ability_holder1 {
		ids = append(ids, id)
	}
	return
}

// ResetAbilityHolder1 resets all changes to the "ability_holder1" edge.
func (m *AbilitiesMutation) ResetAbilityHolder1() {
	m.ability_holder1 = nil
	m.clearedability_holder1 = false
	m.removedability_holder1 = nil
}

// AddAbilityHolder2IDs adds the "ability_holder2" edge to the Pokemons entity by ids.
func (m *AbilitiesMutation) AddAbilityHolder2IDs(ids ...int) {
	if m.ability_holder2 == nil {
		m.ability_holder2 = make(map[int]struct{})
	}
	for i := range ids {
		m.ability_holder2[ids[i]] = struct{}{}
	}
}

// ClearAbilityHolder2 clears the "ability_holder2" edge to the Pokemons entity.
func (m *AbilitiesMutation) ClearAbilityHolder2() {
	m.clearedability_holder2 = true
}

// AbilityHolder2Cleared reports if the "ability_holder2" edge to the Pokemons entity was cleared.
func (m *AbilitiesMutation) AbilityHolder2Cleared() bool {
	return m.clearedability_holder2
}

// RemoveAbilityHolder2IDs removes the "ability_holder2" edge to the Pokemons entity by IDs.
func (m *AbilitiesMutation) RemoveAbilityHolder2IDs(ids ...int) {
	if m.removedability_holder2 == nil {
		m.removedability_holder2 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ability_holder2, ids[i])
		m.removedability_holder2[ids[i]] = struct{}{}
	}
}

// RemovedAbilityHolder2 returns the removed IDs of the "ability_holder2" edge to the Pokemons entity.
func (m *AbilitiesMutation) RemovedAbilityHolder2IDs() (ids []int) {
	for id := range m.removedability_holder2 {
		ids = append(ids, id)
	}
	return
}

// AbilityHolder2IDs returns the "ability_holder2" edge IDs in the mutation.
func (m *AbilitiesMutation) AbilityHolder2IDs() (ids []int) {
	for id := range m.ability_holder2 {
		ids = append(ids, id)
	}
	return
}

// ResetAbilityHolder2 resets all changes to the "ability_holder2" edge.
func (m *AbilitiesMutation) ResetAbilityHolder2() {
	m.ability_holder2 = nil
	m.clearedability_holder2 = false
	m.removedability_holder2 = nil
}

// AddHiddenAbilityHolderIDs adds the "hidden_ability_holder" edge to the Pokemons entity by ids.
func (m *AbilitiesMutation) AddHiddenAbilityHolderIDs(ids ...int) {
	if m.hidden_ability_holder == nil {
		m.hidden_ability_holder = make(map[int]struct{})
	}
	for i := range ids {
		m.hidden_ability_holder[ids[i]] = struct{}{}
	}
}

// ClearHiddenAbilityHolder clears the "hidden_ability_holder" edge to the Pokemons entity.
func (m *AbilitiesMutation) ClearHiddenAbilityHolder() {
	m.clearedhidden_ability_holder = true
}

// HiddenAbilityHolderCleared reports if the "hidden_ability_holder" edge to the Pokemons entity was cleared.
func (m *AbilitiesMutation) HiddenAbilityHolderCleared() bool {
	return m.clearedhidden_ability_holder
}

// RemoveHiddenAbilityHolderIDs removes the "hidden_ability_holder" edge to the Pokemons entity by IDs.
func (m *AbilitiesMutation) RemoveHiddenAbilityHolderIDs(ids ...int) {
	if m.removedhidden_ability_holder == nil {
		m.removedhidden_ability_holder = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hidden_ability_holder, ids[i])
		m.removedhidden_ability_holder[ids[i]] = struct{}{}
	}
}

// RemovedHiddenAbilityHolder returns the removed IDs of the "hidden_ability_holder" edge to the Pokemons entity.
func (m *AbilitiesMutation) RemovedHiddenAbilityHolderIDs() (ids []int) {
	for id := range m.removedhidden_ability_holder {
		ids = append(ids, id)
	}
	return
}

// HiddenAbilityHolderIDs returns the "hidden_ability_holder" edge IDs in the mutation.
func (m *AbilitiesMutation) HiddenAbilityHolderIDs() (ids []int) {
	for id := range m.hidden_ability_holder {
		ids = append(ids, id)
	}
	return
}

// ResetHiddenAbilityHolder resets all changes to the "hidden_ability_holder" edge.
func (m *AbilitiesMutation) ResetHiddenAbilityHolder() {
	m.hidden_ability_holder = nil
	m.clearedhidden_ability_holder = false
	m.removedhidden_ability_holder = nil
}

// AddToTrainedPokemonAbilityIDs adds the "to_trained_pokemon_ability" edge to the TrainedPokemonDetails entity by ids.
func (m *AbilitiesMutation) AddToTrainedPokemonAbilityIDs(ids ...int) {
	if m.to_trained_pokemon_ability == nil {
		m.to_trained_pokemon_ability = make(map[int]struct{})
	}
	for i := range ids {
		m.to_trained_pokemon_ability[ids[i]] = struct{}{}
	}
}

// ClearToTrainedPokemonAbility clears the "to_trained_pokemon_ability" edge to the TrainedPokemonDetails entity.
func (m *AbilitiesMutation) ClearToTrainedPokemonAbility() {
	m.clearedto_trained_pokemon_ability = true
}

// ToTrainedPokemonAbilityCleared reports if the "to_trained_pokemon_ability" edge to the TrainedPokemonDetails entity was cleared.
func (m *AbilitiesMutation) ToTrainedPokemonAbilityCleared() bool {
	return m.clearedto_trained_pokemon_ability
}

// RemoveToTrainedPokemonAbilityIDs removes the "to_trained_pokemon_ability" edge to the TrainedPokemonDetails entity by IDs.
func (m *AbilitiesMutation) RemoveToTrainedPokemonAbilityIDs(ids ...int) {
	if m.removedto_trained_pokemon_ability == nil {
		m.removedto_trained_pokemon_ability = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_trained_pokemon_ability, ids[i])
		m.removedto_trained_pokemon_ability[ids[i]] = struct{}{}
	}
}

// RemovedToTrainedPokemonAbility returns the removed IDs of the "to_trained_pokemon_ability" edge to the TrainedPokemonDetails entity.
func (m *AbilitiesMutation) RemovedToTrainedPokemonAbilityIDs() (ids []int) {
	for id := range m.removedto_trained_pokemon_ability {
		ids = append(ids, id)
	}
	return
}

// ToTrainedPokemonAbilityIDs returns the "to_trained_pokemon_ability" edge IDs in the mutation.
func (m *AbilitiesMutation) ToTrainedPokemonAbilityIDs() (ids []int) {
	for id := range m.to_trained_pokemon_ability {
		ids = append(ids, id)
	}
	return
}

// ResetToTrainedPokemonAbility resets all changes to the "to_trained_pokemon_ability" edge.
func (m *AbilitiesMutation) ResetToTrainedPokemonAbility() {
	m.to_trained_pokemon_ability = nil
	m.clearedto_trained_pokemon_ability = false
	m.removedto_trained_pokemon_ability = nil
}

// Where appends a list predicates to the AbilitiesMutation builder.
func (m *AbilitiesMutation) Where(ps ...predicate.Abilities) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AbilitiesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Abilities).
func (m *AbilitiesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbilitiesMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.physical_move_power_correction_value != nil {
		fields = append(fields, abilities.FieldPhysicalMovePowerCorrectionValue)
	}
	if m.special_move_power_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialMovePowerCorrectionValue)
	}
	if m.attack_power_correction_value != nil {
		fields = append(fields, abilities.FieldAttackPowerCorrectionValue)
	}
	if m.special_attack_power_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialAttackPowerCorrectionValue)
	}
	if m.attack_correction_value != nil {
		fields = append(fields, abilities.FieldAttackCorrectionValue)
	}
	if m.special_attack_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialAttackCorrectionValue)
	}
	if m.deffense_correction_value != nil {
		fields = append(fields, abilities.FieldDeffenseCorrectionValue)
	}
	if m.special_deffense_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialDeffenseCorrectionValue)
	}
	if m.damage_correction_type1 != nil {
		fields = append(fields, abilities.FieldDamageCorrectionType1)
	}
	if m.damage_correction_value1 != nil {
		fields = append(fields, abilities.FieldDamageCorrectionValue1)
	}
	if m.damage_correction_type2 != nil {
		fields = append(fields, abilities.FieldDamageCorrectionType2)
	}
	if m.damage_correction_value2 != nil {
		fields = append(fields, abilities.FieldDamageCorrectionValue2)
	}
	if m.weight_correction_value != nil {
		fields = append(fields, abilities.FieldWeightCorrectionValue)
	}
	if m.name != nil {
		fields = append(fields, abilities.FieldName)
	}
	if m.description != nil {
		fields = append(fields, abilities.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbilitiesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abilities.FieldPhysicalMovePowerCorrectionValue:
		return m.PhysicalMovePowerCorrectionValue()
	case abilities.FieldSpecialMovePowerCorrectionValue:
		return m.SpecialMovePowerCorrectionValue()
	case abilities.FieldAttackPowerCorrectionValue:
		return m.AttackPowerCorrectionValue()
	case abilities.FieldSpecialAttackPowerCorrectionValue:
		return m.SpecialAttackPowerCorrectionValue()
	case abilities.FieldAttackCorrectionValue:
		return m.AttackCorrectionValue()
	case abilities.FieldSpecialAttackCorrectionValue:
		return m.SpecialAttackCorrectionValue()
	case abilities.FieldDeffenseCorrectionValue:
		return m.DeffenseCorrectionValue()
	case abilities.FieldSpecialDeffenseCorrectionValue:
		return m.SpecialDeffenseCorrectionValue()
	case abilities.FieldDamageCorrectionType1:
		return m.DamageCorrectionType1()
	case abilities.FieldDamageCorrectionValue1:
		return m.DamageCorrectionValue1()
	case abilities.FieldDamageCorrectionType2:
		return m.DamageCorrectionType2()
	case abilities.FieldDamageCorrectionValue2:
		return m.DamageCorrectionValue2()
	case abilities.FieldWeightCorrectionValue:
		return m.WeightCorrectionValue()
	case abilities.FieldName:
		return m.Name()
	case abilities.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbilitiesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abilities.FieldPhysicalMovePowerCorrectionValue:
		return m.OldPhysicalMovePowerCorrectionValue(ctx)
	case abilities.FieldSpecialMovePowerCorrectionValue:
		return m.OldSpecialMovePowerCorrectionValue(ctx)
	case abilities.FieldAttackPowerCorrectionValue:
		return m.OldAttackPowerCorrectionValue(ctx)
	case abilities.FieldSpecialAttackPowerCorrectionValue:
		return m.OldSpecialAttackPowerCorrectionValue(ctx)
	case abilities.FieldAttackCorrectionValue:
		return m.OldAttackCorrectionValue(ctx)
	case abilities.FieldSpecialAttackCorrectionValue:
		return m.OldSpecialAttackCorrectionValue(ctx)
	case abilities.FieldDeffenseCorrectionValue:
		return m.OldDeffenseCorrectionValue(ctx)
	case abilities.FieldSpecialDeffenseCorrectionValue:
		return m.OldSpecialDeffenseCorrectionValue(ctx)
	case abilities.FieldDamageCorrectionType1:
		return m.OldDamageCorrectionType1(ctx)
	case abilities.FieldDamageCorrectionValue1:
		return m.OldDamageCorrectionValue1(ctx)
	case abilities.FieldDamageCorrectionType2:
		return m.OldDamageCorrectionType2(ctx)
	case abilities.FieldDamageCorrectionValue2:
		return m.OldDamageCorrectionValue2(ctx)
	case abilities.FieldWeightCorrectionValue:
		return m.OldWeightCorrectionValue(ctx)
	case abilities.FieldName:
		return m.OldName(ctx)
	case abilities.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Abilities field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilitiesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abilities.FieldPhysicalMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicalMovePowerCorrectionValue(v)
		return nil
	case abilities.FieldSpecialMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialMovePowerCorrectionValue(v)
		return nil
	case abilities.FieldAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttackPowerCorrectionValue(v)
		return nil
	case abilities.FieldSpecialAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialAttackPowerCorrectionValue(v)
		return nil
	case abilities.FieldAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttackCorrectionValue(v)
		return nil
	case abilities.FieldSpecialAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialAttackCorrectionValue(v)
		return nil
	case abilities.FieldDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeffenseCorrectionValue(v)
		return nil
	case abilities.FieldSpecialDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialDeffenseCorrectionValue(v)
		return nil
	case abilities.FieldDamageCorrectionType1:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionType1(v)
		return nil
	case abilities.FieldDamageCorrectionValue1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionValue1(v)
		return nil
	case abilities.FieldDamageCorrectionType2:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionType2(v)
		return nil
	case abilities.FieldDamageCorrectionValue2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionValue2(v)
		return nil
	case abilities.FieldWeightCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightCorrectionValue(v)
		return nil
	case abilities.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abilities.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Abilities field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbilitiesMutation) AddedFields() []string {
	var fields []string
	if m.addphysical_move_power_correction_value != nil {
		fields = append(fields, abilities.FieldPhysicalMovePowerCorrectionValue)
	}
	if m.addspecial_move_power_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialMovePowerCorrectionValue)
	}
	if m.addattack_power_correction_value != nil {
		fields = append(fields, abilities.FieldAttackPowerCorrectionValue)
	}
	if m.addspecial_attack_power_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialAttackPowerCorrectionValue)
	}
	if m.addattack_correction_value != nil {
		fields = append(fields, abilities.FieldAttackCorrectionValue)
	}
	if m.addspecial_attack_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialAttackCorrectionValue)
	}
	if m.adddeffense_correction_value != nil {
		fields = append(fields, abilities.FieldDeffenseCorrectionValue)
	}
	if m.addspecial_deffense_correction_value != nil {
		fields = append(fields, abilities.FieldSpecialDeffenseCorrectionValue)
	}
	if m.adddamage_correction_value1 != nil {
		fields = append(fields, abilities.FieldDamageCorrectionValue1)
	}
	if m.adddamage_correction_value2 != nil {
		fields = append(fields, abilities.FieldDamageCorrectionValue2)
	}
	if m.addweight_correction_value != nil {
		fields = append(fields, abilities.FieldWeightCorrectionValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbilitiesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abilities.FieldPhysicalMovePowerCorrectionValue:
		return m.AddedPhysicalMovePowerCorrectionValue()
	case abilities.FieldSpecialMovePowerCorrectionValue:
		return m.AddedSpecialMovePowerCorrectionValue()
	case abilities.FieldAttackPowerCorrectionValue:
		return m.AddedAttackPowerCorrectionValue()
	case abilities.FieldSpecialAttackPowerCorrectionValue:
		return m.AddedSpecialAttackPowerCorrectionValue()
	case abilities.FieldAttackCorrectionValue:
		return m.AddedAttackCorrectionValue()
	case abilities.FieldSpecialAttackCorrectionValue:
		return m.AddedSpecialAttackCorrectionValue()
	case abilities.FieldDeffenseCorrectionValue:
		return m.AddedDeffenseCorrectionValue()
	case abilities.FieldSpecialDeffenseCorrectionValue:
		return m.AddedSpecialDeffenseCorrectionValue()
	case abilities.FieldDamageCorrectionValue1:
		return m.AddedDamageCorrectionValue1()
	case abilities.FieldDamageCorrectionValue2:
		return m.AddedDamageCorrectionValue2()
	case abilities.FieldWeightCorrectionValue:
		return m.AddedWeightCorrectionValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilitiesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abilities.FieldPhysicalMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhysicalMovePowerCorrectionValue(v)
		return nil
	case abilities.FieldSpecialMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialMovePowerCorrectionValue(v)
		return nil
	case abilities.FieldAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttackPowerCorrectionValue(v)
		return nil
	case abilities.FieldSpecialAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialAttackPowerCorrectionValue(v)
		return nil
	case abilities.FieldAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttackCorrectionValue(v)
		return nil
	case abilities.FieldSpecialAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialAttackCorrectionValue(v)
		return nil
	case abilities.FieldDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeffenseCorrectionValue(v)
		return nil
	case abilities.FieldSpecialDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialDeffenseCorrectionValue(v)
		return nil
	case abilities.FieldDamageCorrectionValue1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDamageCorrectionValue1(v)
		return nil
	case abilities.FieldDamageCorrectionValue2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDamageCorrectionValue2(v)
		return nil
	case abilities.FieldWeightCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightCorrectionValue(v)
		return nil
	}
	return fmt.Errorf("unknown Abilities numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbilitiesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(abilities.FieldDamageCorrectionType2) {
		fields = append(fields, abilities.FieldDamageCorrectionType2)
	}
	if m.FieldCleared(abilities.FieldDamageCorrectionValue2) {
		fields = append(fields, abilities.FieldDamageCorrectionValue2)
	}
	if m.FieldCleared(abilities.FieldDescription) {
		fields = append(fields, abilities.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbilitiesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbilitiesMutation) ClearField(name string) error {
	switch name {
	case abilities.FieldDamageCorrectionType2:
		m.ClearDamageCorrectionType2()
		return nil
	case abilities.FieldDamageCorrectionValue2:
		m.ClearDamageCorrectionValue2()
		return nil
	case abilities.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Abilities nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbilitiesMutation) ResetField(name string) error {
	switch name {
	case abilities.FieldPhysicalMovePowerCorrectionValue:
		m.ResetPhysicalMovePowerCorrectionValue()
		return nil
	case abilities.FieldSpecialMovePowerCorrectionValue:
		m.ResetSpecialMovePowerCorrectionValue()
		return nil
	case abilities.FieldAttackPowerCorrectionValue:
		m.ResetAttackPowerCorrectionValue()
		return nil
	case abilities.FieldSpecialAttackPowerCorrectionValue:
		m.ResetSpecialAttackPowerCorrectionValue()
		return nil
	case abilities.FieldAttackCorrectionValue:
		m.ResetAttackCorrectionValue()
		return nil
	case abilities.FieldSpecialAttackCorrectionValue:
		m.ResetSpecialAttackCorrectionValue()
		return nil
	case abilities.FieldDeffenseCorrectionValue:
		m.ResetDeffenseCorrectionValue()
		return nil
	case abilities.FieldSpecialDeffenseCorrectionValue:
		m.ResetSpecialDeffenseCorrectionValue()
		return nil
	case abilities.FieldDamageCorrectionType1:
		m.ResetDamageCorrectionType1()
		return nil
	case abilities.FieldDamageCorrectionValue1:
		m.ResetDamageCorrectionValue1()
		return nil
	case abilities.FieldDamageCorrectionType2:
		m.ResetDamageCorrectionType2()
		return nil
	case abilities.FieldDamageCorrectionValue2:
		m.ResetDamageCorrectionValue2()
		return nil
	case abilities.FieldWeightCorrectionValue:
		m.ResetWeightCorrectionValue()
		return nil
	case abilities.FieldName:
		m.ResetName()
		return nil
	case abilities.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Abilities field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbilitiesMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.ability_holder1 != nil {
		edges = append(edges, abilities.EdgeAbilityHolder1)
	}
	if m.ability_holder2 != nil {
		edges = append(edges, abilities.EdgeAbilityHolder2)
	}
	if m.hidden_ability_holder != nil {
		edges = append(edges, abilities.EdgeHiddenAbilityHolder)
	}
	if m.to_trained_pokemon_ability != nil {
		edges = append(edges, abilities.EdgeToTrainedPokemonAbility)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbilitiesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abilities.EdgeAbilityHolder1:
		ids := make([]ent.Value, 0, len(m.ability_holder1))
		for id := range m.ability_holder1 {
			ids = append(ids, id)
		}
		return ids
	case abilities.EdgeAbilityHolder2:
		ids := make([]ent.Value, 0, len(m.ability_holder2))
		for id := range m.ability_holder2 {
			ids = append(ids, id)
		}
		return ids
	case abilities.EdgeHiddenAbilityHolder:
		ids := make([]ent.Value, 0, len(m.hidden_ability_holder))
		for id := range m.hidden_ability_holder {
			ids = append(ids, id)
		}
		return ids
	case abilities.EdgeToTrainedPokemonAbility:
		ids := make([]ent.Value, 0, len(m.to_trained_pokemon_ability))
		for id := range m.to_trained_pokemon_ability {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbilitiesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedability_holder1 != nil {
		edges = append(edges, abilities.EdgeAbilityHolder1)
	}
	if m.removedability_holder2 != nil {
		edges = append(edges, abilities.EdgeAbilityHolder2)
	}
	if m.removedhidden_ability_holder != nil {
		edges = append(edges, abilities.EdgeHiddenAbilityHolder)
	}
	if m.removedto_trained_pokemon_ability != nil {
		edges = append(edges, abilities.EdgeToTrainedPokemonAbility)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbilitiesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abilities.EdgeAbilityHolder1:
		ids := make([]ent.Value, 0, len(m.removedability_holder1))
		for id := range m.removedability_holder1 {
			ids = append(ids, id)
		}
		return ids
	case abilities.EdgeAbilityHolder2:
		ids := make([]ent.Value, 0, len(m.removedability_holder2))
		for id := range m.removedability_holder2 {
			ids = append(ids, id)
		}
		return ids
	case abilities.EdgeHiddenAbilityHolder:
		ids := make([]ent.Value, 0, len(m.removedhidden_ability_holder))
		for id := range m.removedhidden_ability_holder {
			ids = append(ids, id)
		}
		return ids
	case abilities.EdgeToTrainedPokemonAbility:
		ids := make([]ent.Value, 0, len(m.removedto_trained_pokemon_ability))
		for id := range m.removedto_trained_pokemon_ability {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbilitiesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedability_holder1 {
		edges = append(edges, abilities.EdgeAbilityHolder1)
	}
	if m.clearedability_holder2 {
		edges = append(edges, abilities.EdgeAbilityHolder2)
	}
	if m.clearedhidden_ability_holder {
		edges = append(edges, abilities.EdgeHiddenAbilityHolder)
	}
	if m.clearedto_trained_pokemon_ability {
		edges = append(edges, abilities.EdgeToTrainedPokemonAbility)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbilitiesMutation) EdgeCleared(name string) bool {
	switch name {
	case abilities.EdgeAbilityHolder1:
		return m.clearedability_holder1
	case abilities.EdgeAbilityHolder2:
		return m.clearedability_holder2
	case abilities.EdgeHiddenAbilityHolder:
		return m.clearedhidden_ability_holder
	case abilities.EdgeToTrainedPokemonAbility:
		return m.clearedto_trained_pokemon_ability
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbilitiesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Abilities unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbilitiesMutation) ResetEdge(name string) error {
	switch name {
	case abilities.EdgeAbilityHolder1:
		m.ResetAbilityHolder1()
		return nil
	case abilities.EdgeAbilityHolder2:
		m.ResetAbilityHolder2()
		return nil
	case abilities.EdgeHiddenAbilityHolder:
		m.ResetHiddenAbilityHolder()
		return nil
	case abilities.EdgeToTrainedPokemonAbility:
		m.ResetToTrainedPokemonAbility()
		return nil
	}
	return fmt.Errorf("unknown Abilities edge %s", name)
}

// BattleOpponentPartyMutation represents an operation that mutates the BattleOpponentParty nodes in the graph.
type BattleOpponentPartyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	opponent_pokemon_id1    *int
	addopponent_pokemon_id1 *int
	opponent_pokemon_id2    *int
	addopponent_pokemon_id2 *int
	opponent_pokemon_id3    *int
	addopponent_pokemon_id3 *int
	opponent_pokemon_id4    *int
	addopponent_pokemon_id4 *int
	opponent_pokemon_id5    *int
	addopponent_pokemon_id5 *int
	opponent_pokemon_id6    *int
	addopponent_pokemon_id6 *int
	clearedFields           map[string]struct{}
	battle_content          map[int]struct{}
	removedbattle_content   map[int]struct{}
	clearedbattle_content   bool
	done                    bool
	oldValue                func(context.Context) (*BattleOpponentParty, error)
	predicates              []predicate.BattleOpponentParty
}

var _ ent.Mutation = (*BattleOpponentPartyMutation)(nil)

// battleopponentpartyOption allows management of the mutation configuration using functional options.
type battleopponentpartyOption func(*BattleOpponentPartyMutation)

// newBattleOpponentPartyMutation creates new mutation for the BattleOpponentParty entity.
func newBattleOpponentPartyMutation(c config, op Op, opts ...battleopponentpartyOption) *BattleOpponentPartyMutation {
	m := &BattleOpponentPartyMutation{
		config:        c,
		op:            op,
		typ:           TypeBattleOpponentParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBattleOpponentPartyID sets the ID field of the mutation.
func withBattleOpponentPartyID(id int) battleopponentpartyOption {
	return func(m *BattleOpponentPartyMutation) {
		var (
			err   error
			once  sync.Once
			value *BattleOpponentParty
		)
		m.oldValue = func(ctx context.Context) (*BattleOpponentParty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BattleOpponentParty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBattleOpponentParty sets the old BattleOpponentParty of the mutation.
func withBattleOpponentParty(node *BattleOpponentParty) battleopponentpartyOption {
	return func(m *BattleOpponentPartyMutation) {
		m.oldValue = func(context.Context) (*BattleOpponentParty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BattleOpponentPartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BattleOpponentPartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BattleOpponentPartyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOpponentPokemonId1 sets the "opponent_pokemon_id1" field.
func (m *BattleOpponentPartyMutation) SetOpponentPokemonId1(i int) {
	m.opponent_pokemon_id1 = &i
	m.addopponent_pokemon_id1 = nil
}

// OpponentPokemonId1 returns the value of the "opponent_pokemon_id1" field in the mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId1() (r int, exists bool) {
	v := m.opponent_pokemon_id1
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentPokemonId1 returns the old "opponent_pokemon_id1" field's value of the BattleOpponentParty entity.
// If the BattleOpponentParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleOpponentPartyMutation) OldOpponentPokemonId1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentPokemonId1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentPokemonId1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentPokemonId1: %w", err)
	}
	return oldValue.OpponentPokemonId1, nil
}

// AddOpponentPokemonId1 adds i to the "opponent_pokemon_id1" field.
func (m *BattleOpponentPartyMutation) AddOpponentPokemonId1(i int) {
	if m.addopponent_pokemon_id1 != nil {
		*m.addopponent_pokemon_id1 += i
	} else {
		m.addopponent_pokemon_id1 = &i
	}
}

// AddedOpponentPokemonId1 returns the value that was added to the "opponent_pokemon_id1" field in this mutation.
func (m *BattleOpponentPartyMutation) AddedOpponentPokemonId1() (r int, exists bool) {
	v := m.addopponent_pokemon_id1
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentPokemonId1 resets all changes to the "opponent_pokemon_id1" field.
func (m *BattleOpponentPartyMutation) ResetOpponentPokemonId1() {
	m.opponent_pokemon_id1 = nil
	m.addopponent_pokemon_id1 = nil
}

// SetOpponentPokemonId2 sets the "opponent_pokemon_id2" field.
func (m *BattleOpponentPartyMutation) SetOpponentPokemonId2(i int) {
	m.opponent_pokemon_id2 = &i
	m.addopponent_pokemon_id2 = nil
}

// OpponentPokemonId2 returns the value of the "opponent_pokemon_id2" field in the mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId2() (r int, exists bool) {
	v := m.opponent_pokemon_id2
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentPokemonId2 returns the old "opponent_pokemon_id2" field's value of the BattleOpponentParty entity.
// If the BattleOpponentParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleOpponentPartyMutation) OldOpponentPokemonId2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentPokemonId2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentPokemonId2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentPokemonId2: %w", err)
	}
	return oldValue.OpponentPokemonId2, nil
}

// AddOpponentPokemonId2 adds i to the "opponent_pokemon_id2" field.
func (m *BattleOpponentPartyMutation) AddOpponentPokemonId2(i int) {
	if m.addopponent_pokemon_id2 != nil {
		*m.addopponent_pokemon_id2 += i
	} else {
		m.addopponent_pokemon_id2 = &i
	}
}

// AddedOpponentPokemonId2 returns the value that was added to the "opponent_pokemon_id2" field in this mutation.
func (m *BattleOpponentPartyMutation) AddedOpponentPokemonId2() (r int, exists bool) {
	v := m.addopponent_pokemon_id2
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentPokemonId2 resets all changes to the "opponent_pokemon_id2" field.
func (m *BattleOpponentPartyMutation) ResetOpponentPokemonId2() {
	m.opponent_pokemon_id2 = nil
	m.addopponent_pokemon_id2 = nil
}

// SetOpponentPokemonId3 sets the "opponent_pokemon_id3" field.
func (m *BattleOpponentPartyMutation) SetOpponentPokemonId3(i int) {
	m.opponent_pokemon_id3 = &i
	m.addopponent_pokemon_id3 = nil
}

// OpponentPokemonId3 returns the value of the "opponent_pokemon_id3" field in the mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId3() (r int, exists bool) {
	v := m.opponent_pokemon_id3
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentPokemonId3 returns the old "opponent_pokemon_id3" field's value of the BattleOpponentParty entity.
// If the BattleOpponentParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleOpponentPartyMutation) OldOpponentPokemonId3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentPokemonId3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentPokemonId3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentPokemonId3: %w", err)
	}
	return oldValue.OpponentPokemonId3, nil
}

// AddOpponentPokemonId3 adds i to the "opponent_pokemon_id3" field.
func (m *BattleOpponentPartyMutation) AddOpponentPokemonId3(i int) {
	if m.addopponent_pokemon_id3 != nil {
		*m.addopponent_pokemon_id3 += i
	} else {
		m.addopponent_pokemon_id3 = &i
	}
}

// AddedOpponentPokemonId3 returns the value that was added to the "opponent_pokemon_id3" field in this mutation.
func (m *BattleOpponentPartyMutation) AddedOpponentPokemonId3() (r int, exists bool) {
	v := m.addopponent_pokemon_id3
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentPokemonId3 resets all changes to the "opponent_pokemon_id3" field.
func (m *BattleOpponentPartyMutation) ResetOpponentPokemonId3() {
	m.opponent_pokemon_id3 = nil
	m.addopponent_pokemon_id3 = nil
}

// SetOpponentPokemonId4 sets the "opponent_pokemon_id4" field.
func (m *BattleOpponentPartyMutation) SetOpponentPokemonId4(i int) {
	m.opponent_pokemon_id4 = &i
	m.addopponent_pokemon_id4 = nil
}

// OpponentPokemonId4 returns the value of the "opponent_pokemon_id4" field in the mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId4() (r int, exists bool) {
	v := m.opponent_pokemon_id4
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentPokemonId4 returns the old "opponent_pokemon_id4" field's value of the BattleOpponentParty entity.
// If the BattleOpponentParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleOpponentPartyMutation) OldOpponentPokemonId4(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentPokemonId4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentPokemonId4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentPokemonId4: %w", err)
	}
	return oldValue.OpponentPokemonId4, nil
}

// AddOpponentPokemonId4 adds i to the "opponent_pokemon_id4" field.
func (m *BattleOpponentPartyMutation) AddOpponentPokemonId4(i int) {
	if m.addopponent_pokemon_id4 != nil {
		*m.addopponent_pokemon_id4 += i
	} else {
		m.addopponent_pokemon_id4 = &i
	}
}

// AddedOpponentPokemonId4 returns the value that was added to the "opponent_pokemon_id4" field in this mutation.
func (m *BattleOpponentPartyMutation) AddedOpponentPokemonId4() (r int, exists bool) {
	v := m.addopponent_pokemon_id4
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpponentPokemonId4 clears the value of the "opponent_pokemon_id4" field.
func (m *BattleOpponentPartyMutation) ClearOpponentPokemonId4() {
	m.opponent_pokemon_id4 = nil
	m.addopponent_pokemon_id4 = nil
	m.clearedFields[battleopponentparty.FieldOpponentPokemonId4] = struct{}{}
}

// OpponentPokemonId4Cleared returns if the "opponent_pokemon_id4" field was cleared in this mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId4Cleared() bool {
	_, ok := m.clearedFields[battleopponentparty.FieldOpponentPokemonId4]
	return ok
}

// ResetOpponentPokemonId4 resets all changes to the "opponent_pokemon_id4" field.
func (m *BattleOpponentPartyMutation) ResetOpponentPokemonId4() {
	m.opponent_pokemon_id4 = nil
	m.addopponent_pokemon_id4 = nil
	delete(m.clearedFields, battleopponentparty.FieldOpponentPokemonId4)
}

// SetOpponentPokemonId5 sets the "opponent_pokemon_id5" field.
func (m *BattleOpponentPartyMutation) SetOpponentPokemonId5(i int) {
	m.opponent_pokemon_id5 = &i
	m.addopponent_pokemon_id5 = nil
}

// OpponentPokemonId5 returns the value of the "opponent_pokemon_id5" field in the mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId5() (r int, exists bool) {
	v := m.opponent_pokemon_id5
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentPokemonId5 returns the old "opponent_pokemon_id5" field's value of the BattleOpponentParty entity.
// If the BattleOpponentParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleOpponentPartyMutation) OldOpponentPokemonId5(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentPokemonId5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentPokemonId5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentPokemonId5: %w", err)
	}
	return oldValue.OpponentPokemonId5, nil
}

// AddOpponentPokemonId5 adds i to the "opponent_pokemon_id5" field.
func (m *BattleOpponentPartyMutation) AddOpponentPokemonId5(i int) {
	if m.addopponent_pokemon_id5 != nil {
		*m.addopponent_pokemon_id5 += i
	} else {
		m.addopponent_pokemon_id5 = &i
	}
}

// AddedOpponentPokemonId5 returns the value that was added to the "opponent_pokemon_id5" field in this mutation.
func (m *BattleOpponentPartyMutation) AddedOpponentPokemonId5() (r int, exists bool) {
	v := m.addopponent_pokemon_id5
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpponentPokemonId5 clears the value of the "opponent_pokemon_id5" field.
func (m *BattleOpponentPartyMutation) ClearOpponentPokemonId5() {
	m.opponent_pokemon_id5 = nil
	m.addopponent_pokemon_id5 = nil
	m.clearedFields[battleopponentparty.FieldOpponentPokemonId5] = struct{}{}
}

// OpponentPokemonId5Cleared returns if the "opponent_pokemon_id5" field was cleared in this mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId5Cleared() bool {
	_, ok := m.clearedFields[battleopponentparty.FieldOpponentPokemonId5]
	return ok
}

// ResetOpponentPokemonId5 resets all changes to the "opponent_pokemon_id5" field.
func (m *BattleOpponentPartyMutation) ResetOpponentPokemonId5() {
	m.opponent_pokemon_id5 = nil
	m.addopponent_pokemon_id5 = nil
	delete(m.clearedFields, battleopponentparty.FieldOpponentPokemonId5)
}

// SetOpponentPokemonId6 sets the "opponent_pokemon_id6" field.
func (m *BattleOpponentPartyMutation) SetOpponentPokemonId6(i int) {
	m.opponent_pokemon_id6 = &i
	m.addopponent_pokemon_id6 = nil
}

// OpponentPokemonId6 returns the value of the "opponent_pokemon_id6" field in the mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId6() (r int, exists bool) {
	v := m.opponent_pokemon_id6
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentPokemonId6 returns the old "opponent_pokemon_id6" field's value of the BattleOpponentParty entity.
// If the BattleOpponentParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleOpponentPartyMutation) OldOpponentPokemonId6(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentPokemonId6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentPokemonId6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentPokemonId6: %w", err)
	}
	return oldValue.OpponentPokemonId6, nil
}

// AddOpponentPokemonId6 adds i to the "opponent_pokemon_id6" field.
func (m *BattleOpponentPartyMutation) AddOpponentPokemonId6(i int) {
	if m.addopponent_pokemon_id6 != nil {
		*m.addopponent_pokemon_id6 += i
	} else {
		m.addopponent_pokemon_id6 = &i
	}
}

// AddedOpponentPokemonId6 returns the value that was added to the "opponent_pokemon_id6" field in this mutation.
func (m *BattleOpponentPartyMutation) AddedOpponentPokemonId6() (r int, exists bool) {
	v := m.addopponent_pokemon_id6
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpponentPokemonId6 clears the value of the "opponent_pokemon_id6" field.
func (m *BattleOpponentPartyMutation) ClearOpponentPokemonId6() {
	m.opponent_pokemon_id6 = nil
	m.addopponent_pokemon_id6 = nil
	m.clearedFields[battleopponentparty.FieldOpponentPokemonId6] = struct{}{}
}

// OpponentPokemonId6Cleared returns if the "opponent_pokemon_id6" field was cleared in this mutation.
func (m *BattleOpponentPartyMutation) OpponentPokemonId6Cleared() bool {
	_, ok := m.clearedFields[battleopponentparty.FieldOpponentPokemonId6]
	return ok
}

// ResetOpponentPokemonId6 resets all changes to the "opponent_pokemon_id6" field.
func (m *BattleOpponentPartyMutation) ResetOpponentPokemonId6() {
	m.opponent_pokemon_id6 = nil
	m.addopponent_pokemon_id6 = nil
	delete(m.clearedFields, battleopponentparty.FieldOpponentPokemonId6)
}

// AddBattleContentIDs adds the "battle_content" edge to the BattleRecords entity by ids.
func (m *BattleOpponentPartyMutation) AddBattleContentIDs(ids ...int) {
	if m.battle_content == nil {
		m.battle_content = make(map[int]struct{})
	}
	for i := range ids {
		m.battle_content[ids[i]] = struct{}{}
	}
}

// ClearBattleContent clears the "battle_content" edge to the BattleRecords entity.
func (m *BattleOpponentPartyMutation) ClearBattleContent() {
	m.clearedbattle_content = true
}

// BattleContentCleared reports if the "battle_content" edge to the BattleRecords entity was cleared.
func (m *BattleOpponentPartyMutation) BattleContentCleared() bool {
	return m.clearedbattle_content
}

// RemoveBattleContentIDs removes the "battle_content" edge to the BattleRecords entity by IDs.
func (m *BattleOpponentPartyMutation) RemoveBattleContentIDs(ids ...int) {
	if m.removedbattle_content == nil {
		m.removedbattle_content = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.battle_content, ids[i])
		m.removedbattle_content[ids[i]] = struct{}{}
	}
}

// RemovedBattleContent returns the removed IDs of the "battle_content" edge to the BattleRecords entity.
func (m *BattleOpponentPartyMutation) RemovedBattleContentIDs() (ids []int) {
	for id := range m.removedbattle_content {
		ids = append(ids, id)
	}
	return
}

// BattleContentIDs returns the "battle_content" edge IDs in the mutation.
func (m *BattleOpponentPartyMutation) BattleContentIDs() (ids []int) {
	for id := range m.battle_content {
		ids = append(ids, id)
	}
	return
}

// ResetBattleContent resets all changes to the "battle_content" edge.
func (m *BattleOpponentPartyMutation) ResetBattleContent() {
	m.battle_content = nil
	m.clearedbattle_content = false
	m.removedbattle_content = nil
}

// Where appends a list predicates to the BattleOpponentPartyMutation builder.
func (m *BattleOpponentPartyMutation) Where(ps ...predicate.BattleOpponentParty) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BattleOpponentPartyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BattleOpponentParty).
func (m *BattleOpponentPartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BattleOpponentPartyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.opponent_pokemon_id1 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId1)
	}
	if m.opponent_pokemon_id2 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId2)
	}
	if m.opponent_pokemon_id3 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId3)
	}
	if m.opponent_pokemon_id4 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId4)
	}
	if m.opponent_pokemon_id5 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId5)
	}
	if m.opponent_pokemon_id6 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId6)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BattleOpponentPartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case battleopponentparty.FieldOpponentPokemonId1:
		return m.OpponentPokemonId1()
	case battleopponentparty.FieldOpponentPokemonId2:
		return m.OpponentPokemonId2()
	case battleopponentparty.FieldOpponentPokemonId3:
		return m.OpponentPokemonId3()
	case battleopponentparty.FieldOpponentPokemonId4:
		return m.OpponentPokemonId4()
	case battleopponentparty.FieldOpponentPokemonId5:
		return m.OpponentPokemonId5()
	case battleopponentparty.FieldOpponentPokemonId6:
		return m.OpponentPokemonId6()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BattleOpponentPartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case battleopponentparty.FieldOpponentPokemonId1:
		return m.OldOpponentPokemonId1(ctx)
	case battleopponentparty.FieldOpponentPokemonId2:
		return m.OldOpponentPokemonId2(ctx)
	case battleopponentparty.FieldOpponentPokemonId3:
		return m.OldOpponentPokemonId3(ctx)
	case battleopponentparty.FieldOpponentPokemonId4:
		return m.OldOpponentPokemonId4(ctx)
	case battleopponentparty.FieldOpponentPokemonId5:
		return m.OldOpponentPokemonId5(ctx)
	case battleopponentparty.FieldOpponentPokemonId6:
		return m.OldOpponentPokemonId6(ctx)
	}
	return nil, fmt.Errorf("unknown BattleOpponentParty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleOpponentPartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case battleopponentparty.FieldOpponentPokemonId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentPokemonId1(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentPokemonId2(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentPokemonId3(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId4:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentPokemonId4(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId5:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentPokemonId5(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId6:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentPokemonId6(v)
		return nil
	}
	return fmt.Errorf("unknown BattleOpponentParty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BattleOpponentPartyMutation) AddedFields() []string {
	var fields []string
	if m.addopponent_pokemon_id1 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId1)
	}
	if m.addopponent_pokemon_id2 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId2)
	}
	if m.addopponent_pokemon_id3 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId3)
	}
	if m.addopponent_pokemon_id4 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId4)
	}
	if m.addopponent_pokemon_id5 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId5)
	}
	if m.addopponent_pokemon_id6 != nil {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId6)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BattleOpponentPartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case battleopponentparty.FieldOpponentPokemonId1:
		return m.AddedOpponentPokemonId1()
	case battleopponentparty.FieldOpponentPokemonId2:
		return m.AddedOpponentPokemonId2()
	case battleopponentparty.FieldOpponentPokemonId3:
		return m.AddedOpponentPokemonId3()
	case battleopponentparty.FieldOpponentPokemonId4:
		return m.AddedOpponentPokemonId4()
	case battleopponentparty.FieldOpponentPokemonId5:
		return m.AddedOpponentPokemonId5()
	case battleopponentparty.FieldOpponentPokemonId6:
		return m.AddedOpponentPokemonId6()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleOpponentPartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case battleopponentparty.FieldOpponentPokemonId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentPokemonId1(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentPokemonId2(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentPokemonId3(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId4:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentPokemonId4(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId5:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentPokemonId5(v)
		return nil
	case battleopponentparty.FieldOpponentPokemonId6:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentPokemonId6(v)
		return nil
	}
	return fmt.Errorf("unknown BattleOpponentParty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BattleOpponentPartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(battleopponentparty.FieldOpponentPokemonId4) {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId4)
	}
	if m.FieldCleared(battleopponentparty.FieldOpponentPokemonId5) {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId5)
	}
	if m.FieldCleared(battleopponentparty.FieldOpponentPokemonId6) {
		fields = append(fields, battleopponentparty.FieldOpponentPokemonId6)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BattleOpponentPartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BattleOpponentPartyMutation) ClearField(name string) error {
	switch name {
	case battleopponentparty.FieldOpponentPokemonId4:
		m.ClearOpponentPokemonId4()
		return nil
	case battleopponentparty.FieldOpponentPokemonId5:
		m.ClearOpponentPokemonId5()
		return nil
	case battleopponentparty.FieldOpponentPokemonId6:
		m.ClearOpponentPokemonId6()
		return nil
	}
	return fmt.Errorf("unknown BattleOpponentParty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BattleOpponentPartyMutation) ResetField(name string) error {
	switch name {
	case battleopponentparty.FieldOpponentPokemonId1:
		m.ResetOpponentPokemonId1()
		return nil
	case battleopponentparty.FieldOpponentPokemonId2:
		m.ResetOpponentPokemonId2()
		return nil
	case battleopponentparty.FieldOpponentPokemonId3:
		m.ResetOpponentPokemonId3()
		return nil
	case battleopponentparty.FieldOpponentPokemonId4:
		m.ResetOpponentPokemonId4()
		return nil
	case battleopponentparty.FieldOpponentPokemonId5:
		m.ResetOpponentPokemonId5()
		return nil
	case battleopponentparty.FieldOpponentPokemonId6:
		m.ResetOpponentPokemonId6()
		return nil
	}
	return fmt.Errorf("unknown BattleOpponentParty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BattleOpponentPartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.battle_content != nil {
		edges = append(edges, battleopponentparty.EdgeBattleContent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BattleOpponentPartyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case battleopponentparty.EdgeBattleContent:
		ids := make([]ent.Value, 0, len(m.battle_content))
		for id := range m.battle_content {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BattleOpponentPartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbattle_content != nil {
		edges = append(edges, battleopponentparty.EdgeBattleContent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BattleOpponentPartyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case battleopponentparty.EdgeBattleContent:
		ids := make([]ent.Value, 0, len(m.removedbattle_content))
		for id := range m.removedbattle_content {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BattleOpponentPartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbattle_content {
		edges = append(edges, battleopponentparty.EdgeBattleContent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BattleOpponentPartyMutation) EdgeCleared(name string) bool {
	switch name {
	case battleopponentparty.EdgeBattleContent:
		return m.clearedbattle_content
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BattleOpponentPartyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BattleOpponentParty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BattleOpponentPartyMutation) ResetEdge(name string) error {
	switch name {
	case battleopponentparty.EdgeBattleContent:
		m.ResetBattleContent()
		return nil
	}
	return fmt.Errorf("unknown BattleOpponentParty edge %s", name)
}

// BattleRecordsMutation represents an operation that mutates the BattleRecords nodes in the graph.
type BattleRecordsMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	battle_format                    *property.BattleFormats
	self_election_pokemon_id1        *int
	addself_election_pokemon_id1     *int
	self_election_pokemon_id2        *int
	addself_election_pokemon_id2     *int
	self_election_pokemon_id3        *int
	addself_election_pokemon_id3     *int
	self_election_pokemon_id4        *int
	addself_election_pokemon_id4     *int
	opponent_election_pokemon_id1    *int
	addopponent_election_pokemon_id1 *int
	opponent_election_pokemon_id2    *int
	addopponent_election_pokemon_id2 *int
	opponent_election_pokemon_id3    *int
	addopponent_election_pokemon_id3 *int
	opponent_election_pokemon_id4    *int
	addopponent_election_pokemon_id4 *int
	clearedFields                    map[string]struct{}
	use_party                        *int
	cleareduse_party                 bool
	opponent_party                   *int
	clearedopponent_party            bool
	done                             bool
	oldValue                         func(context.Context) (*BattleRecords, error)
	predicates                       []predicate.BattleRecords
}

var _ ent.Mutation = (*BattleRecordsMutation)(nil)

// battlerecordsOption allows management of the mutation configuration using functional options.
type battlerecordsOption func(*BattleRecordsMutation)

// newBattleRecordsMutation creates new mutation for the BattleRecords entity.
func newBattleRecordsMutation(c config, op Op, opts ...battlerecordsOption) *BattleRecordsMutation {
	m := &BattleRecordsMutation{
		config:        c,
		op:            op,
		typ:           TypeBattleRecords,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBattleRecordsID sets the ID field of the mutation.
func withBattleRecordsID(id int) battlerecordsOption {
	return func(m *BattleRecordsMutation) {
		var (
			err   error
			once  sync.Once
			value *BattleRecords
		)
		m.oldValue = func(ctx context.Context) (*BattleRecords, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BattleRecords.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBattleRecords sets the old BattleRecords of the mutation.
func withBattleRecords(node *BattleRecords) battlerecordsOption {
	return func(m *BattleRecordsMutation) {
		m.oldValue = func(context.Context) (*BattleRecords, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BattleRecordsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BattleRecordsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BattleRecordsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPartyID sets the "party_id" field.
func (m *BattleRecordsMutation) SetPartyID(i int) {
	m.use_party = &i
}

// PartyID returns the value of the "party_id" field in the mutation.
func (m *BattleRecordsMutation) PartyID() (r int, exists bool) {
	v := m.use_party
	if v == nil {
		return
	}
	return *v, true
}

// OldPartyID returns the old "party_id" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartyID: %w", err)
	}
	return oldValue.PartyID, nil
}

// ResetPartyID resets all changes to the "party_id" field.
func (m *BattleRecordsMutation) ResetPartyID() {
	m.use_party = nil
}

// SetBattleFormat sets the "battle_format" field.
func (m *BattleRecordsMutation) SetBattleFormat(pf property.BattleFormats) {
	m.battle_format = &pf
}

// BattleFormat returns the value of the "battle_format" field in the mutation.
func (m *BattleRecordsMutation) BattleFormat() (r property.BattleFormats, exists bool) {
	v := m.battle_format
	if v == nil {
		return
	}
	return *v, true
}

// OldBattleFormat returns the old "battle_format" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldBattleFormat(ctx context.Context) (v property.BattleFormats, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBattleFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBattleFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBattleFormat: %w", err)
	}
	return oldValue.BattleFormat, nil
}

// ResetBattleFormat resets all changes to the "battle_format" field.
func (m *BattleRecordsMutation) ResetBattleFormat() {
	m.battle_format = nil
}

// SetBattleOpponentPartyID sets the "battle_opponent_party_id" field.
func (m *BattleRecordsMutation) SetBattleOpponentPartyID(i int) {
	m.opponent_party = &i
}

// BattleOpponentPartyID returns the value of the "battle_opponent_party_id" field in the mutation.
func (m *BattleRecordsMutation) BattleOpponentPartyID() (r int, exists bool) {
	v := m.opponent_party
	if v == nil {
		return
	}
	return *v, true
}

// OldBattleOpponentPartyID returns the old "battle_opponent_party_id" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldBattleOpponentPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBattleOpponentPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBattleOpponentPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBattleOpponentPartyID: %w", err)
	}
	return oldValue.BattleOpponentPartyID, nil
}

// ResetBattleOpponentPartyID resets all changes to the "battle_opponent_party_id" field.
func (m *BattleRecordsMutation) ResetBattleOpponentPartyID() {
	m.opponent_party = nil
}

// SetSelfElectionPokemonId1 sets the "self_election_pokemon_id1" field.
func (m *BattleRecordsMutation) SetSelfElectionPokemonId1(i int) {
	m.self_election_pokemon_id1 = &i
	m.addself_election_pokemon_id1 = nil
}

// SelfElectionPokemonId1 returns the value of the "self_election_pokemon_id1" field in the mutation.
func (m *BattleRecordsMutation) SelfElectionPokemonId1() (r int, exists bool) {
	v := m.self_election_pokemon_id1
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfElectionPokemonId1 returns the old "self_election_pokemon_id1" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldSelfElectionPokemonId1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelfElectionPokemonId1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelfElectionPokemonId1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfElectionPokemonId1: %w", err)
	}
	return oldValue.SelfElectionPokemonId1, nil
}

// AddSelfElectionPokemonId1 adds i to the "self_election_pokemon_id1" field.
func (m *BattleRecordsMutation) AddSelfElectionPokemonId1(i int) {
	if m.addself_election_pokemon_id1 != nil {
		*m.addself_election_pokemon_id1 += i
	} else {
		m.addself_election_pokemon_id1 = &i
	}
}

// AddedSelfElectionPokemonId1 returns the value that was added to the "self_election_pokemon_id1" field in this mutation.
func (m *BattleRecordsMutation) AddedSelfElectionPokemonId1() (r int, exists bool) {
	v := m.addself_election_pokemon_id1
	if v == nil {
		return
	}
	return *v, true
}

// ResetSelfElectionPokemonId1 resets all changes to the "self_election_pokemon_id1" field.
func (m *BattleRecordsMutation) ResetSelfElectionPokemonId1() {
	m.self_election_pokemon_id1 = nil
	m.addself_election_pokemon_id1 = nil
}

// SetSelfElectionPokemonId2 sets the "self_election_pokemon_id2" field.
func (m *BattleRecordsMutation) SetSelfElectionPokemonId2(i int) {
	m.self_election_pokemon_id2 = &i
	m.addself_election_pokemon_id2 = nil
}

// SelfElectionPokemonId2 returns the value of the "self_election_pokemon_id2" field in the mutation.
func (m *BattleRecordsMutation) SelfElectionPokemonId2() (r int, exists bool) {
	v := m.self_election_pokemon_id2
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfElectionPokemonId2 returns the old "self_election_pokemon_id2" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldSelfElectionPokemonId2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelfElectionPokemonId2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelfElectionPokemonId2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfElectionPokemonId2: %w", err)
	}
	return oldValue.SelfElectionPokemonId2, nil
}

// AddSelfElectionPokemonId2 adds i to the "self_election_pokemon_id2" field.
func (m *BattleRecordsMutation) AddSelfElectionPokemonId2(i int) {
	if m.addself_election_pokemon_id2 != nil {
		*m.addself_election_pokemon_id2 += i
	} else {
		m.addself_election_pokemon_id2 = &i
	}
}

// AddedSelfElectionPokemonId2 returns the value that was added to the "self_election_pokemon_id2" field in this mutation.
func (m *BattleRecordsMutation) AddedSelfElectionPokemonId2() (r int, exists bool) {
	v := m.addself_election_pokemon_id2
	if v == nil {
		return
	}
	return *v, true
}

// ResetSelfElectionPokemonId2 resets all changes to the "self_election_pokemon_id2" field.
func (m *BattleRecordsMutation) ResetSelfElectionPokemonId2() {
	m.self_election_pokemon_id2 = nil
	m.addself_election_pokemon_id2 = nil
}

// SetSelfElectionPokemonId3 sets the "self_election_pokemon_id3" field.
func (m *BattleRecordsMutation) SetSelfElectionPokemonId3(i int) {
	m.self_election_pokemon_id3 = &i
	m.addself_election_pokemon_id3 = nil
}

// SelfElectionPokemonId3 returns the value of the "self_election_pokemon_id3" field in the mutation.
func (m *BattleRecordsMutation) SelfElectionPokemonId3() (r int, exists bool) {
	v := m.self_election_pokemon_id3
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfElectionPokemonId3 returns the old "self_election_pokemon_id3" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldSelfElectionPokemonId3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelfElectionPokemonId3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelfElectionPokemonId3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfElectionPokemonId3: %w", err)
	}
	return oldValue.SelfElectionPokemonId3, nil
}

// AddSelfElectionPokemonId3 adds i to the "self_election_pokemon_id3" field.
func (m *BattleRecordsMutation) AddSelfElectionPokemonId3(i int) {
	if m.addself_election_pokemon_id3 != nil {
		*m.addself_election_pokemon_id3 += i
	} else {
		m.addself_election_pokemon_id3 = &i
	}
}

// AddedSelfElectionPokemonId3 returns the value that was added to the "self_election_pokemon_id3" field in this mutation.
func (m *BattleRecordsMutation) AddedSelfElectionPokemonId3() (r int, exists bool) {
	v := m.addself_election_pokemon_id3
	if v == nil {
		return
	}
	return *v, true
}

// ResetSelfElectionPokemonId3 resets all changes to the "self_election_pokemon_id3" field.
func (m *BattleRecordsMutation) ResetSelfElectionPokemonId3() {
	m.self_election_pokemon_id3 = nil
	m.addself_election_pokemon_id3 = nil
}

// SetSelfElectionPokemonId4 sets the "self_election_pokemon_id4" field.
func (m *BattleRecordsMutation) SetSelfElectionPokemonId4(i int) {
	m.self_election_pokemon_id4 = &i
	m.addself_election_pokemon_id4 = nil
}

// SelfElectionPokemonId4 returns the value of the "self_election_pokemon_id4" field in the mutation.
func (m *BattleRecordsMutation) SelfElectionPokemonId4() (r int, exists bool) {
	v := m.self_election_pokemon_id4
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfElectionPokemonId4 returns the old "self_election_pokemon_id4" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldSelfElectionPokemonId4(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelfElectionPokemonId4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelfElectionPokemonId4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfElectionPokemonId4: %w", err)
	}
	return oldValue.SelfElectionPokemonId4, nil
}

// AddSelfElectionPokemonId4 adds i to the "self_election_pokemon_id4" field.
func (m *BattleRecordsMutation) AddSelfElectionPokemonId4(i int) {
	if m.addself_election_pokemon_id4 != nil {
		*m.addself_election_pokemon_id4 += i
	} else {
		m.addself_election_pokemon_id4 = &i
	}
}

// AddedSelfElectionPokemonId4 returns the value that was added to the "self_election_pokemon_id4" field in this mutation.
func (m *BattleRecordsMutation) AddedSelfElectionPokemonId4() (r int, exists bool) {
	v := m.addself_election_pokemon_id4
	if v == nil {
		return
	}
	return *v, true
}

// ClearSelfElectionPokemonId4 clears the value of the "self_election_pokemon_id4" field.
func (m *BattleRecordsMutation) ClearSelfElectionPokemonId4() {
	m.self_election_pokemon_id4 = nil
	m.addself_election_pokemon_id4 = nil
	m.clearedFields[battlerecords.FieldSelfElectionPokemonId4] = struct{}{}
}

// SelfElectionPokemonId4Cleared returns if the "self_election_pokemon_id4" field was cleared in this mutation.
func (m *BattleRecordsMutation) SelfElectionPokemonId4Cleared() bool {
	_, ok := m.clearedFields[battlerecords.FieldSelfElectionPokemonId4]
	return ok
}

// ResetSelfElectionPokemonId4 resets all changes to the "self_election_pokemon_id4" field.
func (m *BattleRecordsMutation) ResetSelfElectionPokemonId4() {
	m.self_election_pokemon_id4 = nil
	m.addself_election_pokemon_id4 = nil
	delete(m.clearedFields, battlerecords.FieldSelfElectionPokemonId4)
}

// SetOpponentElectionPokemonId1 sets the "opponent_election_pokemon_id1" field.
func (m *BattleRecordsMutation) SetOpponentElectionPokemonId1(i int) {
	m.opponent_election_pokemon_id1 = &i
	m.addopponent_election_pokemon_id1 = nil
}

// OpponentElectionPokemonId1 returns the value of the "opponent_election_pokemon_id1" field in the mutation.
func (m *BattleRecordsMutation) OpponentElectionPokemonId1() (r int, exists bool) {
	v := m.opponent_election_pokemon_id1
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentElectionPokemonId1 returns the old "opponent_election_pokemon_id1" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldOpponentElectionPokemonId1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentElectionPokemonId1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentElectionPokemonId1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentElectionPokemonId1: %w", err)
	}
	return oldValue.OpponentElectionPokemonId1, nil
}

// AddOpponentElectionPokemonId1 adds i to the "opponent_election_pokemon_id1" field.
func (m *BattleRecordsMutation) AddOpponentElectionPokemonId1(i int) {
	if m.addopponent_election_pokemon_id1 != nil {
		*m.addopponent_election_pokemon_id1 += i
	} else {
		m.addopponent_election_pokemon_id1 = &i
	}
}

// AddedOpponentElectionPokemonId1 returns the value that was added to the "opponent_election_pokemon_id1" field in this mutation.
func (m *BattleRecordsMutation) AddedOpponentElectionPokemonId1() (r int, exists bool) {
	v := m.addopponent_election_pokemon_id1
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentElectionPokemonId1 resets all changes to the "opponent_election_pokemon_id1" field.
func (m *BattleRecordsMutation) ResetOpponentElectionPokemonId1() {
	m.opponent_election_pokemon_id1 = nil
	m.addopponent_election_pokemon_id1 = nil
}

// SetOpponentElectionPokemonId2 sets the "opponent_election_pokemon_id2" field.
func (m *BattleRecordsMutation) SetOpponentElectionPokemonId2(i int) {
	m.opponent_election_pokemon_id2 = &i
	m.addopponent_election_pokemon_id2 = nil
}

// OpponentElectionPokemonId2 returns the value of the "opponent_election_pokemon_id2" field in the mutation.
func (m *BattleRecordsMutation) OpponentElectionPokemonId2() (r int, exists bool) {
	v := m.opponent_election_pokemon_id2
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentElectionPokemonId2 returns the old "opponent_election_pokemon_id2" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldOpponentElectionPokemonId2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentElectionPokemonId2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentElectionPokemonId2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentElectionPokemonId2: %w", err)
	}
	return oldValue.OpponentElectionPokemonId2, nil
}

// AddOpponentElectionPokemonId2 adds i to the "opponent_election_pokemon_id2" field.
func (m *BattleRecordsMutation) AddOpponentElectionPokemonId2(i int) {
	if m.addopponent_election_pokemon_id2 != nil {
		*m.addopponent_election_pokemon_id2 += i
	} else {
		m.addopponent_election_pokemon_id2 = &i
	}
}

// AddedOpponentElectionPokemonId2 returns the value that was added to the "opponent_election_pokemon_id2" field in this mutation.
func (m *BattleRecordsMutation) AddedOpponentElectionPokemonId2() (r int, exists bool) {
	v := m.addopponent_election_pokemon_id2
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentElectionPokemonId2 resets all changes to the "opponent_election_pokemon_id2" field.
func (m *BattleRecordsMutation) ResetOpponentElectionPokemonId2() {
	m.opponent_election_pokemon_id2 = nil
	m.addopponent_election_pokemon_id2 = nil
}

// SetOpponentElectionPokemonId3 sets the "opponent_election_pokemon_id3" field.
func (m *BattleRecordsMutation) SetOpponentElectionPokemonId3(i int) {
	m.opponent_election_pokemon_id3 = &i
	m.addopponent_election_pokemon_id3 = nil
}

// OpponentElectionPokemonId3 returns the value of the "opponent_election_pokemon_id3" field in the mutation.
func (m *BattleRecordsMutation) OpponentElectionPokemonId3() (r int, exists bool) {
	v := m.opponent_election_pokemon_id3
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentElectionPokemonId3 returns the old "opponent_election_pokemon_id3" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldOpponentElectionPokemonId3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentElectionPokemonId3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentElectionPokemonId3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentElectionPokemonId3: %w", err)
	}
	return oldValue.OpponentElectionPokemonId3, nil
}

// AddOpponentElectionPokemonId3 adds i to the "opponent_election_pokemon_id3" field.
func (m *BattleRecordsMutation) AddOpponentElectionPokemonId3(i int) {
	if m.addopponent_election_pokemon_id3 != nil {
		*m.addopponent_election_pokemon_id3 += i
	} else {
		m.addopponent_election_pokemon_id3 = &i
	}
}

// AddedOpponentElectionPokemonId3 returns the value that was added to the "opponent_election_pokemon_id3" field in this mutation.
func (m *BattleRecordsMutation) AddedOpponentElectionPokemonId3() (r int, exists bool) {
	v := m.addopponent_election_pokemon_id3
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentElectionPokemonId3 resets all changes to the "opponent_election_pokemon_id3" field.
func (m *BattleRecordsMutation) ResetOpponentElectionPokemonId3() {
	m.opponent_election_pokemon_id3 = nil
	m.addopponent_election_pokemon_id3 = nil
}

// SetOpponentElectionPokemonId4 sets the "opponent_election_pokemon_id4" field.
func (m *BattleRecordsMutation) SetOpponentElectionPokemonId4(i int) {
	m.opponent_election_pokemon_id4 = &i
	m.addopponent_election_pokemon_id4 = nil
}

// OpponentElectionPokemonId4 returns the value of the "opponent_election_pokemon_id4" field in the mutation.
func (m *BattleRecordsMutation) OpponentElectionPokemonId4() (r int, exists bool) {
	v := m.opponent_election_pokemon_id4
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentElectionPokemonId4 returns the old "opponent_election_pokemon_id4" field's value of the BattleRecords entity.
// If the BattleRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRecordsMutation) OldOpponentElectionPokemonId4(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpponentElectionPokemonId4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpponentElectionPokemonId4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentElectionPokemonId4: %w", err)
	}
	return oldValue.OpponentElectionPokemonId4, nil
}

// AddOpponentElectionPokemonId4 adds i to the "opponent_election_pokemon_id4" field.
func (m *BattleRecordsMutation) AddOpponentElectionPokemonId4(i int) {
	if m.addopponent_election_pokemon_id4 != nil {
		*m.addopponent_election_pokemon_id4 += i
	} else {
		m.addopponent_election_pokemon_id4 = &i
	}
}

// AddedOpponentElectionPokemonId4 returns the value that was added to the "opponent_election_pokemon_id4" field in this mutation.
func (m *BattleRecordsMutation) AddedOpponentElectionPokemonId4() (r int, exists bool) {
	v := m.addopponent_election_pokemon_id4
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentElectionPokemonId4 resets all changes to the "opponent_election_pokemon_id4" field.
func (m *BattleRecordsMutation) ResetOpponentElectionPokemonId4() {
	m.opponent_election_pokemon_id4 = nil
	m.addopponent_election_pokemon_id4 = nil
}

// SetUsePartyID sets the "use_party" edge to the Party entity by id.
func (m *BattleRecordsMutation) SetUsePartyID(id int) {
	m.use_party = &id
}

// ClearUseParty clears the "use_party" edge to the Party entity.
func (m *BattleRecordsMutation) ClearUseParty() {
	m.cleareduse_party = true
}

// UsePartyCleared reports if the "use_party" edge to the Party entity was cleared.
func (m *BattleRecordsMutation) UsePartyCleared() bool {
	return m.cleareduse_party
}

// UsePartyID returns the "use_party" edge ID in the mutation.
func (m *BattleRecordsMutation) UsePartyID() (id int, exists bool) {
	if m.use_party != nil {
		return *m.use_party, true
	}
	return
}

// UsePartyIDs returns the "use_party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsePartyID instead. It exists only for internal usage by the builders.
func (m *BattleRecordsMutation) UsePartyIDs() (ids []int) {
	if id := m.use_party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseParty resets all changes to the "use_party" edge.
func (m *BattleRecordsMutation) ResetUseParty() {
	m.use_party = nil
	m.cleareduse_party = false
}

// SetOpponentPartyID sets the "opponent_party" edge to the BattleOpponentParty entity by id.
func (m *BattleRecordsMutation) SetOpponentPartyID(id int) {
	m.opponent_party = &id
}

// ClearOpponentParty clears the "opponent_party" edge to the BattleOpponentParty entity.
func (m *BattleRecordsMutation) ClearOpponentParty() {
	m.clearedopponent_party = true
}

// OpponentPartyCleared reports if the "opponent_party" edge to the BattleOpponentParty entity was cleared.
func (m *BattleRecordsMutation) OpponentPartyCleared() bool {
	return m.clearedopponent_party
}

// OpponentPartyID returns the "opponent_party" edge ID in the mutation.
func (m *BattleRecordsMutation) OpponentPartyID() (id int, exists bool) {
	if m.opponent_party != nil {
		return *m.opponent_party, true
	}
	return
}

// OpponentPartyIDs returns the "opponent_party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OpponentPartyID instead. It exists only for internal usage by the builders.
func (m *BattleRecordsMutation) OpponentPartyIDs() (ids []int) {
	if id := m.opponent_party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOpponentParty resets all changes to the "opponent_party" edge.
func (m *BattleRecordsMutation) ResetOpponentParty() {
	m.opponent_party = nil
	m.clearedopponent_party = false
}

// Where appends a list predicates to the BattleRecordsMutation builder.
func (m *BattleRecordsMutation) Where(ps ...predicate.BattleRecords) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BattleRecordsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BattleRecords).
func (m *BattleRecordsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BattleRecordsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.use_party != nil {
		fields = append(fields, battlerecords.FieldPartyID)
	}
	if m.battle_format != nil {
		fields = append(fields, battlerecords.FieldBattleFormat)
	}
	if m.opponent_party != nil {
		fields = append(fields, battlerecords.FieldBattleOpponentPartyID)
	}
	if m.self_election_pokemon_id1 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId1)
	}
	if m.self_election_pokemon_id2 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId2)
	}
	if m.self_election_pokemon_id3 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId3)
	}
	if m.self_election_pokemon_id4 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId4)
	}
	if m.opponent_election_pokemon_id1 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId1)
	}
	if m.opponent_election_pokemon_id2 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId2)
	}
	if m.opponent_election_pokemon_id3 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId3)
	}
	if m.opponent_election_pokemon_id4 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId4)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BattleRecordsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case battlerecords.FieldPartyID:
		return m.PartyID()
	case battlerecords.FieldBattleFormat:
		return m.BattleFormat()
	case battlerecords.FieldBattleOpponentPartyID:
		return m.BattleOpponentPartyID()
	case battlerecords.FieldSelfElectionPokemonId1:
		return m.SelfElectionPokemonId1()
	case battlerecords.FieldSelfElectionPokemonId2:
		return m.SelfElectionPokemonId2()
	case battlerecords.FieldSelfElectionPokemonId3:
		return m.SelfElectionPokemonId3()
	case battlerecords.FieldSelfElectionPokemonId4:
		return m.SelfElectionPokemonId4()
	case battlerecords.FieldOpponentElectionPokemonId1:
		return m.OpponentElectionPokemonId1()
	case battlerecords.FieldOpponentElectionPokemonId2:
		return m.OpponentElectionPokemonId2()
	case battlerecords.FieldOpponentElectionPokemonId3:
		return m.OpponentElectionPokemonId3()
	case battlerecords.FieldOpponentElectionPokemonId4:
		return m.OpponentElectionPokemonId4()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BattleRecordsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case battlerecords.FieldPartyID:
		return m.OldPartyID(ctx)
	case battlerecords.FieldBattleFormat:
		return m.OldBattleFormat(ctx)
	case battlerecords.FieldBattleOpponentPartyID:
		return m.OldBattleOpponentPartyID(ctx)
	case battlerecords.FieldSelfElectionPokemonId1:
		return m.OldSelfElectionPokemonId1(ctx)
	case battlerecords.FieldSelfElectionPokemonId2:
		return m.OldSelfElectionPokemonId2(ctx)
	case battlerecords.FieldSelfElectionPokemonId3:
		return m.OldSelfElectionPokemonId3(ctx)
	case battlerecords.FieldSelfElectionPokemonId4:
		return m.OldSelfElectionPokemonId4(ctx)
	case battlerecords.FieldOpponentElectionPokemonId1:
		return m.OldOpponentElectionPokemonId1(ctx)
	case battlerecords.FieldOpponentElectionPokemonId2:
		return m.OldOpponentElectionPokemonId2(ctx)
	case battlerecords.FieldOpponentElectionPokemonId3:
		return m.OldOpponentElectionPokemonId3(ctx)
	case battlerecords.FieldOpponentElectionPokemonId4:
		return m.OldOpponentElectionPokemonId4(ctx)
	}
	return nil, fmt.Errorf("unknown BattleRecords field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleRecordsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case battlerecords.FieldPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartyID(v)
		return nil
	case battlerecords.FieldBattleFormat:
		v, ok := value.(property.BattleFormats)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBattleFormat(v)
		return nil
	case battlerecords.FieldBattleOpponentPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBattleOpponentPartyID(v)
		return nil
	case battlerecords.FieldSelfElectionPokemonId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfElectionPokemonId1(v)
		return nil
	case battlerecords.FieldSelfElectionPokemonId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfElectionPokemonId2(v)
		return nil
	case battlerecords.FieldSelfElectionPokemonId3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfElectionPokemonId3(v)
		return nil
	case battlerecords.FieldSelfElectionPokemonId4:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfElectionPokemonId4(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentElectionPokemonId1(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentElectionPokemonId2(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentElectionPokemonId3(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId4:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentElectionPokemonId4(v)
		return nil
	}
	return fmt.Errorf("unknown BattleRecords field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BattleRecordsMutation) AddedFields() []string {
	var fields []string
	if m.addself_election_pokemon_id1 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId1)
	}
	if m.addself_election_pokemon_id2 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId2)
	}
	if m.addself_election_pokemon_id3 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId3)
	}
	if m.addself_election_pokemon_id4 != nil {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId4)
	}
	if m.addopponent_election_pokemon_id1 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId1)
	}
	if m.addopponent_election_pokemon_id2 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId2)
	}
	if m.addopponent_election_pokemon_id3 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId3)
	}
	if m.addopponent_election_pokemon_id4 != nil {
		fields = append(fields, battlerecords.FieldOpponentElectionPokemonId4)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BattleRecordsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case battlerecords.FieldSelfElectionPokemonId1:
		return m.AddedSelfElectionPokemonId1()
	case battlerecords.FieldSelfElectionPokemonId2:
		return m.AddedSelfElectionPokemonId2()
	case battlerecords.FieldSelfElectionPokemonId3:
		return m.AddedSelfElectionPokemonId3()
	case battlerecords.FieldSelfElectionPokemonId4:
		return m.AddedSelfElectionPokemonId4()
	case battlerecords.FieldOpponentElectionPokemonId1:
		return m.AddedOpponentElectionPokemonId1()
	case battlerecords.FieldOpponentElectionPokemonId2:
		return m.AddedOpponentElectionPokemonId2()
	case battlerecords.FieldOpponentElectionPokemonId3:
		return m.AddedOpponentElectionPokemonId3()
	case battlerecords.FieldOpponentElectionPokemonId4:
		return m.AddedOpponentElectionPokemonId4()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleRecordsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case battlerecords.FieldSelfElectionPokemonId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelfElectionPokemonId1(v)
		return nil
	case battlerecords.FieldSelfElectionPokemonId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelfElectionPokemonId2(v)
		return nil
	case battlerecords.FieldSelfElectionPokemonId3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelfElectionPokemonId3(v)
		return nil
	case battlerecords.FieldSelfElectionPokemonId4:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelfElectionPokemonId4(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentElectionPokemonId1(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentElectionPokemonId2(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentElectionPokemonId3(v)
		return nil
	case battlerecords.FieldOpponentElectionPokemonId4:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentElectionPokemonId4(v)
		return nil
	}
	return fmt.Errorf("unknown BattleRecords numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BattleRecordsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(battlerecords.FieldSelfElectionPokemonId4) {
		fields = append(fields, battlerecords.FieldSelfElectionPokemonId4)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BattleRecordsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BattleRecordsMutation) ClearField(name string) error {
	switch name {
	case battlerecords.FieldSelfElectionPokemonId4:
		m.ClearSelfElectionPokemonId4()
		return nil
	}
	return fmt.Errorf("unknown BattleRecords nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BattleRecordsMutation) ResetField(name string) error {
	switch name {
	case battlerecords.FieldPartyID:
		m.ResetPartyID()
		return nil
	case battlerecords.FieldBattleFormat:
		m.ResetBattleFormat()
		return nil
	case battlerecords.FieldBattleOpponentPartyID:
		m.ResetBattleOpponentPartyID()
		return nil
	case battlerecords.FieldSelfElectionPokemonId1:
		m.ResetSelfElectionPokemonId1()
		return nil
	case battlerecords.FieldSelfElectionPokemonId2:
		m.ResetSelfElectionPokemonId2()
		return nil
	case battlerecords.FieldSelfElectionPokemonId3:
		m.ResetSelfElectionPokemonId3()
		return nil
	case battlerecords.FieldSelfElectionPokemonId4:
		m.ResetSelfElectionPokemonId4()
		return nil
	case battlerecords.FieldOpponentElectionPokemonId1:
		m.ResetOpponentElectionPokemonId1()
		return nil
	case battlerecords.FieldOpponentElectionPokemonId2:
		m.ResetOpponentElectionPokemonId2()
		return nil
	case battlerecords.FieldOpponentElectionPokemonId3:
		m.ResetOpponentElectionPokemonId3()
		return nil
	case battlerecords.FieldOpponentElectionPokemonId4:
		m.ResetOpponentElectionPokemonId4()
		return nil
	}
	return fmt.Errorf("unknown BattleRecords field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BattleRecordsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.use_party != nil {
		edges = append(edges, battlerecords.EdgeUseParty)
	}
	if m.opponent_party != nil {
		edges = append(edges, battlerecords.EdgeOpponentParty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BattleRecordsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case battlerecords.EdgeUseParty:
		if id := m.use_party; id != nil {
			return []ent.Value{*id}
		}
	case battlerecords.EdgeOpponentParty:
		if id := m.opponent_party; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BattleRecordsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BattleRecordsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BattleRecordsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduse_party {
		edges = append(edges, battlerecords.EdgeUseParty)
	}
	if m.clearedopponent_party {
		edges = append(edges, battlerecords.EdgeOpponentParty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BattleRecordsMutation) EdgeCleared(name string) bool {
	switch name {
	case battlerecords.EdgeUseParty:
		return m.cleareduse_party
	case battlerecords.EdgeOpponentParty:
		return m.clearedopponent_party
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BattleRecordsMutation) ClearEdge(name string) error {
	switch name {
	case battlerecords.EdgeUseParty:
		m.ClearUseParty()
		return nil
	case battlerecords.EdgeOpponentParty:
		m.ClearOpponentParty()
		return nil
	}
	return fmt.Errorf("unknown BattleRecords unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BattleRecordsMutation) ResetEdge(name string) error {
	switch name {
	case battlerecords.EdgeUseParty:
		m.ResetUseParty()
		return nil
	case battlerecords.EdgeOpponentParty:
		m.ResetOpponentParty()
		return nil
	}
	return fmt.Errorf("unknown BattleRecords edge %s", name)
}

// FormsMutation represents an operation that mutates the Forms nodes in the graph.
type FormsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	form_name           *string
	is_regional_variant *bool
	regionName          *string
	clearedFields       map[string]struct{}
	form_holder         map[int]struct{}
	removedform_holder  map[int]struct{}
	clearedform_holder  bool
	done                bool
	oldValue            func(context.Context) (*Forms, error)
	predicates          []predicate.Forms
}

var _ ent.Mutation = (*FormsMutation)(nil)

// formsOption allows management of the mutation configuration using functional options.
type formsOption func(*FormsMutation)

// newFormsMutation creates new mutation for the Forms entity.
func newFormsMutation(c config, op Op, opts ...formsOption) *FormsMutation {
	m := &FormsMutation{
		config:        c,
		op:            op,
		typ:           TypeForms,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFormsID sets the ID field of the mutation.
func withFormsID(id int) formsOption {
	return func(m *FormsMutation) {
		var (
			err   error
			once  sync.Once
			value *Forms
		)
		m.oldValue = func(ctx context.Context) (*Forms, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Forms.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withForms sets the old Forms of the mutation.
func withForms(node *Forms) formsOption {
	return func(m *FormsMutation) {
		m.oldValue = func(context.Context) (*Forms, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FormsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FormsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FormsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFormName sets the "form_name" field.
func (m *FormsMutation) SetFormName(s string) {
	m.form_name = &s
}

// FormName returns the value of the "form_name" field in the mutation.
func (m *FormsMutation) FormName() (r string, exists bool) {
	v := m.form_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFormName returns the old "form_name" field's value of the Forms entity.
// If the Forms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormsMutation) OldFormName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormName: %w", err)
	}
	return oldValue.FormName, nil
}

// ResetFormName resets all changes to the "form_name" field.
func (m *FormsMutation) ResetFormName() {
	m.form_name = nil
}

// SetIsRegionalVariant sets the "is_regional_variant" field.
func (m *FormsMutation) SetIsRegionalVariant(b bool) {
	m.is_regional_variant = &b
}

// IsRegionalVariant returns the value of the "is_regional_variant" field in the mutation.
func (m *FormsMutation) IsRegionalVariant() (r bool, exists bool) {
	v := m.is_regional_variant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRegionalVariant returns the old "is_regional_variant" field's value of the Forms entity.
// If the Forms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormsMutation) OldIsRegionalVariant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRegionalVariant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRegionalVariant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRegionalVariant: %w", err)
	}
	return oldValue.IsRegionalVariant, nil
}

// ResetIsRegionalVariant resets all changes to the "is_regional_variant" field.
func (m *FormsMutation) ResetIsRegionalVariant() {
	m.is_regional_variant = nil
}

// SetRegionName sets the "regionName" field.
func (m *FormsMutation) SetRegionName(s string) {
	m.regionName = &s
}

// RegionName returns the value of the "regionName" field in the mutation.
func (m *FormsMutation) RegionName() (r string, exists bool) {
	v := m.regionName
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionName returns the old "regionName" field's value of the Forms entity.
// If the Forms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormsMutation) OldRegionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionName: %w", err)
	}
	return oldValue.RegionName, nil
}

// ResetRegionName resets all changes to the "regionName" field.
func (m *FormsMutation) ResetRegionName() {
	m.regionName = nil
}

// AddFormHolderIDs adds the "form_holder" edge to the Pokemons entity by ids.
func (m *FormsMutation) AddFormHolderIDs(ids ...int) {
	if m.form_holder == nil {
		m.form_holder = make(map[int]struct{})
	}
	for i := range ids {
		m.form_holder[ids[i]] = struct{}{}
	}
}

// ClearFormHolder clears the "form_holder" edge to the Pokemons entity.
func (m *FormsMutation) ClearFormHolder() {
	m.clearedform_holder = true
}

// FormHolderCleared reports if the "form_holder" edge to the Pokemons entity was cleared.
func (m *FormsMutation) FormHolderCleared() bool {
	return m.clearedform_holder
}

// RemoveFormHolderIDs removes the "form_holder" edge to the Pokemons entity by IDs.
func (m *FormsMutation) RemoveFormHolderIDs(ids ...int) {
	if m.removedform_holder == nil {
		m.removedform_holder = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.form_holder, ids[i])
		m.removedform_holder[ids[i]] = struct{}{}
	}
}

// RemovedFormHolder returns the removed IDs of the "form_holder" edge to the Pokemons entity.
func (m *FormsMutation) RemovedFormHolderIDs() (ids []int) {
	for id := range m.removedform_holder {
		ids = append(ids, id)
	}
	return
}

// FormHolderIDs returns the "form_holder" edge IDs in the mutation.
func (m *FormsMutation) FormHolderIDs() (ids []int) {
	for id := range m.form_holder {
		ids = append(ids, id)
	}
	return
}

// ResetFormHolder resets all changes to the "form_holder" edge.
func (m *FormsMutation) ResetFormHolder() {
	m.form_holder = nil
	m.clearedform_holder = false
	m.removedform_holder = nil
}

// Where appends a list predicates to the FormsMutation builder.
func (m *FormsMutation) Where(ps ...predicate.Forms) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FormsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Forms).
func (m *FormsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FormsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.form_name != nil {
		fields = append(fields, forms.FieldFormName)
	}
	if m.is_regional_variant != nil {
		fields = append(fields, forms.FieldIsRegionalVariant)
	}
	if m.regionName != nil {
		fields = append(fields, forms.FieldRegionName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FormsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case forms.FieldFormName:
		return m.FormName()
	case forms.FieldIsRegionalVariant:
		return m.IsRegionalVariant()
	case forms.FieldRegionName:
		return m.RegionName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FormsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case forms.FieldFormName:
		return m.OldFormName(ctx)
	case forms.FieldIsRegionalVariant:
		return m.OldIsRegionalVariant(ctx)
	case forms.FieldRegionName:
		return m.OldRegionName(ctx)
	}
	return nil, fmt.Errorf("unknown Forms field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FormsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case forms.FieldFormName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormName(v)
		return nil
	case forms.FieldIsRegionalVariant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRegionalVariant(v)
		return nil
	case forms.FieldRegionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionName(v)
		return nil
	}
	return fmt.Errorf("unknown Forms field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FormsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FormsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FormsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Forms numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FormsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FormsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FormsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Forms nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FormsMutation) ResetField(name string) error {
	switch name {
	case forms.FieldFormName:
		m.ResetFormName()
		return nil
	case forms.FieldIsRegionalVariant:
		m.ResetIsRegionalVariant()
		return nil
	case forms.FieldRegionName:
		m.ResetRegionName()
		return nil
	}
	return fmt.Errorf("unknown Forms field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FormsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.form_holder != nil {
		edges = append(edges, forms.EdgeFormHolder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FormsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case forms.EdgeFormHolder:
		ids := make([]ent.Value, 0, len(m.form_holder))
		for id := range m.form_holder {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FormsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedform_holder != nil {
		edges = append(edges, forms.EdgeFormHolder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FormsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case forms.EdgeFormHolder:
		ids := make([]ent.Value, 0, len(m.removedform_holder))
		for id := range m.removedform_holder {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FormsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedform_holder {
		edges = append(edges, forms.EdgeFormHolder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FormsMutation) EdgeCleared(name string) bool {
	switch name {
	case forms.EdgeFormHolder:
		return m.clearedform_holder
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FormsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Forms unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FormsMutation) ResetEdge(name string) error {
	switch name {
	case forms.EdgeFormHolder:
		m.ResetFormHolder()
		return nil
	}
	return fmt.Errorf("unknown Forms edge %s", name)
}

// HeldItemsMutation represents an operation that mutates the HeldItems nodes in the graph.
type HeldItemsMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	physical_move_power_correction_value     *int
	addphysical_move_power_correction_value  *int
	special_move_power_correction_value      *int
	addspecial_move_power_correction_value   *int
	attack_power_correction_value            *int
	addattack_power_correction_value         *int
	special_attack_power_correction_value    *int
	addspecial_attack_power_correction_value *int
	attack_correction_value                  *int
	addattack_correction_value               *int
	special_attack_correction_value          *int
	addspecial_attack_correction_value       *int
	deffense_correction_value                *int
	adddeffense_correction_value             *int
	special_deffense_correction_value        *int
	addspecial_deffense_correction_value     *int
	damage_correction_type1                  *property.Types
	damage_correction_value1                 *int
	adddamage_correction_value1              *int
	damage_correction_type2                  *property.Types
	damage_correction_value2                 *int
	adddamage_correction_value2              *int
	weight_correction_value                  *int
	addweight_correction_value               *int
	name                                     *string
	description                              *string
	clearedFields                            map[string]struct{}
	to_trained_pokemon_item                  map[int]struct{}
	removedto_trained_pokemon_item           map[int]struct{}
	clearedto_trained_pokemon_item           bool
	done                                     bool
	oldValue                                 func(context.Context) (*HeldItems, error)
	predicates                               []predicate.HeldItems
}

var _ ent.Mutation = (*HeldItemsMutation)(nil)

// helditemsOption allows management of the mutation configuration using functional options.
type helditemsOption func(*HeldItemsMutation)

// newHeldItemsMutation creates new mutation for the HeldItems entity.
func newHeldItemsMutation(c config, op Op, opts ...helditemsOption) *HeldItemsMutation {
	m := &HeldItemsMutation{
		config:        c,
		op:            op,
		typ:           TypeHeldItems,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHeldItemsID sets the ID field of the mutation.
func withHeldItemsID(id int) helditemsOption {
	return func(m *HeldItemsMutation) {
		var (
			err   error
			once  sync.Once
			value *HeldItems
		)
		m.oldValue = func(ctx context.Context) (*HeldItems, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HeldItems.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHeldItems sets the old HeldItems of the mutation.
func withHeldItems(node *HeldItems) helditemsOption {
	return func(m *HeldItemsMutation) {
		m.oldValue = func(context.Context) (*HeldItems, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HeldItemsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HeldItemsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HeldItemsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPhysicalMovePowerCorrectionValue sets the "physical_move_power_correction_value" field.
func (m *HeldItemsMutation) SetPhysicalMovePowerCorrectionValue(i int) {
	m.physical_move_power_correction_value = &i
	m.addphysical_move_power_correction_value = nil
}

// PhysicalMovePowerCorrectionValue returns the value of the "physical_move_power_correction_value" field in the mutation.
func (m *HeldItemsMutation) PhysicalMovePowerCorrectionValue() (r int, exists bool) {
	v := m.physical_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicalMovePowerCorrectionValue returns the old "physical_move_power_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldPhysicalMovePowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhysicalMovePowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhysicalMovePowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicalMovePowerCorrectionValue: %w", err)
	}
	return oldValue.PhysicalMovePowerCorrectionValue, nil
}

// AddPhysicalMovePowerCorrectionValue adds i to the "physical_move_power_correction_value" field.
func (m *HeldItemsMutation) AddPhysicalMovePowerCorrectionValue(i int) {
	if m.addphysical_move_power_correction_value != nil {
		*m.addphysical_move_power_correction_value += i
	} else {
		m.addphysical_move_power_correction_value = &i
	}
}

// AddedPhysicalMovePowerCorrectionValue returns the value that was added to the "physical_move_power_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedPhysicalMovePowerCorrectionValue() (r int, exists bool) {
	v := m.addphysical_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetPhysicalMovePowerCorrectionValue resets all changes to the "physical_move_power_correction_value" field.
func (m *HeldItemsMutation) ResetPhysicalMovePowerCorrectionValue() {
	m.physical_move_power_correction_value = nil
	m.addphysical_move_power_correction_value = nil
}

// SetSpecialMovePowerCorrectionValue sets the "special_move_power_correction_value" field.
func (m *HeldItemsMutation) SetSpecialMovePowerCorrectionValue(i int) {
	m.special_move_power_correction_value = &i
	m.addspecial_move_power_correction_value = nil
}

// SpecialMovePowerCorrectionValue returns the value of the "special_move_power_correction_value" field in the mutation.
func (m *HeldItemsMutation) SpecialMovePowerCorrectionValue() (r int, exists bool) {
	v := m.special_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialMovePowerCorrectionValue returns the old "special_move_power_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldSpecialMovePowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialMovePowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialMovePowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialMovePowerCorrectionValue: %w", err)
	}
	return oldValue.SpecialMovePowerCorrectionValue, nil
}

// AddSpecialMovePowerCorrectionValue adds i to the "special_move_power_correction_value" field.
func (m *HeldItemsMutation) AddSpecialMovePowerCorrectionValue(i int) {
	if m.addspecial_move_power_correction_value != nil {
		*m.addspecial_move_power_correction_value += i
	} else {
		m.addspecial_move_power_correction_value = &i
	}
}

// AddedSpecialMovePowerCorrectionValue returns the value that was added to the "special_move_power_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedSpecialMovePowerCorrectionValue() (r int, exists bool) {
	v := m.addspecial_move_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialMovePowerCorrectionValue resets all changes to the "special_move_power_correction_value" field.
func (m *HeldItemsMutation) ResetSpecialMovePowerCorrectionValue() {
	m.special_move_power_correction_value = nil
	m.addspecial_move_power_correction_value = nil
}

// SetAttackPowerCorrectionValue sets the "attack_power_correction_value" field.
func (m *HeldItemsMutation) SetAttackPowerCorrectionValue(i int) {
	m.attack_power_correction_value = &i
	m.addattack_power_correction_value = nil
}

// AttackPowerCorrectionValue returns the value of the "attack_power_correction_value" field in the mutation.
func (m *HeldItemsMutation) AttackPowerCorrectionValue() (r int, exists bool) {
	v := m.attack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAttackPowerCorrectionValue returns the old "attack_power_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldAttackPowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttackPowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttackPowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttackPowerCorrectionValue: %w", err)
	}
	return oldValue.AttackPowerCorrectionValue, nil
}

// AddAttackPowerCorrectionValue adds i to the "attack_power_correction_value" field.
func (m *HeldItemsMutation) AddAttackPowerCorrectionValue(i int) {
	if m.addattack_power_correction_value != nil {
		*m.addattack_power_correction_value += i
	} else {
		m.addattack_power_correction_value = &i
	}
}

// AddedAttackPowerCorrectionValue returns the value that was added to the "attack_power_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedAttackPowerCorrectionValue() (r int, exists bool) {
	v := m.addattack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttackPowerCorrectionValue resets all changes to the "attack_power_correction_value" field.
func (m *HeldItemsMutation) ResetAttackPowerCorrectionValue() {
	m.attack_power_correction_value = nil
	m.addattack_power_correction_value = nil
}

// SetSpecialAttackPowerCorrectionValue sets the "special_attack_power_correction_value" field.
func (m *HeldItemsMutation) SetSpecialAttackPowerCorrectionValue(i int) {
	m.special_attack_power_correction_value = &i
	m.addspecial_attack_power_correction_value = nil
}

// SpecialAttackPowerCorrectionValue returns the value of the "special_attack_power_correction_value" field in the mutation.
func (m *HeldItemsMutation) SpecialAttackPowerCorrectionValue() (r int, exists bool) {
	v := m.special_attack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialAttackPowerCorrectionValue returns the old "special_attack_power_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldSpecialAttackPowerCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialAttackPowerCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialAttackPowerCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialAttackPowerCorrectionValue: %w", err)
	}
	return oldValue.SpecialAttackPowerCorrectionValue, nil
}

// AddSpecialAttackPowerCorrectionValue adds i to the "special_attack_power_correction_value" field.
func (m *HeldItemsMutation) AddSpecialAttackPowerCorrectionValue(i int) {
	if m.addspecial_attack_power_correction_value != nil {
		*m.addspecial_attack_power_correction_value += i
	} else {
		m.addspecial_attack_power_correction_value = &i
	}
}

// AddedSpecialAttackPowerCorrectionValue returns the value that was added to the "special_attack_power_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedSpecialAttackPowerCorrectionValue() (r int, exists bool) {
	v := m.addspecial_attack_power_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialAttackPowerCorrectionValue resets all changes to the "special_attack_power_correction_value" field.
func (m *HeldItemsMutation) ResetSpecialAttackPowerCorrectionValue() {
	m.special_attack_power_correction_value = nil
	m.addspecial_attack_power_correction_value = nil
}

// SetAttackCorrectionValue sets the "attack_correction_value" field.
func (m *HeldItemsMutation) SetAttackCorrectionValue(i int) {
	m.attack_correction_value = &i
	m.addattack_correction_value = nil
}

// AttackCorrectionValue returns the value of the "attack_correction_value" field in the mutation.
func (m *HeldItemsMutation) AttackCorrectionValue() (r int, exists bool) {
	v := m.attack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAttackCorrectionValue returns the old "attack_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldAttackCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttackCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttackCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttackCorrectionValue: %w", err)
	}
	return oldValue.AttackCorrectionValue, nil
}

// AddAttackCorrectionValue adds i to the "attack_correction_value" field.
func (m *HeldItemsMutation) AddAttackCorrectionValue(i int) {
	if m.addattack_correction_value != nil {
		*m.addattack_correction_value += i
	} else {
		m.addattack_correction_value = &i
	}
}

// AddedAttackCorrectionValue returns the value that was added to the "attack_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedAttackCorrectionValue() (r int, exists bool) {
	v := m.addattack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttackCorrectionValue resets all changes to the "attack_correction_value" field.
func (m *HeldItemsMutation) ResetAttackCorrectionValue() {
	m.attack_correction_value = nil
	m.addattack_correction_value = nil
}

// SetSpecialAttackCorrectionValue sets the "special_attack_correction_value" field.
func (m *HeldItemsMutation) SetSpecialAttackCorrectionValue(i int) {
	m.special_attack_correction_value = &i
	m.addspecial_attack_correction_value = nil
}

// SpecialAttackCorrectionValue returns the value of the "special_attack_correction_value" field in the mutation.
func (m *HeldItemsMutation) SpecialAttackCorrectionValue() (r int, exists bool) {
	v := m.special_attack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialAttackCorrectionValue returns the old "special_attack_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldSpecialAttackCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialAttackCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialAttackCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialAttackCorrectionValue: %w", err)
	}
	return oldValue.SpecialAttackCorrectionValue, nil
}

// AddSpecialAttackCorrectionValue adds i to the "special_attack_correction_value" field.
func (m *HeldItemsMutation) AddSpecialAttackCorrectionValue(i int) {
	if m.addspecial_attack_correction_value != nil {
		*m.addspecial_attack_correction_value += i
	} else {
		m.addspecial_attack_correction_value = &i
	}
}

// AddedSpecialAttackCorrectionValue returns the value that was added to the "special_attack_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedSpecialAttackCorrectionValue() (r int, exists bool) {
	v := m.addspecial_attack_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialAttackCorrectionValue resets all changes to the "special_attack_correction_value" field.
func (m *HeldItemsMutation) ResetSpecialAttackCorrectionValue() {
	m.special_attack_correction_value = nil
	m.addspecial_attack_correction_value = nil
}

// SetDeffenseCorrectionValue sets the "deffense_correction_value" field.
func (m *HeldItemsMutation) SetDeffenseCorrectionValue(i int) {
	m.deffense_correction_value = &i
	m.adddeffense_correction_value = nil
}

// DeffenseCorrectionValue returns the value of the "deffense_correction_value" field in the mutation.
func (m *HeldItemsMutation) DeffenseCorrectionValue() (r int, exists bool) {
	v := m.deffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDeffenseCorrectionValue returns the old "deffense_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldDeffenseCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeffenseCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeffenseCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeffenseCorrectionValue: %w", err)
	}
	return oldValue.DeffenseCorrectionValue, nil
}

// AddDeffenseCorrectionValue adds i to the "deffense_correction_value" field.
func (m *HeldItemsMutation) AddDeffenseCorrectionValue(i int) {
	if m.adddeffense_correction_value != nil {
		*m.adddeffense_correction_value += i
	} else {
		m.adddeffense_correction_value = &i
	}
}

// AddedDeffenseCorrectionValue returns the value that was added to the "deffense_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedDeffenseCorrectionValue() (r int, exists bool) {
	v := m.adddeffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeffenseCorrectionValue resets all changes to the "deffense_correction_value" field.
func (m *HeldItemsMutation) ResetDeffenseCorrectionValue() {
	m.deffense_correction_value = nil
	m.adddeffense_correction_value = nil
}

// SetSpecialDeffenseCorrectionValue sets the "special_deffense_correction_value" field.
func (m *HeldItemsMutation) SetSpecialDeffenseCorrectionValue(i int) {
	m.special_deffense_correction_value = &i
	m.addspecial_deffense_correction_value = nil
}

// SpecialDeffenseCorrectionValue returns the value of the "special_deffense_correction_value" field in the mutation.
func (m *HeldItemsMutation) SpecialDeffenseCorrectionValue() (r int, exists bool) {
	v := m.special_deffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialDeffenseCorrectionValue returns the old "special_deffense_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldSpecialDeffenseCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialDeffenseCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialDeffenseCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialDeffenseCorrectionValue: %w", err)
	}
	return oldValue.SpecialDeffenseCorrectionValue, nil
}

// AddSpecialDeffenseCorrectionValue adds i to the "special_deffense_correction_value" field.
func (m *HeldItemsMutation) AddSpecialDeffenseCorrectionValue(i int) {
	if m.addspecial_deffense_correction_value != nil {
		*m.addspecial_deffense_correction_value += i
	} else {
		m.addspecial_deffense_correction_value = &i
	}
}

// AddedSpecialDeffenseCorrectionValue returns the value that was added to the "special_deffense_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedSpecialDeffenseCorrectionValue() (r int, exists bool) {
	v := m.addspecial_deffense_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecialDeffenseCorrectionValue resets all changes to the "special_deffense_correction_value" field.
func (m *HeldItemsMutation) ResetSpecialDeffenseCorrectionValue() {
	m.special_deffense_correction_value = nil
	m.addspecial_deffense_correction_value = nil
}

// SetDamageCorrectionType1 sets the "damage_correction_type1" field.
func (m *HeldItemsMutation) SetDamageCorrectionType1(pr property.Types) {
	m.damage_correction_type1 = &pr
}

// DamageCorrectionType1 returns the value of the "damage_correction_type1" field in the mutation.
func (m *HeldItemsMutation) DamageCorrectionType1() (r property.Types, exists bool) {
	v := m.damage_correction_type1
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionType1 returns the old "damage_correction_type1" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldDamageCorrectionType1(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionType1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionType1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionType1: %w", err)
	}
	return oldValue.DamageCorrectionType1, nil
}

// ResetDamageCorrectionType1 resets all changes to the "damage_correction_type1" field.
func (m *HeldItemsMutation) ResetDamageCorrectionType1() {
	m.damage_correction_type1 = nil
}

// SetDamageCorrectionValue1 sets the "damage_correction_value1" field.
func (m *HeldItemsMutation) SetDamageCorrectionValue1(i int) {
	m.damage_correction_value1 = &i
	m.adddamage_correction_value1 = nil
}

// DamageCorrectionValue1 returns the value of the "damage_correction_value1" field in the mutation.
func (m *HeldItemsMutation) DamageCorrectionValue1() (r int, exists bool) {
	v := m.damage_correction_value1
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionValue1 returns the old "damage_correction_value1" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldDamageCorrectionValue1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionValue1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionValue1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionValue1: %w", err)
	}
	return oldValue.DamageCorrectionValue1, nil
}

// AddDamageCorrectionValue1 adds i to the "damage_correction_value1" field.
func (m *HeldItemsMutation) AddDamageCorrectionValue1(i int) {
	if m.adddamage_correction_value1 != nil {
		*m.adddamage_correction_value1 += i
	} else {
		m.adddamage_correction_value1 = &i
	}
}

// AddedDamageCorrectionValue1 returns the value that was added to the "damage_correction_value1" field in this mutation.
func (m *HeldItemsMutation) AddedDamageCorrectionValue1() (r int, exists bool) {
	v := m.adddamage_correction_value1
	if v == nil {
		return
	}
	return *v, true
}

// ResetDamageCorrectionValue1 resets all changes to the "damage_correction_value1" field.
func (m *HeldItemsMutation) ResetDamageCorrectionValue1() {
	m.damage_correction_value1 = nil
	m.adddamage_correction_value1 = nil
}

// SetDamageCorrectionType2 sets the "damage_correction_type2" field.
func (m *HeldItemsMutation) SetDamageCorrectionType2(pr property.Types) {
	m.damage_correction_type2 = &pr
}

// DamageCorrectionType2 returns the value of the "damage_correction_type2" field in the mutation.
func (m *HeldItemsMutation) DamageCorrectionType2() (r property.Types, exists bool) {
	v := m.damage_correction_type2
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionType2 returns the old "damage_correction_type2" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldDamageCorrectionType2(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionType2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionType2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionType2: %w", err)
	}
	return oldValue.DamageCorrectionType2, nil
}

// ClearDamageCorrectionType2 clears the value of the "damage_correction_type2" field.
func (m *HeldItemsMutation) ClearDamageCorrectionType2() {
	m.damage_correction_type2 = nil
	m.clearedFields[helditems.FieldDamageCorrectionType2] = struct{}{}
}

// DamageCorrectionType2Cleared returns if the "damage_correction_type2" field was cleared in this mutation.
func (m *HeldItemsMutation) DamageCorrectionType2Cleared() bool {
	_, ok := m.clearedFields[helditems.FieldDamageCorrectionType2]
	return ok
}

// ResetDamageCorrectionType2 resets all changes to the "damage_correction_type2" field.
func (m *HeldItemsMutation) ResetDamageCorrectionType2() {
	m.damage_correction_type2 = nil
	delete(m.clearedFields, helditems.FieldDamageCorrectionType2)
}

// SetDamageCorrectionValue2 sets the "damage_correction_value2" field.
func (m *HeldItemsMutation) SetDamageCorrectionValue2(i int) {
	m.damage_correction_value2 = &i
	m.adddamage_correction_value2 = nil
}

// DamageCorrectionValue2 returns the value of the "damage_correction_value2" field in the mutation.
func (m *HeldItemsMutation) DamageCorrectionValue2() (r int, exists bool) {
	v := m.damage_correction_value2
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageCorrectionValue2 returns the old "damage_correction_value2" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldDamageCorrectionValue2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDamageCorrectionValue2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDamageCorrectionValue2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageCorrectionValue2: %w", err)
	}
	return oldValue.DamageCorrectionValue2, nil
}

// AddDamageCorrectionValue2 adds i to the "damage_correction_value2" field.
func (m *HeldItemsMutation) AddDamageCorrectionValue2(i int) {
	if m.adddamage_correction_value2 != nil {
		*m.adddamage_correction_value2 += i
	} else {
		m.adddamage_correction_value2 = &i
	}
}

// AddedDamageCorrectionValue2 returns the value that was added to the "damage_correction_value2" field in this mutation.
func (m *HeldItemsMutation) AddedDamageCorrectionValue2() (r int, exists bool) {
	v := m.adddamage_correction_value2
	if v == nil {
		return
	}
	return *v, true
}

// ClearDamageCorrectionValue2 clears the value of the "damage_correction_value2" field.
func (m *HeldItemsMutation) ClearDamageCorrectionValue2() {
	m.damage_correction_value2 = nil
	m.adddamage_correction_value2 = nil
	m.clearedFields[helditems.FieldDamageCorrectionValue2] = struct{}{}
}

// DamageCorrectionValue2Cleared returns if the "damage_correction_value2" field was cleared in this mutation.
func (m *HeldItemsMutation) DamageCorrectionValue2Cleared() bool {
	_, ok := m.clearedFields[helditems.FieldDamageCorrectionValue2]
	return ok
}

// ResetDamageCorrectionValue2 resets all changes to the "damage_correction_value2" field.
func (m *HeldItemsMutation) ResetDamageCorrectionValue2() {
	m.damage_correction_value2 = nil
	m.adddamage_correction_value2 = nil
	delete(m.clearedFields, helditems.FieldDamageCorrectionValue2)
}

// SetWeightCorrectionValue sets the "weight_correction_value" field.
func (m *HeldItemsMutation) SetWeightCorrectionValue(i int) {
	m.weight_correction_value = &i
	m.addweight_correction_value = nil
}

// WeightCorrectionValue returns the value of the "weight_correction_value" field in the mutation.
func (m *HeldItemsMutation) WeightCorrectionValue() (r int, exists bool) {
	v := m.weight_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightCorrectionValue returns the old "weight_correction_value" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldWeightCorrectionValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightCorrectionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightCorrectionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightCorrectionValue: %w", err)
	}
	return oldValue.WeightCorrectionValue, nil
}

// AddWeightCorrectionValue adds i to the "weight_correction_value" field.
func (m *HeldItemsMutation) AddWeightCorrectionValue(i int) {
	if m.addweight_correction_value != nil {
		*m.addweight_correction_value += i
	} else {
		m.addweight_correction_value = &i
	}
}

// AddedWeightCorrectionValue returns the value that was added to the "weight_correction_value" field in this mutation.
func (m *HeldItemsMutation) AddedWeightCorrectionValue() (r int, exists bool) {
	v := m.addweight_correction_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightCorrectionValue resets all changes to the "weight_correction_value" field.
func (m *HeldItemsMutation) ResetWeightCorrectionValue() {
	m.weight_correction_value = nil
	m.addweight_correction_value = nil
}

// SetName sets the "name" field.
func (m *HeldItemsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HeldItemsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HeldItemsMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HeldItemsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HeldItemsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HeldItems entity.
// If the HeldItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeldItemsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HeldItemsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[helditems.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HeldItemsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[helditems.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HeldItemsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, helditems.FieldDescription)
}

// AddToTrainedPokemonItemIDs adds the "to_trained_pokemon_item" edge to the TrainedPokemonDetails entity by ids.
func (m *HeldItemsMutation) AddToTrainedPokemonItemIDs(ids ...int) {
	if m.to_trained_pokemon_item == nil {
		m.to_trained_pokemon_item = make(map[int]struct{})
	}
	for i := range ids {
		m.to_trained_pokemon_item[ids[i]] = struct{}{}
	}
}

// ClearToTrainedPokemonItem clears the "to_trained_pokemon_item" edge to the TrainedPokemonDetails entity.
func (m *HeldItemsMutation) ClearToTrainedPokemonItem() {
	m.clearedto_trained_pokemon_item = true
}

// ToTrainedPokemonItemCleared reports if the "to_trained_pokemon_item" edge to the TrainedPokemonDetails entity was cleared.
func (m *HeldItemsMutation) ToTrainedPokemonItemCleared() bool {
	return m.clearedto_trained_pokemon_item
}

// RemoveToTrainedPokemonItemIDs removes the "to_trained_pokemon_item" edge to the TrainedPokemonDetails entity by IDs.
func (m *HeldItemsMutation) RemoveToTrainedPokemonItemIDs(ids ...int) {
	if m.removedto_trained_pokemon_item == nil {
		m.removedto_trained_pokemon_item = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_trained_pokemon_item, ids[i])
		m.removedto_trained_pokemon_item[ids[i]] = struct{}{}
	}
}

// RemovedToTrainedPokemonItem returns the removed IDs of the "to_trained_pokemon_item" edge to the TrainedPokemonDetails entity.
func (m *HeldItemsMutation) RemovedToTrainedPokemonItemIDs() (ids []int) {
	for id := range m.removedto_trained_pokemon_item {
		ids = append(ids, id)
	}
	return
}

// ToTrainedPokemonItemIDs returns the "to_trained_pokemon_item" edge IDs in the mutation.
func (m *HeldItemsMutation) ToTrainedPokemonItemIDs() (ids []int) {
	for id := range m.to_trained_pokemon_item {
		ids = append(ids, id)
	}
	return
}

// ResetToTrainedPokemonItem resets all changes to the "to_trained_pokemon_item" edge.
func (m *HeldItemsMutation) ResetToTrainedPokemonItem() {
	m.to_trained_pokemon_item = nil
	m.clearedto_trained_pokemon_item = false
	m.removedto_trained_pokemon_item = nil
}

// Where appends a list predicates to the HeldItemsMutation builder.
func (m *HeldItemsMutation) Where(ps ...predicate.HeldItems) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HeldItemsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HeldItems).
func (m *HeldItemsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HeldItemsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.physical_move_power_correction_value != nil {
		fields = append(fields, helditems.FieldPhysicalMovePowerCorrectionValue)
	}
	if m.special_move_power_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialMovePowerCorrectionValue)
	}
	if m.attack_power_correction_value != nil {
		fields = append(fields, helditems.FieldAttackPowerCorrectionValue)
	}
	if m.special_attack_power_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialAttackPowerCorrectionValue)
	}
	if m.attack_correction_value != nil {
		fields = append(fields, helditems.FieldAttackCorrectionValue)
	}
	if m.special_attack_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialAttackCorrectionValue)
	}
	if m.deffense_correction_value != nil {
		fields = append(fields, helditems.FieldDeffenseCorrectionValue)
	}
	if m.special_deffense_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialDeffenseCorrectionValue)
	}
	if m.damage_correction_type1 != nil {
		fields = append(fields, helditems.FieldDamageCorrectionType1)
	}
	if m.damage_correction_value1 != nil {
		fields = append(fields, helditems.FieldDamageCorrectionValue1)
	}
	if m.damage_correction_type2 != nil {
		fields = append(fields, helditems.FieldDamageCorrectionType2)
	}
	if m.damage_correction_value2 != nil {
		fields = append(fields, helditems.FieldDamageCorrectionValue2)
	}
	if m.weight_correction_value != nil {
		fields = append(fields, helditems.FieldWeightCorrectionValue)
	}
	if m.name != nil {
		fields = append(fields, helditems.FieldName)
	}
	if m.description != nil {
		fields = append(fields, helditems.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HeldItemsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case helditems.FieldPhysicalMovePowerCorrectionValue:
		return m.PhysicalMovePowerCorrectionValue()
	case helditems.FieldSpecialMovePowerCorrectionValue:
		return m.SpecialMovePowerCorrectionValue()
	case helditems.FieldAttackPowerCorrectionValue:
		return m.AttackPowerCorrectionValue()
	case helditems.FieldSpecialAttackPowerCorrectionValue:
		return m.SpecialAttackPowerCorrectionValue()
	case helditems.FieldAttackCorrectionValue:
		return m.AttackCorrectionValue()
	case helditems.FieldSpecialAttackCorrectionValue:
		return m.SpecialAttackCorrectionValue()
	case helditems.FieldDeffenseCorrectionValue:
		return m.DeffenseCorrectionValue()
	case helditems.FieldSpecialDeffenseCorrectionValue:
		return m.SpecialDeffenseCorrectionValue()
	case helditems.FieldDamageCorrectionType1:
		return m.DamageCorrectionType1()
	case helditems.FieldDamageCorrectionValue1:
		return m.DamageCorrectionValue1()
	case helditems.FieldDamageCorrectionType2:
		return m.DamageCorrectionType2()
	case helditems.FieldDamageCorrectionValue2:
		return m.DamageCorrectionValue2()
	case helditems.FieldWeightCorrectionValue:
		return m.WeightCorrectionValue()
	case helditems.FieldName:
		return m.Name()
	case helditems.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HeldItemsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case helditems.FieldPhysicalMovePowerCorrectionValue:
		return m.OldPhysicalMovePowerCorrectionValue(ctx)
	case helditems.FieldSpecialMovePowerCorrectionValue:
		return m.OldSpecialMovePowerCorrectionValue(ctx)
	case helditems.FieldAttackPowerCorrectionValue:
		return m.OldAttackPowerCorrectionValue(ctx)
	case helditems.FieldSpecialAttackPowerCorrectionValue:
		return m.OldSpecialAttackPowerCorrectionValue(ctx)
	case helditems.FieldAttackCorrectionValue:
		return m.OldAttackCorrectionValue(ctx)
	case helditems.FieldSpecialAttackCorrectionValue:
		return m.OldSpecialAttackCorrectionValue(ctx)
	case helditems.FieldDeffenseCorrectionValue:
		return m.OldDeffenseCorrectionValue(ctx)
	case helditems.FieldSpecialDeffenseCorrectionValue:
		return m.OldSpecialDeffenseCorrectionValue(ctx)
	case helditems.FieldDamageCorrectionType1:
		return m.OldDamageCorrectionType1(ctx)
	case helditems.FieldDamageCorrectionValue1:
		return m.OldDamageCorrectionValue1(ctx)
	case helditems.FieldDamageCorrectionType2:
		return m.OldDamageCorrectionType2(ctx)
	case helditems.FieldDamageCorrectionValue2:
		return m.OldDamageCorrectionValue2(ctx)
	case helditems.FieldWeightCorrectionValue:
		return m.OldWeightCorrectionValue(ctx)
	case helditems.FieldName:
		return m.OldName(ctx)
	case helditems.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown HeldItems field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HeldItemsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case helditems.FieldPhysicalMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicalMovePowerCorrectionValue(v)
		return nil
	case helditems.FieldSpecialMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialMovePowerCorrectionValue(v)
		return nil
	case helditems.FieldAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttackPowerCorrectionValue(v)
		return nil
	case helditems.FieldSpecialAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialAttackPowerCorrectionValue(v)
		return nil
	case helditems.FieldAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttackCorrectionValue(v)
		return nil
	case helditems.FieldSpecialAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialAttackCorrectionValue(v)
		return nil
	case helditems.FieldDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeffenseCorrectionValue(v)
		return nil
	case helditems.FieldSpecialDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialDeffenseCorrectionValue(v)
		return nil
	case helditems.FieldDamageCorrectionType1:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionType1(v)
		return nil
	case helditems.FieldDamageCorrectionValue1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionValue1(v)
		return nil
	case helditems.FieldDamageCorrectionType2:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionType2(v)
		return nil
	case helditems.FieldDamageCorrectionValue2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageCorrectionValue2(v)
		return nil
	case helditems.FieldWeightCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightCorrectionValue(v)
		return nil
	case helditems.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case helditems.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown HeldItems field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HeldItemsMutation) AddedFields() []string {
	var fields []string
	if m.addphysical_move_power_correction_value != nil {
		fields = append(fields, helditems.FieldPhysicalMovePowerCorrectionValue)
	}
	if m.addspecial_move_power_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialMovePowerCorrectionValue)
	}
	if m.addattack_power_correction_value != nil {
		fields = append(fields, helditems.FieldAttackPowerCorrectionValue)
	}
	if m.addspecial_attack_power_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialAttackPowerCorrectionValue)
	}
	if m.addattack_correction_value != nil {
		fields = append(fields, helditems.FieldAttackCorrectionValue)
	}
	if m.addspecial_attack_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialAttackCorrectionValue)
	}
	if m.adddeffense_correction_value != nil {
		fields = append(fields, helditems.FieldDeffenseCorrectionValue)
	}
	if m.addspecial_deffense_correction_value != nil {
		fields = append(fields, helditems.FieldSpecialDeffenseCorrectionValue)
	}
	if m.adddamage_correction_value1 != nil {
		fields = append(fields, helditems.FieldDamageCorrectionValue1)
	}
	if m.adddamage_correction_value2 != nil {
		fields = append(fields, helditems.FieldDamageCorrectionValue2)
	}
	if m.addweight_correction_value != nil {
		fields = append(fields, helditems.FieldWeightCorrectionValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HeldItemsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case helditems.FieldPhysicalMovePowerCorrectionValue:
		return m.AddedPhysicalMovePowerCorrectionValue()
	case helditems.FieldSpecialMovePowerCorrectionValue:
		return m.AddedSpecialMovePowerCorrectionValue()
	case helditems.FieldAttackPowerCorrectionValue:
		return m.AddedAttackPowerCorrectionValue()
	case helditems.FieldSpecialAttackPowerCorrectionValue:
		return m.AddedSpecialAttackPowerCorrectionValue()
	case helditems.FieldAttackCorrectionValue:
		return m.AddedAttackCorrectionValue()
	case helditems.FieldSpecialAttackCorrectionValue:
		return m.AddedSpecialAttackCorrectionValue()
	case helditems.FieldDeffenseCorrectionValue:
		return m.AddedDeffenseCorrectionValue()
	case helditems.FieldSpecialDeffenseCorrectionValue:
		return m.AddedSpecialDeffenseCorrectionValue()
	case helditems.FieldDamageCorrectionValue1:
		return m.AddedDamageCorrectionValue1()
	case helditems.FieldDamageCorrectionValue2:
		return m.AddedDamageCorrectionValue2()
	case helditems.FieldWeightCorrectionValue:
		return m.AddedWeightCorrectionValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HeldItemsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case helditems.FieldPhysicalMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhysicalMovePowerCorrectionValue(v)
		return nil
	case helditems.FieldSpecialMovePowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialMovePowerCorrectionValue(v)
		return nil
	case helditems.FieldAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttackPowerCorrectionValue(v)
		return nil
	case helditems.FieldSpecialAttackPowerCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialAttackPowerCorrectionValue(v)
		return nil
	case helditems.FieldAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttackCorrectionValue(v)
		return nil
	case helditems.FieldSpecialAttackCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialAttackCorrectionValue(v)
		return nil
	case helditems.FieldDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeffenseCorrectionValue(v)
		return nil
	case helditems.FieldSpecialDeffenseCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecialDeffenseCorrectionValue(v)
		return nil
	case helditems.FieldDamageCorrectionValue1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDamageCorrectionValue1(v)
		return nil
	case helditems.FieldDamageCorrectionValue2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDamageCorrectionValue2(v)
		return nil
	case helditems.FieldWeightCorrectionValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightCorrectionValue(v)
		return nil
	}
	return fmt.Errorf("unknown HeldItems numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HeldItemsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(helditems.FieldDamageCorrectionType2) {
		fields = append(fields, helditems.FieldDamageCorrectionType2)
	}
	if m.FieldCleared(helditems.FieldDamageCorrectionValue2) {
		fields = append(fields, helditems.FieldDamageCorrectionValue2)
	}
	if m.FieldCleared(helditems.FieldDescription) {
		fields = append(fields, helditems.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HeldItemsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HeldItemsMutation) ClearField(name string) error {
	switch name {
	case helditems.FieldDamageCorrectionType2:
		m.ClearDamageCorrectionType2()
		return nil
	case helditems.FieldDamageCorrectionValue2:
		m.ClearDamageCorrectionValue2()
		return nil
	case helditems.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown HeldItems nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HeldItemsMutation) ResetField(name string) error {
	switch name {
	case helditems.FieldPhysicalMovePowerCorrectionValue:
		m.ResetPhysicalMovePowerCorrectionValue()
		return nil
	case helditems.FieldSpecialMovePowerCorrectionValue:
		m.ResetSpecialMovePowerCorrectionValue()
		return nil
	case helditems.FieldAttackPowerCorrectionValue:
		m.ResetAttackPowerCorrectionValue()
		return nil
	case helditems.FieldSpecialAttackPowerCorrectionValue:
		m.ResetSpecialAttackPowerCorrectionValue()
		return nil
	case helditems.FieldAttackCorrectionValue:
		m.ResetAttackCorrectionValue()
		return nil
	case helditems.FieldSpecialAttackCorrectionValue:
		m.ResetSpecialAttackCorrectionValue()
		return nil
	case helditems.FieldDeffenseCorrectionValue:
		m.ResetDeffenseCorrectionValue()
		return nil
	case helditems.FieldSpecialDeffenseCorrectionValue:
		m.ResetSpecialDeffenseCorrectionValue()
		return nil
	case helditems.FieldDamageCorrectionType1:
		m.ResetDamageCorrectionType1()
		return nil
	case helditems.FieldDamageCorrectionValue1:
		m.ResetDamageCorrectionValue1()
		return nil
	case helditems.FieldDamageCorrectionType2:
		m.ResetDamageCorrectionType2()
		return nil
	case helditems.FieldDamageCorrectionValue2:
		m.ResetDamageCorrectionValue2()
		return nil
	case helditems.FieldWeightCorrectionValue:
		m.ResetWeightCorrectionValue()
		return nil
	case helditems.FieldName:
		m.ResetName()
		return nil
	case helditems.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown HeldItems field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HeldItemsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.to_trained_pokemon_item != nil {
		edges = append(edges, helditems.EdgeToTrainedPokemonItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HeldItemsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case helditems.EdgeToTrainedPokemonItem:
		ids := make([]ent.Value, 0, len(m.to_trained_pokemon_item))
		for id := range m.to_trained_pokemon_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HeldItemsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedto_trained_pokemon_item != nil {
		edges = append(edges, helditems.EdgeToTrainedPokemonItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HeldItemsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case helditems.EdgeToTrainedPokemonItem:
		ids := make([]ent.Value, 0, len(m.removedto_trained_pokemon_item))
		for id := range m.removedto_trained_pokemon_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HeldItemsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedto_trained_pokemon_item {
		edges = append(edges, helditems.EdgeToTrainedPokemonItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HeldItemsMutation) EdgeCleared(name string) bool {
	switch name {
	case helditems.EdgeToTrainedPokemonItem:
		return m.clearedto_trained_pokemon_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HeldItemsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HeldItems unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HeldItemsMutation) ResetEdge(name string) error {
	switch name {
	case helditems.EdgeToTrainedPokemonItem:
		m.ResetToTrainedPokemonItem()
		return nil
	}
	return fmt.Errorf("unknown HeldItems edge %s", name)
}

// MovesMutation represents an operation that mutates the Moves nodes in the graph.
type MovesMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	name                            *string
	_type                           *property.Types
	species                         *property.MoveSpecies
	power                           *int
	addpower                        *int
	accuracy                        *int
	addaccuracy                     *int
	pp                              *int
	addpp                           *int
	is_contact                      *bool
	is_can_guard                    *bool
	clearedFields                   map[string]struct{}
	to_trained_pokemon_move1        map[int]struct{}
	removedto_trained_pokemon_move1 map[int]struct{}
	clearedto_trained_pokemon_move1 bool
	to_trained_pokemon_move2        map[int]struct{}
	removedto_trained_pokemon_move2 map[int]struct{}
	clearedto_trained_pokemon_move2 bool
	to_trained_pokemon_move3        map[int]struct{}
	removedto_trained_pokemon_move3 map[int]struct{}
	clearedto_trained_pokemon_move3 bool
	to_trained_pokemon_move4        map[int]struct{}
	removedto_trained_pokemon_move4 map[int]struct{}
	clearedto_trained_pokemon_move4 bool
	move_to_pokemon                 map[int]struct{}
	removedmove_to_pokemon          map[int]struct{}
	clearedmove_to_pokemon          bool
	done                            bool
	oldValue                        func(context.Context) (*Moves, error)
	predicates                      []predicate.Moves
}

var _ ent.Mutation = (*MovesMutation)(nil)

// movesOption allows management of the mutation configuration using functional options.
type movesOption func(*MovesMutation)

// newMovesMutation creates new mutation for the Moves entity.
func newMovesMutation(c config, op Op, opts ...movesOption) *MovesMutation {
	m := &MovesMutation{
		config:        c,
		op:            op,
		typ:           TypeMoves,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMovesID sets the ID field of the mutation.
func withMovesID(id int) movesOption {
	return func(m *MovesMutation) {
		var (
			err   error
			once  sync.Once
			value *Moves
		)
		m.oldValue = func(ctx context.Context) (*Moves, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Moves.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMoves sets the old Moves of the mutation.
func withMoves(node *Moves) movesOption {
	return func(m *MovesMutation) {
		m.oldValue = func(context.Context) (*Moves, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MovesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MovesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MovesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *MovesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MovesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MovesMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *MovesMutation) SetType(pr property.Types) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *MovesMutation) GetType() (r property.Types, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldType(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MovesMutation) ResetType() {
	m._type = nil
}

// SetSpecies sets the "species" field.
func (m *MovesMutation) SetSpecies(ps property.MoveSpecies) {
	m.species = &ps
}

// Species returns the value of the "species" field in the mutation.
func (m *MovesMutation) Species() (r property.MoveSpecies, exists bool) {
	v := m.species
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecies returns the old "species" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldSpecies(ctx context.Context) (v property.MoveSpecies, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecies: %w", err)
	}
	return oldValue.Species, nil
}

// ResetSpecies resets all changes to the "species" field.
func (m *MovesMutation) ResetSpecies() {
	m.species = nil
}

// SetPower sets the "power" field.
func (m *MovesMutation) SetPower(i int) {
	m.power = &i
	m.addpower = nil
}

// Power returns the value of the "power" field in the mutation.
func (m *MovesMutation) Power() (r int, exists bool) {
	v := m.power
	if v == nil {
		return
	}
	return *v, true
}

// OldPower returns the old "power" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldPower(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPower: %w", err)
	}
	return oldValue.Power, nil
}

// AddPower adds i to the "power" field.
func (m *MovesMutation) AddPower(i int) {
	if m.addpower != nil {
		*m.addpower += i
	} else {
		m.addpower = &i
	}
}

// AddedPower returns the value that was added to the "power" field in this mutation.
func (m *MovesMutation) AddedPower() (r int, exists bool) {
	v := m.addpower
	if v == nil {
		return
	}
	return *v, true
}

// ResetPower resets all changes to the "power" field.
func (m *MovesMutation) ResetPower() {
	m.power = nil
	m.addpower = nil
}

// SetAccuracy sets the "accuracy" field.
func (m *MovesMutation) SetAccuracy(i int) {
	m.accuracy = &i
	m.addaccuracy = nil
}

// Accuracy returns the value of the "accuracy" field in the mutation.
func (m *MovesMutation) Accuracy() (r int, exists bool) {
	v := m.accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldAccuracy returns the old "accuracy" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldAccuracy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccuracy: %w", err)
	}
	return oldValue.Accuracy, nil
}

// AddAccuracy adds i to the "accuracy" field.
func (m *MovesMutation) AddAccuracy(i int) {
	if m.addaccuracy != nil {
		*m.addaccuracy += i
	} else {
		m.addaccuracy = &i
	}
}

// AddedAccuracy returns the value that was added to the "accuracy" field in this mutation.
func (m *MovesMutation) AddedAccuracy() (r int, exists bool) {
	v := m.addaccuracy
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccuracy resets all changes to the "accuracy" field.
func (m *MovesMutation) ResetAccuracy() {
	m.accuracy = nil
	m.addaccuracy = nil
}

// SetPp sets the "pp" field.
func (m *MovesMutation) SetPp(i int) {
	m.pp = &i
	m.addpp = nil
}

// Pp returns the value of the "pp" field in the mutation.
func (m *MovesMutation) Pp() (r int, exists bool) {
	v := m.pp
	if v == nil {
		return
	}
	return *v, true
}

// OldPp returns the old "pp" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldPp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPp: %w", err)
	}
	return oldValue.Pp, nil
}

// AddPp adds i to the "pp" field.
func (m *MovesMutation) AddPp(i int) {
	if m.addpp != nil {
		*m.addpp += i
	} else {
		m.addpp = &i
	}
}

// AddedPp returns the value that was added to the "pp" field in this mutation.
func (m *MovesMutation) AddedPp() (r int, exists bool) {
	v := m.addpp
	if v == nil {
		return
	}
	return *v, true
}

// ResetPp resets all changes to the "pp" field.
func (m *MovesMutation) ResetPp() {
	m.pp = nil
	m.addpp = nil
}

// SetIsContact sets the "is_contact" field.
func (m *MovesMutation) SetIsContact(b bool) {
	m.is_contact = &b
}

// IsContact returns the value of the "is_contact" field in the mutation.
func (m *MovesMutation) IsContact() (r bool, exists bool) {
	v := m.is_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldIsContact returns the old "is_contact" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldIsContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsContact: %w", err)
	}
	return oldValue.IsContact, nil
}

// ResetIsContact resets all changes to the "is_contact" field.
func (m *MovesMutation) ResetIsContact() {
	m.is_contact = nil
}

// SetIsCanGuard sets the "is_can_guard" field.
func (m *MovesMutation) SetIsCanGuard(b bool) {
	m.is_can_guard = &b
}

// IsCanGuard returns the value of the "is_can_guard" field in the mutation.
func (m *MovesMutation) IsCanGuard() (r bool, exists bool) {
	v := m.is_can_guard
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCanGuard returns the old "is_can_guard" field's value of the Moves entity.
// If the Moves object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovesMutation) OldIsCanGuard(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsCanGuard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsCanGuard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCanGuard: %w", err)
	}
	return oldValue.IsCanGuard, nil
}

// ResetIsCanGuard resets all changes to the "is_can_guard" field.
func (m *MovesMutation) ResetIsCanGuard() {
	m.is_can_guard = nil
}

// AddToTrainedPokemonMove1IDs adds the "to_trained_pokemon_move1" edge to the TrainedPokemonDetails entity by ids.
func (m *MovesMutation) AddToTrainedPokemonMove1IDs(ids ...int) {
	if m.to_trained_pokemon_move1 == nil {
		m.to_trained_pokemon_move1 = make(map[int]struct{})
	}
	for i := range ids {
		m.to_trained_pokemon_move1[ids[i]] = struct{}{}
	}
}

// ClearToTrainedPokemonMove1 clears the "to_trained_pokemon_move1" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) ClearToTrainedPokemonMove1() {
	m.clearedto_trained_pokemon_move1 = true
}

// ToTrainedPokemonMove1Cleared reports if the "to_trained_pokemon_move1" edge to the TrainedPokemonDetails entity was cleared.
func (m *MovesMutation) ToTrainedPokemonMove1Cleared() bool {
	return m.clearedto_trained_pokemon_move1
}

// RemoveToTrainedPokemonMove1IDs removes the "to_trained_pokemon_move1" edge to the TrainedPokemonDetails entity by IDs.
func (m *MovesMutation) RemoveToTrainedPokemonMove1IDs(ids ...int) {
	if m.removedto_trained_pokemon_move1 == nil {
		m.removedto_trained_pokemon_move1 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_trained_pokemon_move1, ids[i])
		m.removedto_trained_pokemon_move1[ids[i]] = struct{}{}
	}
}

// RemovedToTrainedPokemonMove1 returns the removed IDs of the "to_trained_pokemon_move1" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) RemovedToTrainedPokemonMove1IDs() (ids []int) {
	for id := range m.removedto_trained_pokemon_move1 {
		ids = append(ids, id)
	}
	return
}

// ToTrainedPokemonMove1IDs returns the "to_trained_pokemon_move1" edge IDs in the mutation.
func (m *MovesMutation) ToTrainedPokemonMove1IDs() (ids []int) {
	for id := range m.to_trained_pokemon_move1 {
		ids = append(ids, id)
	}
	return
}

// ResetToTrainedPokemonMove1 resets all changes to the "to_trained_pokemon_move1" edge.
func (m *MovesMutation) ResetToTrainedPokemonMove1() {
	m.to_trained_pokemon_move1 = nil
	m.clearedto_trained_pokemon_move1 = false
	m.removedto_trained_pokemon_move1 = nil
}

// AddToTrainedPokemonMove2IDs adds the "to_trained_pokemon_move2" edge to the TrainedPokemonDetails entity by ids.
func (m *MovesMutation) AddToTrainedPokemonMove2IDs(ids ...int) {
	if m.to_trained_pokemon_move2 == nil {
		m.to_trained_pokemon_move2 = make(map[int]struct{})
	}
	for i := range ids {
		m.to_trained_pokemon_move2[ids[i]] = struct{}{}
	}
}

// ClearToTrainedPokemonMove2 clears the "to_trained_pokemon_move2" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) ClearToTrainedPokemonMove2() {
	m.clearedto_trained_pokemon_move2 = true
}

// ToTrainedPokemonMove2Cleared reports if the "to_trained_pokemon_move2" edge to the TrainedPokemonDetails entity was cleared.
func (m *MovesMutation) ToTrainedPokemonMove2Cleared() bool {
	return m.clearedto_trained_pokemon_move2
}

// RemoveToTrainedPokemonMove2IDs removes the "to_trained_pokemon_move2" edge to the TrainedPokemonDetails entity by IDs.
func (m *MovesMutation) RemoveToTrainedPokemonMove2IDs(ids ...int) {
	if m.removedto_trained_pokemon_move2 == nil {
		m.removedto_trained_pokemon_move2 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_trained_pokemon_move2, ids[i])
		m.removedto_trained_pokemon_move2[ids[i]] = struct{}{}
	}
}

// RemovedToTrainedPokemonMove2 returns the removed IDs of the "to_trained_pokemon_move2" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) RemovedToTrainedPokemonMove2IDs() (ids []int) {
	for id := range m.removedto_trained_pokemon_move2 {
		ids = append(ids, id)
	}
	return
}

// ToTrainedPokemonMove2IDs returns the "to_trained_pokemon_move2" edge IDs in the mutation.
func (m *MovesMutation) ToTrainedPokemonMove2IDs() (ids []int) {
	for id := range m.to_trained_pokemon_move2 {
		ids = append(ids, id)
	}
	return
}

// ResetToTrainedPokemonMove2 resets all changes to the "to_trained_pokemon_move2" edge.
func (m *MovesMutation) ResetToTrainedPokemonMove2() {
	m.to_trained_pokemon_move2 = nil
	m.clearedto_trained_pokemon_move2 = false
	m.removedto_trained_pokemon_move2 = nil
}

// AddToTrainedPokemonMove3IDs adds the "to_trained_pokemon_move3" edge to the TrainedPokemonDetails entity by ids.
func (m *MovesMutation) AddToTrainedPokemonMove3IDs(ids ...int) {
	if m.to_trained_pokemon_move3 == nil {
		m.to_trained_pokemon_move3 = make(map[int]struct{})
	}
	for i := range ids {
		m.to_trained_pokemon_move3[ids[i]] = struct{}{}
	}
}

// ClearToTrainedPokemonMove3 clears the "to_trained_pokemon_move3" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) ClearToTrainedPokemonMove3() {
	m.clearedto_trained_pokemon_move3 = true
}

// ToTrainedPokemonMove3Cleared reports if the "to_trained_pokemon_move3" edge to the TrainedPokemonDetails entity was cleared.
func (m *MovesMutation) ToTrainedPokemonMove3Cleared() bool {
	return m.clearedto_trained_pokemon_move3
}

// RemoveToTrainedPokemonMove3IDs removes the "to_trained_pokemon_move3" edge to the TrainedPokemonDetails entity by IDs.
func (m *MovesMutation) RemoveToTrainedPokemonMove3IDs(ids ...int) {
	if m.removedto_trained_pokemon_move3 == nil {
		m.removedto_trained_pokemon_move3 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_trained_pokemon_move3, ids[i])
		m.removedto_trained_pokemon_move3[ids[i]] = struct{}{}
	}
}

// RemovedToTrainedPokemonMove3 returns the removed IDs of the "to_trained_pokemon_move3" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) RemovedToTrainedPokemonMove3IDs() (ids []int) {
	for id := range m.removedto_trained_pokemon_move3 {
		ids = append(ids, id)
	}
	return
}

// ToTrainedPokemonMove3IDs returns the "to_trained_pokemon_move3" edge IDs in the mutation.
func (m *MovesMutation) ToTrainedPokemonMove3IDs() (ids []int) {
	for id := range m.to_trained_pokemon_move3 {
		ids = append(ids, id)
	}
	return
}

// ResetToTrainedPokemonMove3 resets all changes to the "to_trained_pokemon_move3" edge.
func (m *MovesMutation) ResetToTrainedPokemonMove3() {
	m.to_trained_pokemon_move3 = nil
	m.clearedto_trained_pokemon_move3 = false
	m.removedto_trained_pokemon_move3 = nil
}

// AddToTrainedPokemonMove4IDs adds the "to_trained_pokemon_move4" edge to the TrainedPokemonDetails entity by ids.
func (m *MovesMutation) AddToTrainedPokemonMove4IDs(ids ...int) {
	if m.to_trained_pokemon_move4 == nil {
		m.to_trained_pokemon_move4 = make(map[int]struct{})
	}
	for i := range ids {
		m.to_trained_pokemon_move4[ids[i]] = struct{}{}
	}
}

// ClearToTrainedPokemonMove4 clears the "to_trained_pokemon_move4" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) ClearToTrainedPokemonMove4() {
	m.clearedto_trained_pokemon_move4 = true
}

// ToTrainedPokemonMove4Cleared reports if the "to_trained_pokemon_move4" edge to the TrainedPokemonDetails entity was cleared.
func (m *MovesMutation) ToTrainedPokemonMove4Cleared() bool {
	return m.clearedto_trained_pokemon_move4
}

// RemoveToTrainedPokemonMove4IDs removes the "to_trained_pokemon_move4" edge to the TrainedPokemonDetails entity by IDs.
func (m *MovesMutation) RemoveToTrainedPokemonMove4IDs(ids ...int) {
	if m.removedto_trained_pokemon_move4 == nil {
		m.removedto_trained_pokemon_move4 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_trained_pokemon_move4, ids[i])
		m.removedto_trained_pokemon_move4[ids[i]] = struct{}{}
	}
}

// RemovedToTrainedPokemonMove4 returns the removed IDs of the "to_trained_pokemon_move4" edge to the TrainedPokemonDetails entity.
func (m *MovesMutation) RemovedToTrainedPokemonMove4IDs() (ids []int) {
	for id := range m.removedto_trained_pokemon_move4 {
		ids = append(ids, id)
	}
	return
}

// ToTrainedPokemonMove4IDs returns the "to_trained_pokemon_move4" edge IDs in the mutation.
func (m *MovesMutation) ToTrainedPokemonMove4IDs() (ids []int) {
	for id := range m.to_trained_pokemon_move4 {
		ids = append(ids, id)
	}
	return
}

// ResetToTrainedPokemonMove4 resets all changes to the "to_trained_pokemon_move4" edge.
func (m *MovesMutation) ResetToTrainedPokemonMove4() {
	m.to_trained_pokemon_move4 = nil
	m.clearedto_trained_pokemon_move4 = false
	m.removedto_trained_pokemon_move4 = nil
}

// AddMoveToPokemonIDs adds the "move_to_pokemon" edge to the Pokemons entity by ids.
func (m *MovesMutation) AddMoveToPokemonIDs(ids ...int) {
	if m.move_to_pokemon == nil {
		m.move_to_pokemon = make(map[int]struct{})
	}
	for i := range ids {
		m.move_to_pokemon[ids[i]] = struct{}{}
	}
}

// ClearMoveToPokemon clears the "move_to_pokemon" edge to the Pokemons entity.
func (m *MovesMutation) ClearMoveToPokemon() {
	m.clearedmove_to_pokemon = true
}

// MoveToPokemonCleared reports if the "move_to_pokemon" edge to the Pokemons entity was cleared.
func (m *MovesMutation) MoveToPokemonCleared() bool {
	return m.clearedmove_to_pokemon
}

// RemoveMoveToPokemonIDs removes the "move_to_pokemon" edge to the Pokemons entity by IDs.
func (m *MovesMutation) RemoveMoveToPokemonIDs(ids ...int) {
	if m.removedmove_to_pokemon == nil {
		m.removedmove_to_pokemon = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.move_to_pokemon, ids[i])
		m.removedmove_to_pokemon[ids[i]] = struct{}{}
	}
}

// RemovedMoveToPokemon returns the removed IDs of the "move_to_pokemon" edge to the Pokemons entity.
func (m *MovesMutation) RemovedMoveToPokemonIDs() (ids []int) {
	for id := range m.removedmove_to_pokemon {
		ids = append(ids, id)
	}
	return
}

// MoveToPokemonIDs returns the "move_to_pokemon" edge IDs in the mutation.
func (m *MovesMutation) MoveToPokemonIDs() (ids []int) {
	for id := range m.move_to_pokemon {
		ids = append(ids, id)
	}
	return
}

// ResetMoveToPokemon resets all changes to the "move_to_pokemon" edge.
func (m *MovesMutation) ResetMoveToPokemon() {
	m.move_to_pokemon = nil
	m.clearedmove_to_pokemon = false
	m.removedmove_to_pokemon = nil
}

// Where appends a list predicates to the MovesMutation builder.
func (m *MovesMutation) Where(ps ...predicate.Moves) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MovesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Moves).
func (m *MovesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MovesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, moves.FieldName)
	}
	if m._type != nil {
		fields = append(fields, moves.FieldType)
	}
	if m.species != nil {
		fields = append(fields, moves.FieldSpecies)
	}
	if m.power != nil {
		fields = append(fields, moves.FieldPower)
	}
	if m.accuracy != nil {
		fields = append(fields, moves.FieldAccuracy)
	}
	if m.pp != nil {
		fields = append(fields, moves.FieldPp)
	}
	if m.is_contact != nil {
		fields = append(fields, moves.FieldIsContact)
	}
	if m.is_can_guard != nil {
		fields = append(fields, moves.FieldIsCanGuard)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MovesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moves.FieldName:
		return m.Name()
	case moves.FieldType:
		return m.GetType()
	case moves.FieldSpecies:
		return m.Species()
	case moves.FieldPower:
		return m.Power()
	case moves.FieldAccuracy:
		return m.Accuracy()
	case moves.FieldPp:
		return m.Pp()
	case moves.FieldIsContact:
		return m.IsContact()
	case moves.FieldIsCanGuard:
		return m.IsCanGuard()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MovesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case moves.FieldName:
		return m.OldName(ctx)
	case moves.FieldType:
		return m.OldType(ctx)
	case moves.FieldSpecies:
		return m.OldSpecies(ctx)
	case moves.FieldPower:
		return m.OldPower(ctx)
	case moves.FieldAccuracy:
		return m.OldAccuracy(ctx)
	case moves.FieldPp:
		return m.OldPp(ctx)
	case moves.FieldIsContact:
		return m.OldIsContact(ctx)
	case moves.FieldIsCanGuard:
		return m.OldIsCanGuard(ctx)
	}
	return nil, fmt.Errorf("unknown Moves field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moves.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case moves.FieldType:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case moves.FieldSpecies:
		v, ok := value.(property.MoveSpecies)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecies(v)
		return nil
	case moves.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPower(v)
		return nil
	case moves.FieldAccuracy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccuracy(v)
		return nil
	case moves.FieldPp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPp(v)
		return nil
	case moves.FieldIsContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsContact(v)
		return nil
	case moves.FieldIsCanGuard:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCanGuard(v)
		return nil
	}
	return fmt.Errorf("unknown Moves field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MovesMutation) AddedFields() []string {
	var fields []string
	if m.addpower != nil {
		fields = append(fields, moves.FieldPower)
	}
	if m.addaccuracy != nil {
		fields = append(fields, moves.FieldAccuracy)
	}
	if m.addpp != nil {
		fields = append(fields, moves.FieldPp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MovesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case moves.FieldPower:
		return m.AddedPower()
	case moves.FieldAccuracy:
		return m.AddedAccuracy()
	case moves.FieldPp:
		return m.AddedPp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case moves.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPower(v)
		return nil
	case moves.FieldAccuracy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccuracy(v)
		return nil
	case moves.FieldPp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPp(v)
		return nil
	}
	return fmt.Errorf("unknown Moves numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MovesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MovesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MovesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Moves nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MovesMutation) ResetField(name string) error {
	switch name {
	case moves.FieldName:
		m.ResetName()
		return nil
	case moves.FieldType:
		m.ResetType()
		return nil
	case moves.FieldSpecies:
		m.ResetSpecies()
		return nil
	case moves.FieldPower:
		m.ResetPower()
		return nil
	case moves.FieldAccuracy:
		m.ResetAccuracy()
		return nil
	case moves.FieldPp:
		m.ResetPp()
		return nil
	case moves.FieldIsContact:
		m.ResetIsContact()
		return nil
	case moves.FieldIsCanGuard:
		m.ResetIsCanGuard()
		return nil
	}
	return fmt.Errorf("unknown Moves field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MovesMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.to_trained_pokemon_move1 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove1)
	}
	if m.to_trained_pokemon_move2 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove2)
	}
	if m.to_trained_pokemon_move3 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove3)
	}
	if m.to_trained_pokemon_move4 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove4)
	}
	if m.move_to_pokemon != nil {
		edges = append(edges, moves.EdgeMoveToPokemon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MovesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moves.EdgeToTrainedPokemonMove1:
		ids := make([]ent.Value, 0, len(m.to_trained_pokemon_move1))
		for id := range m.to_trained_pokemon_move1 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeToTrainedPokemonMove2:
		ids := make([]ent.Value, 0, len(m.to_trained_pokemon_move2))
		for id := range m.to_trained_pokemon_move2 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeToTrainedPokemonMove3:
		ids := make([]ent.Value, 0, len(m.to_trained_pokemon_move3))
		for id := range m.to_trained_pokemon_move3 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeToTrainedPokemonMove4:
		ids := make([]ent.Value, 0, len(m.to_trained_pokemon_move4))
		for id := range m.to_trained_pokemon_move4 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeMoveToPokemon:
		ids := make([]ent.Value, 0, len(m.move_to_pokemon))
		for id := range m.move_to_pokemon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MovesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedto_trained_pokemon_move1 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove1)
	}
	if m.removedto_trained_pokemon_move2 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove2)
	}
	if m.removedto_trained_pokemon_move3 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove3)
	}
	if m.removedto_trained_pokemon_move4 != nil {
		edges = append(edges, moves.EdgeToTrainedPokemonMove4)
	}
	if m.removedmove_to_pokemon != nil {
		edges = append(edges, moves.EdgeMoveToPokemon)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MovesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case moves.EdgeToTrainedPokemonMove1:
		ids := make([]ent.Value, 0, len(m.removedto_trained_pokemon_move1))
		for id := range m.removedto_trained_pokemon_move1 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeToTrainedPokemonMove2:
		ids := make([]ent.Value, 0, len(m.removedto_trained_pokemon_move2))
		for id := range m.removedto_trained_pokemon_move2 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeToTrainedPokemonMove3:
		ids := make([]ent.Value, 0, len(m.removedto_trained_pokemon_move3))
		for id := range m.removedto_trained_pokemon_move3 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeToTrainedPokemonMove4:
		ids := make([]ent.Value, 0, len(m.removedto_trained_pokemon_move4))
		for id := range m.removedto_trained_pokemon_move4 {
			ids = append(ids, id)
		}
		return ids
	case moves.EdgeMoveToPokemon:
		ids := make([]ent.Value, 0, len(m.removedmove_to_pokemon))
		for id := range m.removedmove_to_pokemon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MovesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedto_trained_pokemon_move1 {
		edges = append(edges, moves.EdgeToTrainedPokemonMove1)
	}
	if m.clearedto_trained_pokemon_move2 {
		edges = append(edges, moves.EdgeToTrainedPokemonMove2)
	}
	if m.clearedto_trained_pokemon_move3 {
		edges = append(edges, moves.EdgeToTrainedPokemonMove3)
	}
	if m.clearedto_trained_pokemon_move4 {
		edges = append(edges, moves.EdgeToTrainedPokemonMove4)
	}
	if m.clearedmove_to_pokemon {
		edges = append(edges, moves.EdgeMoveToPokemon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MovesMutation) EdgeCleared(name string) bool {
	switch name {
	case moves.EdgeToTrainedPokemonMove1:
		return m.clearedto_trained_pokemon_move1
	case moves.EdgeToTrainedPokemonMove2:
		return m.clearedto_trained_pokemon_move2
	case moves.EdgeToTrainedPokemonMove3:
		return m.clearedto_trained_pokemon_move3
	case moves.EdgeToTrainedPokemonMove4:
		return m.clearedto_trained_pokemon_move4
	case moves.EdgeMoveToPokemon:
		return m.clearedmove_to_pokemon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MovesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Moves unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MovesMutation) ResetEdge(name string) error {
	switch name {
	case moves.EdgeToTrainedPokemonMove1:
		m.ResetToTrainedPokemonMove1()
		return nil
	case moves.EdgeToTrainedPokemonMove2:
		m.ResetToTrainedPokemonMove2()
		return nil
	case moves.EdgeToTrainedPokemonMove3:
		m.ResetToTrainedPokemonMove3()
		return nil
	case moves.EdgeToTrainedPokemonMove4:
		m.ResetToTrainedPokemonMove4()
		return nil
	case moves.EdgeMoveToPokemon:
		m.ResetMoveToPokemon()
		return nil
	}
	return fmt.Errorf("unknown Moves edge %s", name)
}

// PartyMutation represents an operation that mutates the Party nodes in the graph.
type PartyMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	user_id                    *int
	adduser_id                 *int
	name                       *string
	battle_format              *property.BattleFormats
	clearedFields              map[string]struct{}
	party_battle_record        map[int]struct{}
	removedparty_battle_record map[int]struct{}
	clearedparty_battle_record bool
	party_to_tag               map[int]struct{}
	removedparty_to_tag        map[int]struct{}
	clearedparty_to_tag        bool
	result_record              map[int]struct{}
	removedresult_record       map[int]struct{}
	clearedresult_record       bool
	done                       bool
	oldValue                   func(context.Context) (*Party, error)
	predicates                 []predicate.Party
}

var _ ent.Mutation = (*PartyMutation)(nil)

// partyOption allows management of the mutation configuration using functional options.
type partyOption func(*PartyMutation)

// newPartyMutation creates new mutation for the Party entity.
func newPartyMutation(c config, op Op, opts ...partyOption) *PartyMutation {
	m := &PartyMutation{
		config:        c,
		op:            op,
		typ:           TypeParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartyID sets the ID field of the mutation.
func withPartyID(id int) partyOption {
	return func(m *PartyMutation) {
		var (
			err   error
			once  sync.Once
			value *Party
		)
		m.oldValue = func(ctx context.Context) (*Party, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Party.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParty sets the old Party of the mutation.
func withParty(node *Party) partyOption {
	return func(m *PartyMutation) {
		m.oldValue = func(context.Context) (*Party, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the "user_id" field.
func (m *PartyMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PartyMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *PartyMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *PartyMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PartyMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetName sets the "name" field.
func (m *PartyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PartyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PartyMutation) ClearName() {
	m.name = nil
	m.clearedFields[party.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PartyMutation) NameCleared() bool {
	_, ok := m.clearedFields[party.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PartyMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, party.FieldName)
}

// SetBattleFormat sets the "battle_format" field.
func (m *PartyMutation) SetBattleFormat(pf property.BattleFormats) {
	m.battle_format = &pf
}

// BattleFormat returns the value of the "battle_format" field in the mutation.
func (m *PartyMutation) BattleFormat() (r property.BattleFormats, exists bool) {
	v := m.battle_format
	if v == nil {
		return
	}
	return *v, true
}

// OldBattleFormat returns the old "battle_format" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldBattleFormat(ctx context.Context) (v property.BattleFormats, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBattleFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBattleFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBattleFormat: %w", err)
	}
	return oldValue.BattleFormat, nil
}

// ClearBattleFormat clears the value of the "battle_format" field.
func (m *PartyMutation) ClearBattleFormat() {
	m.battle_format = nil
	m.clearedFields[party.FieldBattleFormat] = struct{}{}
}

// BattleFormatCleared returns if the "battle_format" field was cleared in this mutation.
func (m *PartyMutation) BattleFormatCleared() bool {
	_, ok := m.clearedFields[party.FieldBattleFormat]
	return ok
}

// ResetBattleFormat resets all changes to the "battle_format" field.
func (m *PartyMutation) ResetBattleFormat() {
	m.battle_format = nil
	delete(m.clearedFields, party.FieldBattleFormat)
}

// AddPartyBattleRecordIDs adds the "party_battle_record" edge to the BattleRecords entity by ids.
func (m *PartyMutation) AddPartyBattleRecordIDs(ids ...int) {
	if m.party_battle_record == nil {
		m.party_battle_record = make(map[int]struct{})
	}
	for i := range ids {
		m.party_battle_record[ids[i]] = struct{}{}
	}
}

// ClearPartyBattleRecord clears the "party_battle_record" edge to the BattleRecords entity.
func (m *PartyMutation) ClearPartyBattleRecord() {
	m.clearedparty_battle_record = true
}

// PartyBattleRecordCleared reports if the "party_battle_record" edge to the BattleRecords entity was cleared.
func (m *PartyMutation) PartyBattleRecordCleared() bool {
	return m.clearedparty_battle_record
}

// RemovePartyBattleRecordIDs removes the "party_battle_record" edge to the BattleRecords entity by IDs.
func (m *PartyMutation) RemovePartyBattleRecordIDs(ids ...int) {
	if m.removedparty_battle_record == nil {
		m.removedparty_battle_record = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.party_battle_record, ids[i])
		m.removedparty_battle_record[ids[i]] = struct{}{}
	}
}

// RemovedPartyBattleRecord returns the removed IDs of the "party_battle_record" edge to the BattleRecords entity.
func (m *PartyMutation) RemovedPartyBattleRecordIDs() (ids []int) {
	for id := range m.removedparty_battle_record {
		ids = append(ids, id)
	}
	return
}

// PartyBattleRecordIDs returns the "party_battle_record" edge IDs in the mutation.
func (m *PartyMutation) PartyBattleRecordIDs() (ids []int) {
	for id := range m.party_battle_record {
		ids = append(ids, id)
	}
	return
}

// ResetPartyBattleRecord resets all changes to the "party_battle_record" edge.
func (m *PartyMutation) ResetPartyBattleRecord() {
	m.party_battle_record = nil
	m.clearedparty_battle_record = false
	m.removedparty_battle_record = nil
}

// AddPartyToTagIDs adds the "party_to_tag" edge to the Tags entity by ids.
func (m *PartyMutation) AddPartyToTagIDs(ids ...int) {
	if m.party_to_tag == nil {
		m.party_to_tag = make(map[int]struct{})
	}
	for i := range ids {
		m.party_to_tag[ids[i]] = struct{}{}
	}
}

// ClearPartyToTag clears the "party_to_tag" edge to the Tags entity.
func (m *PartyMutation) ClearPartyToTag() {
	m.clearedparty_to_tag = true
}

// PartyToTagCleared reports if the "party_to_tag" edge to the Tags entity was cleared.
func (m *PartyMutation) PartyToTagCleared() bool {
	return m.clearedparty_to_tag
}

// RemovePartyToTagIDs removes the "party_to_tag" edge to the Tags entity by IDs.
func (m *PartyMutation) RemovePartyToTagIDs(ids ...int) {
	if m.removedparty_to_tag == nil {
		m.removedparty_to_tag = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.party_to_tag, ids[i])
		m.removedparty_to_tag[ids[i]] = struct{}{}
	}
}

// RemovedPartyToTag returns the removed IDs of the "party_to_tag" edge to the Tags entity.
func (m *PartyMutation) RemovedPartyToTagIDs() (ids []int) {
	for id := range m.removedparty_to_tag {
		ids = append(ids, id)
	}
	return
}

// PartyToTagIDs returns the "party_to_tag" edge IDs in the mutation.
func (m *PartyMutation) PartyToTagIDs() (ids []int) {
	for id := range m.party_to_tag {
		ids = append(ids, id)
	}
	return
}

// ResetPartyToTag resets all changes to the "party_to_tag" edge.
func (m *PartyMutation) ResetPartyToTag() {
	m.party_to_tag = nil
	m.clearedparty_to_tag = false
	m.removedparty_to_tag = nil
}

// AddResultRecordIDs adds the "result_record" edge to the PartyResultRecord entity by ids.
func (m *PartyMutation) AddResultRecordIDs(ids ...int) {
	if m.result_record == nil {
		m.result_record = make(map[int]struct{})
	}
	for i := range ids {
		m.result_record[ids[i]] = struct{}{}
	}
}

// ClearResultRecord clears the "result_record" edge to the PartyResultRecord entity.
func (m *PartyMutation) ClearResultRecord() {
	m.clearedresult_record = true
}

// ResultRecordCleared reports if the "result_record" edge to the PartyResultRecord entity was cleared.
func (m *PartyMutation) ResultRecordCleared() bool {
	return m.clearedresult_record
}

// RemoveResultRecordIDs removes the "result_record" edge to the PartyResultRecord entity by IDs.
func (m *PartyMutation) RemoveResultRecordIDs(ids ...int) {
	if m.removedresult_record == nil {
		m.removedresult_record = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.result_record, ids[i])
		m.removedresult_record[ids[i]] = struct{}{}
	}
}

// RemovedResultRecord returns the removed IDs of the "result_record" edge to the PartyResultRecord entity.
func (m *PartyMutation) RemovedResultRecordIDs() (ids []int) {
	for id := range m.removedresult_record {
		ids = append(ids, id)
	}
	return
}

// ResultRecordIDs returns the "result_record" edge IDs in the mutation.
func (m *PartyMutation) ResultRecordIDs() (ids []int) {
	for id := range m.result_record {
		ids = append(ids, id)
	}
	return
}

// ResetResultRecord resets all changes to the "result_record" edge.
func (m *PartyMutation) ResetResultRecord() {
	m.result_record = nil
	m.clearedresult_record = false
	m.removedresult_record = nil
}

// Where appends a list predicates to the PartyMutation builder.
func (m *PartyMutation) Where(ps ...predicate.Party) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PartyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Party).
func (m *PartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user_id != nil {
		fields = append(fields, party.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, party.FieldName)
	}
	if m.battle_format != nil {
		fields = append(fields, party.FieldBattleFormat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case party.FieldUserID:
		return m.UserID()
	case party.FieldName:
		return m.Name()
	case party.FieldBattleFormat:
		return m.BattleFormat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case party.FieldUserID:
		return m.OldUserID(ctx)
	case party.FieldName:
		return m.OldName(ctx)
	case party.FieldBattleFormat:
		return m.OldBattleFormat(ctx)
	}
	return nil, fmt.Errorf("unknown Party field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case party.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case party.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case party.FieldBattleFormat:
		v, ok := value.(property.BattleFormats)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBattleFormat(v)
		return nil
	}
	return fmt.Errorf("unknown Party field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartyMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, party.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case party.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case party.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Party numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(party.FieldName) {
		fields = append(fields, party.FieldName)
	}
	if m.FieldCleared(party.FieldBattleFormat) {
		fields = append(fields, party.FieldBattleFormat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartyMutation) ClearField(name string) error {
	switch name {
	case party.FieldName:
		m.ClearName()
		return nil
	case party.FieldBattleFormat:
		m.ClearBattleFormat()
		return nil
	}
	return fmt.Errorf("unknown Party nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartyMutation) ResetField(name string) error {
	switch name {
	case party.FieldUserID:
		m.ResetUserID()
		return nil
	case party.FieldName:
		m.ResetName()
		return nil
	case party.FieldBattleFormat:
		m.ResetBattleFormat()
		return nil
	}
	return fmt.Errorf("unknown Party field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.party_battle_record != nil {
		edges = append(edges, party.EdgePartyBattleRecord)
	}
	if m.party_to_tag != nil {
		edges = append(edges, party.EdgePartyToTag)
	}
	if m.result_record != nil {
		edges = append(edges, party.EdgeResultRecord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case party.EdgePartyBattleRecord:
		ids := make([]ent.Value, 0, len(m.party_battle_record))
		for id := range m.party_battle_record {
			ids = append(ids, id)
		}
		return ids
	case party.EdgePartyToTag:
		ids := make([]ent.Value, 0, len(m.party_to_tag))
		for id := range m.party_to_tag {
			ids = append(ids, id)
		}
		return ids
	case party.EdgeResultRecord:
		ids := make([]ent.Value, 0, len(m.result_record))
		for id := range m.result_record {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparty_battle_record != nil {
		edges = append(edges, party.EdgePartyBattleRecord)
	}
	if m.removedparty_to_tag != nil {
		edges = append(edges, party.EdgePartyToTag)
	}
	if m.removedresult_record != nil {
		edges = append(edges, party.EdgeResultRecord)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case party.EdgePartyBattleRecord:
		ids := make([]ent.Value, 0, len(m.removedparty_battle_record))
		for id := range m.removedparty_battle_record {
			ids = append(ids, id)
		}
		return ids
	case party.EdgePartyToTag:
		ids := make([]ent.Value, 0, len(m.removedparty_to_tag))
		for id := range m.removedparty_to_tag {
			ids = append(ids, id)
		}
		return ids
	case party.EdgeResultRecord:
		ids := make([]ent.Value, 0, len(m.removedresult_record))
		for id := range m.removedresult_record {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparty_battle_record {
		edges = append(edges, party.EdgePartyBattleRecord)
	}
	if m.clearedparty_to_tag {
		edges = append(edges, party.EdgePartyToTag)
	}
	if m.clearedresult_record {
		edges = append(edges, party.EdgeResultRecord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartyMutation) EdgeCleared(name string) bool {
	switch name {
	case party.EdgePartyBattleRecord:
		return m.clearedparty_battle_record
	case party.EdgePartyToTag:
		return m.clearedparty_to_tag
	case party.EdgeResultRecord:
		return m.clearedresult_record
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Party unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartyMutation) ResetEdge(name string) error {
	switch name {
	case party.EdgePartyBattleRecord:
		m.ResetPartyBattleRecord()
		return nil
	case party.EdgePartyToTag:
		m.ResetPartyToTag()
		return nil
	case party.EdgeResultRecord:
		m.ResetResultRecord()
		return nil
	}
	return fmt.Errorf("unknown Party edge %s", name)
}

// PartyResultRecordMutation represents an operation that mutates the PartyResultRecord nodes in the graph.
type PartyResultRecordMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	generation             *int
	addgeneration          *int
	seasen                 *int
	addseasen              *int
	max_rate               *int
	addmax_rate            *int
	max_ranking            *int
	addmax_ranking         *int
	clearedFields          map[string]struct{}
	result_to_party        *int
	clearedresult_to_party bool
	done                   bool
	oldValue               func(context.Context) (*PartyResultRecord, error)
	predicates             []predicate.PartyResultRecord
}

var _ ent.Mutation = (*PartyResultRecordMutation)(nil)

// partyresultrecordOption allows management of the mutation configuration using functional options.
type partyresultrecordOption func(*PartyResultRecordMutation)

// newPartyResultRecordMutation creates new mutation for the PartyResultRecord entity.
func newPartyResultRecordMutation(c config, op Op, opts ...partyresultrecordOption) *PartyResultRecordMutation {
	m := &PartyResultRecordMutation{
		config:        c,
		op:            op,
		typ:           TypePartyResultRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartyResultRecordID sets the ID field of the mutation.
func withPartyResultRecordID(id int) partyresultrecordOption {
	return func(m *PartyResultRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *PartyResultRecord
		)
		m.oldValue = func(ctx context.Context) (*PartyResultRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartyResultRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartyResultRecord sets the old PartyResultRecord of the mutation.
func withPartyResultRecord(node *PartyResultRecord) partyresultrecordOption {
	return func(m *PartyResultRecordMutation) {
		m.oldValue = func(context.Context) (*PartyResultRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartyResultRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartyResultRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartyResultRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPartyID sets the "party_id" field.
func (m *PartyResultRecordMutation) SetPartyID(i int) {
	m.result_to_party = &i
}

// PartyID returns the value of the "party_id" field in the mutation.
func (m *PartyResultRecordMutation) PartyID() (r int, exists bool) {
	v := m.result_to_party
	if v == nil {
		return
	}
	return *v, true
}

// OldPartyID returns the old "party_id" field's value of the PartyResultRecord entity.
// If the PartyResultRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyResultRecordMutation) OldPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartyID: %w", err)
	}
	return oldValue.PartyID, nil
}

// ResetPartyID resets all changes to the "party_id" field.
func (m *PartyResultRecordMutation) ResetPartyID() {
	m.result_to_party = nil
}

// SetGeneration sets the "generation" field.
func (m *PartyResultRecordMutation) SetGeneration(i int) {
	m.generation = &i
	m.addgeneration = nil
}

// Generation returns the value of the "generation" field in the mutation.
func (m *PartyResultRecordMutation) Generation() (r int, exists bool) {
	v := m.generation
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneration returns the old "generation" field's value of the PartyResultRecord entity.
// If the PartyResultRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyResultRecordMutation) OldGeneration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGeneration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGeneration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneration: %w", err)
	}
	return oldValue.Generation, nil
}

// AddGeneration adds i to the "generation" field.
func (m *PartyResultRecordMutation) AddGeneration(i int) {
	if m.addgeneration != nil {
		*m.addgeneration += i
	} else {
		m.addgeneration = &i
	}
}

// AddedGeneration returns the value that was added to the "generation" field in this mutation.
func (m *PartyResultRecordMutation) AddedGeneration() (r int, exists bool) {
	v := m.addgeneration
	if v == nil {
		return
	}
	return *v, true
}

// ResetGeneration resets all changes to the "generation" field.
func (m *PartyResultRecordMutation) ResetGeneration() {
	m.generation = nil
	m.addgeneration = nil
}

// SetSeasen sets the "seasen" field.
func (m *PartyResultRecordMutation) SetSeasen(i int) {
	m.seasen = &i
	m.addseasen = nil
}

// Seasen returns the value of the "seasen" field in the mutation.
func (m *PartyResultRecordMutation) Seasen() (r int, exists bool) {
	v := m.seasen
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasen returns the old "seasen" field's value of the PartyResultRecord entity.
// If the PartyResultRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyResultRecordMutation) OldSeasen(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeasen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeasen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasen: %w", err)
	}
	return oldValue.Seasen, nil
}

// AddSeasen adds i to the "seasen" field.
func (m *PartyResultRecordMutation) AddSeasen(i int) {
	if m.addseasen != nil {
		*m.addseasen += i
	} else {
		m.addseasen = &i
	}
}

// AddedSeasen returns the value that was added to the "seasen" field in this mutation.
func (m *PartyResultRecordMutation) AddedSeasen() (r int, exists bool) {
	v := m.addseasen
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeasen resets all changes to the "seasen" field.
func (m *PartyResultRecordMutation) ResetSeasen() {
	m.seasen = nil
	m.addseasen = nil
}

// SetMaxRate sets the "max_rate" field.
func (m *PartyResultRecordMutation) SetMaxRate(i int) {
	m.max_rate = &i
	m.addmax_rate = nil
}

// MaxRate returns the value of the "max_rate" field in the mutation.
func (m *PartyResultRecordMutation) MaxRate() (r int, exists bool) {
	v := m.max_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRate returns the old "max_rate" field's value of the PartyResultRecord entity.
// If the PartyResultRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyResultRecordMutation) OldMaxRate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRate: %w", err)
	}
	return oldValue.MaxRate, nil
}

// AddMaxRate adds i to the "max_rate" field.
func (m *PartyResultRecordMutation) AddMaxRate(i int) {
	if m.addmax_rate != nil {
		*m.addmax_rate += i
	} else {
		m.addmax_rate = &i
	}
}

// AddedMaxRate returns the value that was added to the "max_rate" field in this mutation.
func (m *PartyResultRecordMutation) AddedMaxRate() (r int, exists bool) {
	v := m.addmax_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxRate clears the value of the "max_rate" field.
func (m *PartyResultRecordMutation) ClearMaxRate() {
	m.max_rate = nil
	m.addmax_rate = nil
	m.clearedFields[partyresultrecord.FieldMaxRate] = struct{}{}
}

// MaxRateCleared returns if the "max_rate" field was cleared in this mutation.
func (m *PartyResultRecordMutation) MaxRateCleared() bool {
	_, ok := m.clearedFields[partyresultrecord.FieldMaxRate]
	return ok
}

// ResetMaxRate resets all changes to the "max_rate" field.
func (m *PartyResultRecordMutation) ResetMaxRate() {
	m.max_rate = nil
	m.addmax_rate = nil
	delete(m.clearedFields, partyresultrecord.FieldMaxRate)
}

// SetMaxRanking sets the "max_ranking" field.
func (m *PartyResultRecordMutation) SetMaxRanking(i int) {
	m.max_ranking = &i
	m.addmax_ranking = nil
}

// MaxRanking returns the value of the "max_ranking" field in the mutation.
func (m *PartyResultRecordMutation) MaxRanking() (r int, exists bool) {
	v := m.max_ranking
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRanking returns the old "max_ranking" field's value of the PartyResultRecord entity.
// If the PartyResultRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyResultRecordMutation) OldMaxRanking(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxRanking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxRanking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRanking: %w", err)
	}
	return oldValue.MaxRanking, nil
}

// AddMaxRanking adds i to the "max_ranking" field.
func (m *PartyResultRecordMutation) AddMaxRanking(i int) {
	if m.addmax_ranking != nil {
		*m.addmax_ranking += i
	} else {
		m.addmax_ranking = &i
	}
}

// AddedMaxRanking returns the value that was added to the "max_ranking" field in this mutation.
func (m *PartyResultRecordMutation) AddedMaxRanking() (r int, exists bool) {
	v := m.addmax_ranking
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxRanking clears the value of the "max_ranking" field.
func (m *PartyResultRecordMutation) ClearMaxRanking() {
	m.max_ranking = nil
	m.addmax_ranking = nil
	m.clearedFields[partyresultrecord.FieldMaxRanking] = struct{}{}
}

// MaxRankingCleared returns if the "max_ranking" field was cleared in this mutation.
func (m *PartyResultRecordMutation) MaxRankingCleared() bool {
	_, ok := m.clearedFields[partyresultrecord.FieldMaxRanking]
	return ok
}

// ResetMaxRanking resets all changes to the "max_ranking" field.
func (m *PartyResultRecordMutation) ResetMaxRanking() {
	m.max_ranking = nil
	m.addmax_ranking = nil
	delete(m.clearedFields, partyresultrecord.FieldMaxRanking)
}

// SetResultToPartyID sets the "result_to_party" edge to the Party entity by id.
func (m *PartyResultRecordMutation) SetResultToPartyID(id int) {
	m.result_to_party = &id
}

// ClearResultToParty clears the "result_to_party" edge to the Party entity.
func (m *PartyResultRecordMutation) ClearResultToParty() {
	m.clearedresult_to_party = true
}

// ResultToPartyCleared reports if the "result_to_party" edge to the Party entity was cleared.
func (m *PartyResultRecordMutation) ResultToPartyCleared() bool {
	return m.clearedresult_to_party
}

// ResultToPartyID returns the "result_to_party" edge ID in the mutation.
func (m *PartyResultRecordMutation) ResultToPartyID() (id int, exists bool) {
	if m.result_to_party != nil {
		return *m.result_to_party, true
	}
	return
}

// ResultToPartyIDs returns the "result_to_party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResultToPartyID instead. It exists only for internal usage by the builders.
func (m *PartyResultRecordMutation) ResultToPartyIDs() (ids []int) {
	if id := m.result_to_party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResultToParty resets all changes to the "result_to_party" edge.
func (m *PartyResultRecordMutation) ResetResultToParty() {
	m.result_to_party = nil
	m.clearedresult_to_party = false
}

// Where appends a list predicates to the PartyResultRecordMutation builder.
func (m *PartyResultRecordMutation) Where(ps ...predicate.PartyResultRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PartyResultRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PartyResultRecord).
func (m *PartyResultRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartyResultRecordMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.result_to_party != nil {
		fields = append(fields, partyresultrecord.FieldPartyID)
	}
	if m.generation != nil {
		fields = append(fields, partyresultrecord.FieldGeneration)
	}
	if m.seasen != nil {
		fields = append(fields, partyresultrecord.FieldSeasen)
	}
	if m.max_rate != nil {
		fields = append(fields, partyresultrecord.FieldMaxRate)
	}
	if m.max_ranking != nil {
		fields = append(fields, partyresultrecord.FieldMaxRanking)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartyResultRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partyresultrecord.FieldPartyID:
		return m.PartyID()
	case partyresultrecord.FieldGeneration:
		return m.Generation()
	case partyresultrecord.FieldSeasen:
		return m.Seasen()
	case partyresultrecord.FieldMaxRate:
		return m.MaxRate()
	case partyresultrecord.FieldMaxRanking:
		return m.MaxRanking()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartyResultRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partyresultrecord.FieldPartyID:
		return m.OldPartyID(ctx)
	case partyresultrecord.FieldGeneration:
		return m.OldGeneration(ctx)
	case partyresultrecord.FieldSeasen:
		return m.OldSeasen(ctx)
	case partyresultrecord.FieldMaxRate:
		return m.OldMaxRate(ctx)
	case partyresultrecord.FieldMaxRanking:
		return m.OldMaxRanking(ctx)
	}
	return nil, fmt.Errorf("unknown PartyResultRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyResultRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partyresultrecord.FieldPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartyID(v)
		return nil
	case partyresultrecord.FieldGeneration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneration(v)
		return nil
	case partyresultrecord.FieldSeasen:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasen(v)
		return nil
	case partyresultrecord.FieldMaxRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRate(v)
		return nil
	case partyresultrecord.FieldMaxRanking:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRanking(v)
		return nil
	}
	return fmt.Errorf("unknown PartyResultRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartyResultRecordMutation) AddedFields() []string {
	var fields []string
	if m.addgeneration != nil {
		fields = append(fields, partyresultrecord.FieldGeneration)
	}
	if m.addseasen != nil {
		fields = append(fields, partyresultrecord.FieldSeasen)
	}
	if m.addmax_rate != nil {
		fields = append(fields, partyresultrecord.FieldMaxRate)
	}
	if m.addmax_ranking != nil {
		fields = append(fields, partyresultrecord.FieldMaxRanking)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartyResultRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partyresultrecord.FieldGeneration:
		return m.AddedGeneration()
	case partyresultrecord.FieldSeasen:
		return m.AddedSeasen()
	case partyresultrecord.FieldMaxRate:
		return m.AddedMaxRate()
	case partyresultrecord.FieldMaxRanking:
		return m.AddedMaxRanking()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyResultRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partyresultrecord.FieldGeneration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGeneration(v)
		return nil
	case partyresultrecord.FieldSeasen:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeasen(v)
		return nil
	case partyresultrecord.FieldMaxRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRate(v)
		return nil
	case partyresultrecord.FieldMaxRanking:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRanking(v)
		return nil
	}
	return fmt.Errorf("unknown PartyResultRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartyResultRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partyresultrecord.FieldMaxRate) {
		fields = append(fields, partyresultrecord.FieldMaxRate)
	}
	if m.FieldCleared(partyresultrecord.FieldMaxRanking) {
		fields = append(fields, partyresultrecord.FieldMaxRanking)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartyResultRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartyResultRecordMutation) ClearField(name string) error {
	switch name {
	case partyresultrecord.FieldMaxRate:
		m.ClearMaxRate()
		return nil
	case partyresultrecord.FieldMaxRanking:
		m.ClearMaxRanking()
		return nil
	}
	return fmt.Errorf("unknown PartyResultRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartyResultRecordMutation) ResetField(name string) error {
	switch name {
	case partyresultrecord.FieldPartyID:
		m.ResetPartyID()
		return nil
	case partyresultrecord.FieldGeneration:
		m.ResetGeneration()
		return nil
	case partyresultrecord.FieldSeasen:
		m.ResetSeasen()
		return nil
	case partyresultrecord.FieldMaxRate:
		m.ResetMaxRate()
		return nil
	case partyresultrecord.FieldMaxRanking:
		m.ResetMaxRanking()
		return nil
	}
	return fmt.Errorf("unknown PartyResultRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartyResultRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.result_to_party != nil {
		edges = append(edges, partyresultrecord.EdgeResultToParty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartyResultRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partyresultrecord.EdgeResultToParty:
		if id := m.result_to_party; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartyResultRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartyResultRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartyResultRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresult_to_party {
		edges = append(edges, partyresultrecord.EdgeResultToParty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartyResultRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case partyresultrecord.EdgeResultToParty:
		return m.clearedresult_to_party
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartyResultRecordMutation) ClearEdge(name string) error {
	switch name {
	case partyresultrecord.EdgeResultToParty:
		m.ClearResultToParty()
		return nil
	}
	return fmt.Errorf("unknown PartyResultRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartyResultRecordMutation) ResetEdge(name string) error {
	switch name {
	case partyresultrecord.EdgeResultToParty:
		m.ResetResultToParty()
		return nil
	}
	return fmt.Errorf("unknown PartyResultRecord edge %s", name)
}

// PokemonsMutation represents an operation that mutates the Pokemons nodes in the graph.
type PokemonsMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	pokedex_no                *int
	addpokedex_no             *int
	form_name                 *string
	name                      *string
	english_name              *string
	type1                     *property.Types
	type2                     *property.Types
	is_final_evolution        *bool
	base_stats_h              *int
	addbase_stats_h           *int
	base_stats_a              *int
	addbase_stats_a           *int
	base_stats_b              *int
	addbase_stats_b           *int
	base_stats_c              *int
	addbase_stats_c           *int
	base_stats_d              *int
	addbase_stats_d           *int
	base_stats_s              *int
	addbase_stats_s           *int
	clearedFields             map[string]struct{}
	ability1                  *int
	clearedability1           bool
	ability2                  *int
	clearedability2           bool
	hidden_ability            *int
	clearedhidden_ability     bool
	form                      *int
	clearedform               bool
	to_trained_pokemon        map[int]struct{}
	removedto_trained_pokemon map[int]struct{}
	clearedto_trained_pokemon bool
	pokemon_to_move           map[int]struct{}
	removedpokemon_to_move    map[int]struct{}
	clearedpokemon_to_move    bool
	done                      bool
	oldValue                  func(context.Context) (*Pokemons, error)
	predicates                []predicate.Pokemons
}

var _ ent.Mutation = (*PokemonsMutation)(nil)

// pokemonsOption allows management of the mutation configuration using functional options.
type pokemonsOption func(*PokemonsMutation)

// newPokemonsMutation creates new mutation for the Pokemons entity.
func newPokemonsMutation(c config, op Op, opts ...pokemonsOption) *PokemonsMutation {
	m := &PokemonsMutation{
		config:        c,
		op:            op,
		typ:           TypePokemons,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPokemonsID sets the ID field of the mutation.
func withPokemonsID(id int) pokemonsOption {
	return func(m *PokemonsMutation) {
		var (
			err   error
			once  sync.Once
			value *Pokemons
		)
		m.oldValue = func(ctx context.Context) (*Pokemons, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pokemons.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPokemons sets the old Pokemons of the mutation.
func withPokemons(node *Pokemons) pokemonsOption {
	return func(m *PokemonsMutation) {
		m.oldValue = func(context.Context) (*Pokemons, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PokemonsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PokemonsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PokemonsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPokedexNo sets the "pokedex_no" field.
func (m *PokemonsMutation) SetPokedexNo(i int) {
	m.pokedex_no = &i
	m.addpokedex_no = nil
}

// PokedexNo returns the value of the "pokedex_no" field in the mutation.
func (m *PokemonsMutation) PokedexNo() (r int, exists bool) {
	v := m.pokedex_no
	if v == nil {
		return
	}
	return *v, true
}

// OldPokedexNo returns the old "pokedex_no" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldPokedexNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPokedexNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPokedexNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPokedexNo: %w", err)
	}
	return oldValue.PokedexNo, nil
}

// AddPokedexNo adds i to the "pokedex_no" field.
func (m *PokemonsMutation) AddPokedexNo(i int) {
	if m.addpokedex_no != nil {
		*m.addpokedex_no += i
	} else {
		m.addpokedex_no = &i
	}
}

// AddedPokedexNo returns the value that was added to the "pokedex_no" field in this mutation.
func (m *PokemonsMutation) AddedPokedexNo() (r int, exists bool) {
	v := m.addpokedex_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetPokedexNo resets all changes to the "pokedex_no" field.
func (m *PokemonsMutation) ResetPokedexNo() {
	m.pokedex_no = nil
	m.addpokedex_no = nil
}

// SetFormNo sets the "form_no" field.
func (m *PokemonsMutation) SetFormNo(i int) {
	m.form = &i
}

// FormNo returns the value of the "form_no" field in the mutation.
func (m *PokemonsMutation) FormNo() (r int, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldFormNo returns the old "form_no" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldFormNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormNo: %w", err)
	}
	return oldValue.FormNo, nil
}

// ResetFormNo resets all changes to the "form_no" field.
func (m *PokemonsMutation) ResetFormNo() {
	m.form = nil
}

// SetFormName sets the "form_name" field.
func (m *PokemonsMutation) SetFormName(s string) {
	m.form_name = &s
}

// FormName returns the value of the "form_name" field in the mutation.
func (m *PokemonsMutation) FormName() (r string, exists bool) {
	v := m.form_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFormName returns the old "form_name" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldFormName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormName: %w", err)
	}
	return oldValue.FormName, nil
}

// ResetFormName resets all changes to the "form_name" field.
func (m *PokemonsMutation) ResetFormName() {
	m.form_name = nil
}

// SetName sets the "name" field.
func (m *PokemonsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PokemonsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PokemonsMutation) ResetName() {
	m.name = nil
}

// SetEnglishName sets the "english_name" field.
func (m *PokemonsMutation) SetEnglishName(s string) {
	m.english_name = &s
}

// EnglishName returns the value of the "english_name" field in the mutation.
func (m *PokemonsMutation) EnglishName() (r string, exists bool) {
	v := m.english_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEnglishName returns the old "english_name" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldEnglishName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnglishName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnglishName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnglishName: %w", err)
	}
	return oldValue.EnglishName, nil
}

// ResetEnglishName resets all changes to the "english_name" field.
func (m *PokemonsMutation) ResetEnglishName() {
	m.english_name = nil
}

// SetType1 sets the "type1" field.
func (m *PokemonsMutation) SetType1(pr property.Types) {
	m.type1 = &pr
}

// Type1 returns the value of the "type1" field in the mutation.
func (m *PokemonsMutation) Type1() (r property.Types, exists bool) {
	v := m.type1
	if v == nil {
		return
	}
	return *v, true
}

// OldType1 returns the old "type1" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldType1(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType1: %w", err)
	}
	return oldValue.Type1, nil
}

// ResetType1 resets all changes to the "type1" field.
func (m *PokemonsMutation) ResetType1() {
	m.type1 = nil
}

// SetType2 sets the "type2" field.
func (m *PokemonsMutation) SetType2(pr property.Types) {
	m.type2 = &pr
}

// Type2 returns the value of the "type2" field in the mutation.
func (m *PokemonsMutation) Type2() (r property.Types, exists bool) {
	v := m.type2
	if v == nil {
		return
	}
	return *v, true
}

// OldType2 returns the old "type2" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldType2(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType2: %w", err)
	}
	return oldValue.Type2, nil
}

// ClearType2 clears the value of the "type2" field.
func (m *PokemonsMutation) ClearType2() {
	m.type2 = nil
	m.clearedFields[pokemons.FieldType2] = struct{}{}
}

// Type2Cleared returns if the "type2" field was cleared in this mutation.
func (m *PokemonsMutation) Type2Cleared() bool {
	_, ok := m.clearedFields[pokemons.FieldType2]
	return ok
}

// ResetType2 resets all changes to the "type2" field.
func (m *PokemonsMutation) ResetType2() {
	m.type2 = nil
	delete(m.clearedFields, pokemons.FieldType2)
}

// SetAbilityId1 sets the "ability_id1" field.
func (m *PokemonsMutation) SetAbilityId1(i int) {
	m.ability1 = &i
}

// AbilityId1 returns the value of the "ability_id1" field in the mutation.
func (m *PokemonsMutation) AbilityId1() (r int, exists bool) {
	v := m.ability1
	if v == nil {
		return
	}
	return *v, true
}

// OldAbilityId1 returns the old "ability_id1" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldAbilityId1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbilityId1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbilityId1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbilityId1: %w", err)
	}
	return oldValue.AbilityId1, nil
}

// ResetAbilityId1 resets all changes to the "ability_id1" field.
func (m *PokemonsMutation) ResetAbilityId1() {
	m.ability1 = nil
}

// SetAbilityId2 sets the "ability_id2" field.
func (m *PokemonsMutation) SetAbilityId2(i int) {
	m.ability2 = &i
}

// AbilityId2 returns the value of the "ability_id2" field in the mutation.
func (m *PokemonsMutation) AbilityId2() (r int, exists bool) {
	v := m.ability2
	if v == nil {
		return
	}
	return *v, true
}

// OldAbilityId2 returns the old "ability_id2" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldAbilityId2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbilityId2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbilityId2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbilityId2: %w", err)
	}
	return oldValue.AbilityId2, nil
}

// ClearAbilityId2 clears the value of the "ability_id2" field.
func (m *PokemonsMutation) ClearAbilityId2() {
	m.ability2 = nil
	m.clearedFields[pokemons.FieldAbilityId2] = struct{}{}
}

// AbilityId2Cleared returns if the "ability_id2" field was cleared in this mutation.
func (m *PokemonsMutation) AbilityId2Cleared() bool {
	_, ok := m.clearedFields[pokemons.FieldAbilityId2]
	return ok
}

// ResetAbilityId2 resets all changes to the "ability_id2" field.
func (m *PokemonsMutation) ResetAbilityId2() {
	m.ability2 = nil
	delete(m.clearedFields, pokemons.FieldAbilityId2)
}

// SetHiddenAbilityID sets the "hidden_ability_id" field.
func (m *PokemonsMutation) SetHiddenAbilityID(i int) {
	m.hidden_ability = &i
}

// HiddenAbilityID returns the value of the "hidden_ability_id" field in the mutation.
func (m *PokemonsMutation) HiddenAbilityID() (r int, exists bool) {
	v := m.hidden_ability
	if v == nil {
		return
	}
	return *v, true
}

// OldHiddenAbilityID returns the old "hidden_ability_id" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldHiddenAbilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHiddenAbilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHiddenAbilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiddenAbilityID: %w", err)
	}
	return oldValue.HiddenAbilityID, nil
}

// ClearHiddenAbilityID clears the value of the "hidden_ability_id" field.
func (m *PokemonsMutation) ClearHiddenAbilityID() {
	m.hidden_ability = nil
	m.clearedFields[pokemons.FieldHiddenAbilityID] = struct{}{}
}

// HiddenAbilityIDCleared returns if the "hidden_ability_id" field was cleared in this mutation.
func (m *PokemonsMutation) HiddenAbilityIDCleared() bool {
	_, ok := m.clearedFields[pokemons.FieldHiddenAbilityID]
	return ok
}

// ResetHiddenAbilityID resets all changes to the "hidden_ability_id" field.
func (m *PokemonsMutation) ResetHiddenAbilityID() {
	m.hidden_ability = nil
	delete(m.clearedFields, pokemons.FieldHiddenAbilityID)
}

// SetIsFinalEvolution sets the "is_final_evolution" field.
func (m *PokemonsMutation) SetIsFinalEvolution(b bool) {
	m.is_final_evolution = &b
}

// IsFinalEvolution returns the value of the "is_final_evolution" field in the mutation.
func (m *PokemonsMutation) IsFinalEvolution() (r bool, exists bool) {
	v := m.is_final_evolution
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinalEvolution returns the old "is_final_evolution" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldIsFinalEvolution(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsFinalEvolution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsFinalEvolution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinalEvolution: %w", err)
	}
	return oldValue.IsFinalEvolution, nil
}

// ResetIsFinalEvolution resets all changes to the "is_final_evolution" field.
func (m *PokemonsMutation) ResetIsFinalEvolution() {
	m.is_final_evolution = nil
}

// SetBaseStatsH sets the "base_stats_h" field.
func (m *PokemonsMutation) SetBaseStatsH(i int) {
	m.base_stats_h = &i
	m.addbase_stats_h = nil
}

// BaseStatsH returns the value of the "base_stats_h" field in the mutation.
func (m *PokemonsMutation) BaseStatsH() (r int, exists bool) {
	v := m.base_stats_h
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseStatsH returns the old "base_stats_h" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldBaseStatsH(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBaseStatsH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBaseStatsH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseStatsH: %w", err)
	}
	return oldValue.BaseStatsH, nil
}

// AddBaseStatsH adds i to the "base_stats_h" field.
func (m *PokemonsMutation) AddBaseStatsH(i int) {
	if m.addbase_stats_h != nil {
		*m.addbase_stats_h += i
	} else {
		m.addbase_stats_h = &i
	}
}

// AddedBaseStatsH returns the value that was added to the "base_stats_h" field in this mutation.
func (m *PokemonsMutation) AddedBaseStatsH() (r int, exists bool) {
	v := m.addbase_stats_h
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseStatsH resets all changes to the "base_stats_h" field.
func (m *PokemonsMutation) ResetBaseStatsH() {
	m.base_stats_h = nil
	m.addbase_stats_h = nil
}

// SetBaseStatsA sets the "base_stats_a" field.
func (m *PokemonsMutation) SetBaseStatsA(i int) {
	m.base_stats_a = &i
	m.addbase_stats_a = nil
}

// BaseStatsA returns the value of the "base_stats_a" field in the mutation.
func (m *PokemonsMutation) BaseStatsA() (r int, exists bool) {
	v := m.base_stats_a
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseStatsA returns the old "base_stats_a" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldBaseStatsA(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBaseStatsA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBaseStatsA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseStatsA: %w", err)
	}
	return oldValue.BaseStatsA, nil
}

// AddBaseStatsA adds i to the "base_stats_a" field.
func (m *PokemonsMutation) AddBaseStatsA(i int) {
	if m.addbase_stats_a != nil {
		*m.addbase_stats_a += i
	} else {
		m.addbase_stats_a = &i
	}
}

// AddedBaseStatsA returns the value that was added to the "base_stats_a" field in this mutation.
func (m *PokemonsMutation) AddedBaseStatsA() (r int, exists bool) {
	v := m.addbase_stats_a
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseStatsA resets all changes to the "base_stats_a" field.
func (m *PokemonsMutation) ResetBaseStatsA() {
	m.base_stats_a = nil
	m.addbase_stats_a = nil
}

// SetBaseStatsB sets the "base_stats_b" field.
func (m *PokemonsMutation) SetBaseStatsB(i int) {
	m.base_stats_b = &i
	m.addbase_stats_b = nil
}

// BaseStatsB returns the value of the "base_stats_b" field in the mutation.
func (m *PokemonsMutation) BaseStatsB() (r int, exists bool) {
	v := m.base_stats_b
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseStatsB returns the old "base_stats_b" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldBaseStatsB(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBaseStatsB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBaseStatsB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseStatsB: %w", err)
	}
	return oldValue.BaseStatsB, nil
}

// AddBaseStatsB adds i to the "base_stats_b" field.
func (m *PokemonsMutation) AddBaseStatsB(i int) {
	if m.addbase_stats_b != nil {
		*m.addbase_stats_b += i
	} else {
		m.addbase_stats_b = &i
	}
}

// AddedBaseStatsB returns the value that was added to the "base_stats_b" field in this mutation.
func (m *PokemonsMutation) AddedBaseStatsB() (r int, exists bool) {
	v := m.addbase_stats_b
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseStatsB resets all changes to the "base_stats_b" field.
func (m *PokemonsMutation) ResetBaseStatsB() {
	m.base_stats_b = nil
	m.addbase_stats_b = nil
}

// SetBaseStatsC sets the "base_stats_c" field.
func (m *PokemonsMutation) SetBaseStatsC(i int) {
	m.base_stats_c = &i
	m.addbase_stats_c = nil
}

// BaseStatsC returns the value of the "base_stats_c" field in the mutation.
func (m *PokemonsMutation) BaseStatsC() (r int, exists bool) {
	v := m.base_stats_c
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseStatsC returns the old "base_stats_c" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldBaseStatsC(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBaseStatsC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBaseStatsC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseStatsC: %w", err)
	}
	return oldValue.BaseStatsC, nil
}

// AddBaseStatsC adds i to the "base_stats_c" field.
func (m *PokemonsMutation) AddBaseStatsC(i int) {
	if m.addbase_stats_c != nil {
		*m.addbase_stats_c += i
	} else {
		m.addbase_stats_c = &i
	}
}

// AddedBaseStatsC returns the value that was added to the "base_stats_c" field in this mutation.
func (m *PokemonsMutation) AddedBaseStatsC() (r int, exists bool) {
	v := m.addbase_stats_c
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseStatsC resets all changes to the "base_stats_c" field.
func (m *PokemonsMutation) ResetBaseStatsC() {
	m.base_stats_c = nil
	m.addbase_stats_c = nil
}

// SetBaseStatsD sets the "base_stats_d" field.
func (m *PokemonsMutation) SetBaseStatsD(i int) {
	m.base_stats_d = &i
	m.addbase_stats_d = nil
}

// BaseStatsD returns the value of the "base_stats_d" field in the mutation.
func (m *PokemonsMutation) BaseStatsD() (r int, exists bool) {
	v := m.base_stats_d
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseStatsD returns the old "base_stats_d" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldBaseStatsD(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBaseStatsD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBaseStatsD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseStatsD: %w", err)
	}
	return oldValue.BaseStatsD, nil
}

// AddBaseStatsD adds i to the "base_stats_d" field.
func (m *PokemonsMutation) AddBaseStatsD(i int) {
	if m.addbase_stats_d != nil {
		*m.addbase_stats_d += i
	} else {
		m.addbase_stats_d = &i
	}
}

// AddedBaseStatsD returns the value that was added to the "base_stats_d" field in this mutation.
func (m *PokemonsMutation) AddedBaseStatsD() (r int, exists bool) {
	v := m.addbase_stats_d
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseStatsD resets all changes to the "base_stats_d" field.
func (m *PokemonsMutation) ResetBaseStatsD() {
	m.base_stats_d = nil
	m.addbase_stats_d = nil
}

// SetBaseStatsS sets the "base_stats_s" field.
func (m *PokemonsMutation) SetBaseStatsS(i int) {
	m.base_stats_s = &i
	m.addbase_stats_s = nil
}

// BaseStatsS returns the value of the "base_stats_s" field in the mutation.
func (m *PokemonsMutation) BaseStatsS() (r int, exists bool) {
	v := m.base_stats_s
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseStatsS returns the old "base_stats_s" field's value of the Pokemons entity.
// If the Pokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PokemonsMutation) OldBaseStatsS(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBaseStatsS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBaseStatsS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseStatsS: %w", err)
	}
	return oldValue.BaseStatsS, nil
}

// AddBaseStatsS adds i to the "base_stats_s" field.
func (m *PokemonsMutation) AddBaseStatsS(i int) {
	if m.addbase_stats_s != nil {
		*m.addbase_stats_s += i
	} else {
		m.addbase_stats_s = &i
	}
}

// AddedBaseStatsS returns the value that was added to the "base_stats_s" field in this mutation.
func (m *PokemonsMutation) AddedBaseStatsS() (r int, exists bool) {
	v := m.addbase_stats_s
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseStatsS resets all changes to the "base_stats_s" field.
func (m *PokemonsMutation) ResetBaseStatsS() {
	m.base_stats_s = nil
	m.addbase_stats_s = nil
}

// SetAbility1ID sets the "ability1" edge to the Abilities entity by id.
func (m *PokemonsMutation) SetAbility1ID(id int) {
	m.ability1 = &id
}

// ClearAbility1 clears the "ability1" edge to the Abilities entity.
func (m *PokemonsMutation) ClearAbility1() {
	m.clearedability1 = true
}

// Ability1Cleared reports if the "ability1" edge to the Abilities entity was cleared.
func (m *PokemonsMutation) Ability1Cleared() bool {
	return m.clearedability1
}

// Ability1ID returns the "ability1" edge ID in the mutation.
func (m *PokemonsMutation) Ability1ID() (id int, exists bool) {
	if m.ability1 != nil {
		return *m.ability1, true
	}
	return
}

// Ability1IDs returns the "ability1" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// Ability1ID instead. It exists only for internal usage by the builders.
func (m *PokemonsMutation) Ability1IDs() (ids []int) {
	if id := m.ability1; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbility1 resets all changes to the "ability1" edge.
func (m *PokemonsMutation) ResetAbility1() {
	m.ability1 = nil
	m.clearedability1 = false
}

// SetAbility2ID sets the "ability2" edge to the Abilities entity by id.
func (m *PokemonsMutation) SetAbility2ID(id int) {
	m.ability2 = &id
}

// ClearAbility2 clears the "ability2" edge to the Abilities entity.
func (m *PokemonsMutation) ClearAbility2() {
	m.clearedability2 = true
}

// Ability2Cleared reports if the "ability2" edge to the Abilities entity was cleared.
func (m *PokemonsMutation) Ability2Cleared() bool {
	return m.AbilityId2Cleared() || m.clearedability2
}

// Ability2ID returns the "ability2" edge ID in the mutation.
func (m *PokemonsMutation) Ability2ID() (id int, exists bool) {
	if m.ability2 != nil {
		return *m.ability2, true
	}
	return
}

// Ability2IDs returns the "ability2" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// Ability2ID instead. It exists only for internal usage by the builders.
func (m *PokemonsMutation) Ability2IDs() (ids []int) {
	if id := m.ability2; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbility2 resets all changes to the "ability2" edge.
func (m *PokemonsMutation) ResetAbility2() {
	m.ability2 = nil
	m.clearedability2 = false
}

// ClearHiddenAbility clears the "hidden_ability" edge to the Abilities entity.
func (m *PokemonsMutation) ClearHiddenAbility() {
	m.clearedhidden_ability = true
}

// HiddenAbilityCleared reports if the "hidden_ability" edge to the Abilities entity was cleared.
func (m *PokemonsMutation) HiddenAbilityCleared() bool {
	return m.HiddenAbilityIDCleared() || m.clearedhidden_ability
}

// HiddenAbilityIDs returns the "hidden_ability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HiddenAbilityID instead. It exists only for internal usage by the builders.
func (m *PokemonsMutation) HiddenAbilityIDs() (ids []int) {
	if id := m.hidden_ability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHiddenAbility resets all changes to the "hidden_ability" edge.
func (m *PokemonsMutation) ResetHiddenAbility() {
	m.hidden_ability = nil
	m.clearedhidden_ability = false
}

// SetFormID sets the "form" edge to the Forms entity by id.
func (m *PokemonsMutation) SetFormID(id int) {
	m.form = &id
}

// ClearForm clears the "form" edge to the Forms entity.
func (m *PokemonsMutation) ClearForm() {
	m.clearedform = true
}

// FormCleared reports if the "form" edge to the Forms entity was cleared.
func (m *PokemonsMutation) FormCleared() bool {
	return m.clearedform
}

// FormID returns the "form" edge ID in the mutation.
func (m *PokemonsMutation) FormID() (id int, exists bool) {
	if m.form != nil {
		return *m.form, true
	}
	return
}

// FormIDs returns the "form" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FormID instead. It exists only for internal usage by the builders.
func (m *PokemonsMutation) FormIDs() (ids []int) {
	if id := m.form; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetForm resets all changes to the "form" edge.
func (m *PokemonsMutation) ResetForm() {
	m.form = nil
	m.clearedform = false
}

// AddToTrainedPokemonIDs adds the "to_trained_pokemon" edge to the TrainedPokemons entity by ids.
func (m *PokemonsMutation) AddToTrainedPokemonIDs(ids ...int) {
	if m.to_trained_pokemon == nil {
		m.to_trained_pokemon = make(map[int]struct{})
	}
	for i := range ids {
		m.to_trained_pokemon[ids[i]] = struct{}{}
	}
}

// ClearToTrainedPokemon clears the "to_trained_pokemon" edge to the TrainedPokemons entity.
func (m *PokemonsMutation) ClearToTrainedPokemon() {
	m.clearedto_trained_pokemon = true
}

// ToTrainedPokemonCleared reports if the "to_trained_pokemon" edge to the TrainedPokemons entity was cleared.
func (m *PokemonsMutation) ToTrainedPokemonCleared() bool {
	return m.clearedto_trained_pokemon
}

// RemoveToTrainedPokemonIDs removes the "to_trained_pokemon" edge to the TrainedPokemons entity by IDs.
func (m *PokemonsMutation) RemoveToTrainedPokemonIDs(ids ...int) {
	if m.removedto_trained_pokemon == nil {
		m.removedto_trained_pokemon = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_trained_pokemon, ids[i])
		m.removedto_trained_pokemon[ids[i]] = struct{}{}
	}
}

// RemovedToTrainedPokemon returns the removed IDs of the "to_trained_pokemon" edge to the TrainedPokemons entity.
func (m *PokemonsMutation) RemovedToTrainedPokemonIDs() (ids []int) {
	for id := range m.removedto_trained_pokemon {
		ids = append(ids, id)
	}
	return
}

// ToTrainedPokemonIDs returns the "to_trained_pokemon" edge IDs in the mutation.
func (m *PokemonsMutation) ToTrainedPokemonIDs() (ids []int) {
	for id := range m.to_trained_pokemon {
		ids = append(ids, id)
	}
	return
}

// ResetToTrainedPokemon resets all changes to the "to_trained_pokemon" edge.
func (m *PokemonsMutation) ResetToTrainedPokemon() {
	m.to_trained_pokemon = nil
	m.clearedto_trained_pokemon = false
	m.removedto_trained_pokemon = nil
}

// AddPokemonToMoveIDs adds the "pokemon_to_move" edge to the Moves entity by ids.
func (m *PokemonsMutation) AddPokemonToMoveIDs(ids ...int) {
	if m.pokemon_to_move == nil {
		m.pokemon_to_move = make(map[int]struct{})
	}
	for i := range ids {
		m.pokemon_to_move[ids[i]] = struct{}{}
	}
}

// ClearPokemonToMove clears the "pokemon_to_move" edge to the Moves entity.
func (m *PokemonsMutation) ClearPokemonToMove() {
	m.clearedpokemon_to_move = true
}

// PokemonToMoveCleared reports if the "pokemon_to_move" edge to the Moves entity was cleared.
func (m *PokemonsMutation) PokemonToMoveCleared() bool {
	return m.clearedpokemon_to_move
}

// RemovePokemonToMoveIDs removes the "pokemon_to_move" edge to the Moves entity by IDs.
func (m *PokemonsMutation) RemovePokemonToMoveIDs(ids ...int) {
	if m.removedpokemon_to_move == nil {
		m.removedpokemon_to_move = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pokemon_to_move, ids[i])
		m.removedpokemon_to_move[ids[i]] = struct{}{}
	}
}

// RemovedPokemonToMove returns the removed IDs of the "pokemon_to_move" edge to the Moves entity.
func (m *PokemonsMutation) RemovedPokemonToMoveIDs() (ids []int) {
	for id := range m.removedpokemon_to_move {
		ids = append(ids, id)
	}
	return
}

// PokemonToMoveIDs returns the "pokemon_to_move" edge IDs in the mutation.
func (m *PokemonsMutation) PokemonToMoveIDs() (ids []int) {
	for id := range m.pokemon_to_move {
		ids = append(ids, id)
	}
	return
}

// ResetPokemonToMove resets all changes to the "pokemon_to_move" edge.
func (m *PokemonsMutation) ResetPokemonToMove() {
	m.pokemon_to_move = nil
	m.clearedpokemon_to_move = false
	m.removedpokemon_to_move = nil
}

// Where appends a list predicates to the PokemonsMutation builder.
func (m *PokemonsMutation) Where(ps ...predicate.Pokemons) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PokemonsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pokemons).
func (m *PokemonsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PokemonsMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.pokedex_no != nil {
		fields = append(fields, pokemons.FieldPokedexNo)
	}
	if m.form != nil {
		fields = append(fields, pokemons.FieldFormNo)
	}
	if m.form_name != nil {
		fields = append(fields, pokemons.FieldFormName)
	}
	if m.name != nil {
		fields = append(fields, pokemons.FieldName)
	}
	if m.english_name != nil {
		fields = append(fields, pokemons.FieldEnglishName)
	}
	if m.type1 != nil {
		fields = append(fields, pokemons.FieldType1)
	}
	if m.type2 != nil {
		fields = append(fields, pokemons.FieldType2)
	}
	if m.ability1 != nil {
		fields = append(fields, pokemons.FieldAbilityId1)
	}
	if m.ability2 != nil {
		fields = append(fields, pokemons.FieldAbilityId2)
	}
	if m.hidden_ability != nil {
		fields = append(fields, pokemons.FieldHiddenAbilityID)
	}
	if m.is_final_evolution != nil {
		fields = append(fields, pokemons.FieldIsFinalEvolution)
	}
	if m.base_stats_h != nil {
		fields = append(fields, pokemons.FieldBaseStatsH)
	}
	if m.base_stats_a != nil {
		fields = append(fields, pokemons.FieldBaseStatsA)
	}
	if m.base_stats_b != nil {
		fields = append(fields, pokemons.FieldBaseStatsB)
	}
	if m.base_stats_c != nil {
		fields = append(fields, pokemons.FieldBaseStatsC)
	}
	if m.base_stats_d != nil {
		fields = append(fields, pokemons.FieldBaseStatsD)
	}
	if m.base_stats_s != nil {
		fields = append(fields, pokemons.FieldBaseStatsS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PokemonsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pokemons.FieldPokedexNo:
		return m.PokedexNo()
	case pokemons.FieldFormNo:
		return m.FormNo()
	case pokemons.FieldFormName:
		return m.FormName()
	case pokemons.FieldName:
		return m.Name()
	case pokemons.FieldEnglishName:
		return m.EnglishName()
	case pokemons.FieldType1:
		return m.Type1()
	case pokemons.FieldType2:
		return m.Type2()
	case pokemons.FieldAbilityId1:
		return m.AbilityId1()
	case pokemons.FieldAbilityId2:
		return m.AbilityId2()
	case pokemons.FieldHiddenAbilityID:
		return m.HiddenAbilityID()
	case pokemons.FieldIsFinalEvolution:
		return m.IsFinalEvolution()
	case pokemons.FieldBaseStatsH:
		return m.BaseStatsH()
	case pokemons.FieldBaseStatsA:
		return m.BaseStatsA()
	case pokemons.FieldBaseStatsB:
		return m.BaseStatsB()
	case pokemons.FieldBaseStatsC:
		return m.BaseStatsC()
	case pokemons.FieldBaseStatsD:
		return m.BaseStatsD()
	case pokemons.FieldBaseStatsS:
		return m.BaseStatsS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PokemonsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pokemons.FieldPokedexNo:
		return m.OldPokedexNo(ctx)
	case pokemons.FieldFormNo:
		return m.OldFormNo(ctx)
	case pokemons.FieldFormName:
		return m.OldFormName(ctx)
	case pokemons.FieldName:
		return m.OldName(ctx)
	case pokemons.FieldEnglishName:
		return m.OldEnglishName(ctx)
	case pokemons.FieldType1:
		return m.OldType1(ctx)
	case pokemons.FieldType2:
		return m.OldType2(ctx)
	case pokemons.FieldAbilityId1:
		return m.OldAbilityId1(ctx)
	case pokemons.FieldAbilityId2:
		return m.OldAbilityId2(ctx)
	case pokemons.FieldHiddenAbilityID:
		return m.OldHiddenAbilityID(ctx)
	case pokemons.FieldIsFinalEvolution:
		return m.OldIsFinalEvolution(ctx)
	case pokemons.FieldBaseStatsH:
		return m.OldBaseStatsH(ctx)
	case pokemons.FieldBaseStatsA:
		return m.OldBaseStatsA(ctx)
	case pokemons.FieldBaseStatsB:
		return m.OldBaseStatsB(ctx)
	case pokemons.FieldBaseStatsC:
		return m.OldBaseStatsC(ctx)
	case pokemons.FieldBaseStatsD:
		return m.OldBaseStatsD(ctx)
	case pokemons.FieldBaseStatsS:
		return m.OldBaseStatsS(ctx)
	}
	return nil, fmt.Errorf("unknown Pokemons field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PokemonsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pokemons.FieldPokedexNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPokedexNo(v)
		return nil
	case pokemons.FieldFormNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormNo(v)
		return nil
	case pokemons.FieldFormName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormName(v)
		return nil
	case pokemons.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pokemons.FieldEnglishName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnglishName(v)
		return nil
	case pokemons.FieldType1:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType1(v)
		return nil
	case pokemons.FieldType2:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType2(v)
		return nil
	case pokemons.FieldAbilityId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbilityId1(v)
		return nil
	case pokemons.FieldAbilityId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbilityId2(v)
		return nil
	case pokemons.FieldHiddenAbilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiddenAbilityID(v)
		return nil
	case pokemons.FieldIsFinalEvolution:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinalEvolution(v)
		return nil
	case pokemons.FieldBaseStatsH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseStatsH(v)
		return nil
	case pokemons.FieldBaseStatsA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseStatsA(v)
		return nil
	case pokemons.FieldBaseStatsB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseStatsB(v)
		return nil
	case pokemons.FieldBaseStatsC:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseStatsC(v)
		return nil
	case pokemons.FieldBaseStatsD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseStatsD(v)
		return nil
	case pokemons.FieldBaseStatsS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseStatsS(v)
		return nil
	}
	return fmt.Errorf("unknown Pokemons field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PokemonsMutation) AddedFields() []string {
	var fields []string
	if m.addpokedex_no != nil {
		fields = append(fields, pokemons.FieldPokedexNo)
	}
	if m.addbase_stats_h != nil {
		fields = append(fields, pokemons.FieldBaseStatsH)
	}
	if m.addbase_stats_a != nil {
		fields = append(fields, pokemons.FieldBaseStatsA)
	}
	if m.addbase_stats_b != nil {
		fields = append(fields, pokemons.FieldBaseStatsB)
	}
	if m.addbase_stats_c != nil {
		fields = append(fields, pokemons.FieldBaseStatsC)
	}
	if m.addbase_stats_d != nil {
		fields = append(fields, pokemons.FieldBaseStatsD)
	}
	if m.addbase_stats_s != nil {
		fields = append(fields, pokemons.FieldBaseStatsS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PokemonsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pokemons.FieldPokedexNo:
		return m.AddedPokedexNo()
	case pokemons.FieldBaseStatsH:
		return m.AddedBaseStatsH()
	case pokemons.FieldBaseStatsA:
		return m.AddedBaseStatsA()
	case pokemons.FieldBaseStatsB:
		return m.AddedBaseStatsB()
	case pokemons.FieldBaseStatsC:
		return m.AddedBaseStatsC()
	case pokemons.FieldBaseStatsD:
		return m.AddedBaseStatsD()
	case pokemons.FieldBaseStatsS:
		return m.AddedBaseStatsS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PokemonsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pokemons.FieldPokedexNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPokedexNo(v)
		return nil
	case pokemons.FieldBaseStatsH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseStatsH(v)
		return nil
	case pokemons.FieldBaseStatsA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseStatsA(v)
		return nil
	case pokemons.FieldBaseStatsB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseStatsB(v)
		return nil
	case pokemons.FieldBaseStatsC:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseStatsC(v)
		return nil
	case pokemons.FieldBaseStatsD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseStatsD(v)
		return nil
	case pokemons.FieldBaseStatsS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseStatsS(v)
		return nil
	}
	return fmt.Errorf("unknown Pokemons numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PokemonsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pokemons.FieldType2) {
		fields = append(fields, pokemons.FieldType2)
	}
	if m.FieldCleared(pokemons.FieldAbilityId2) {
		fields = append(fields, pokemons.FieldAbilityId2)
	}
	if m.FieldCleared(pokemons.FieldHiddenAbilityID) {
		fields = append(fields, pokemons.FieldHiddenAbilityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PokemonsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PokemonsMutation) ClearField(name string) error {
	switch name {
	case pokemons.FieldType2:
		m.ClearType2()
		return nil
	case pokemons.FieldAbilityId2:
		m.ClearAbilityId2()
		return nil
	case pokemons.FieldHiddenAbilityID:
		m.ClearHiddenAbilityID()
		return nil
	}
	return fmt.Errorf("unknown Pokemons nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PokemonsMutation) ResetField(name string) error {
	switch name {
	case pokemons.FieldPokedexNo:
		m.ResetPokedexNo()
		return nil
	case pokemons.FieldFormNo:
		m.ResetFormNo()
		return nil
	case pokemons.FieldFormName:
		m.ResetFormName()
		return nil
	case pokemons.FieldName:
		m.ResetName()
		return nil
	case pokemons.FieldEnglishName:
		m.ResetEnglishName()
		return nil
	case pokemons.FieldType1:
		m.ResetType1()
		return nil
	case pokemons.FieldType2:
		m.ResetType2()
		return nil
	case pokemons.FieldAbilityId1:
		m.ResetAbilityId1()
		return nil
	case pokemons.FieldAbilityId2:
		m.ResetAbilityId2()
		return nil
	case pokemons.FieldHiddenAbilityID:
		m.ResetHiddenAbilityID()
		return nil
	case pokemons.FieldIsFinalEvolution:
		m.ResetIsFinalEvolution()
		return nil
	case pokemons.FieldBaseStatsH:
		m.ResetBaseStatsH()
		return nil
	case pokemons.FieldBaseStatsA:
		m.ResetBaseStatsA()
		return nil
	case pokemons.FieldBaseStatsB:
		m.ResetBaseStatsB()
		return nil
	case pokemons.FieldBaseStatsC:
		m.ResetBaseStatsC()
		return nil
	case pokemons.FieldBaseStatsD:
		m.ResetBaseStatsD()
		return nil
	case pokemons.FieldBaseStatsS:
		m.ResetBaseStatsS()
		return nil
	}
	return fmt.Errorf("unknown Pokemons field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PokemonsMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.ability1 != nil {
		edges = append(edges, pokemons.EdgeAbility1)
	}
	if m.ability2 != nil {
		edges = append(edges, pokemons.EdgeAbility2)
	}
	if m.hidden_ability != nil {
		edges = append(edges, pokemons.EdgeHiddenAbility)
	}
	if m.form != nil {
		edges = append(edges, pokemons.EdgeForm)
	}
	if m.to_trained_pokemon != nil {
		edges = append(edges, pokemons.EdgeToTrainedPokemon)
	}
	if m.pokemon_to_move != nil {
		edges = append(edges, pokemons.EdgePokemonToMove)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PokemonsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pokemons.EdgeAbility1:
		if id := m.ability1; id != nil {
			return []ent.Value{*id}
		}
	case pokemons.EdgeAbility2:
		if id := m.ability2; id != nil {
			return []ent.Value{*id}
		}
	case pokemons.EdgeHiddenAbility:
		if id := m.hidden_ability; id != nil {
			return []ent.Value{*id}
		}
	case pokemons.EdgeForm:
		if id := m.form; id != nil {
			return []ent.Value{*id}
		}
	case pokemons.EdgeToTrainedPokemon:
		ids := make([]ent.Value, 0, len(m.to_trained_pokemon))
		for id := range m.to_trained_pokemon {
			ids = append(ids, id)
		}
		return ids
	case pokemons.EdgePokemonToMove:
		ids := make([]ent.Value, 0, len(m.pokemon_to_move))
		for id := range m.pokemon_to_move {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PokemonsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedto_trained_pokemon != nil {
		edges = append(edges, pokemons.EdgeToTrainedPokemon)
	}
	if m.removedpokemon_to_move != nil {
		edges = append(edges, pokemons.EdgePokemonToMove)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PokemonsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pokemons.EdgeToTrainedPokemon:
		ids := make([]ent.Value, 0, len(m.removedto_trained_pokemon))
		for id := range m.removedto_trained_pokemon {
			ids = append(ids, id)
		}
		return ids
	case pokemons.EdgePokemonToMove:
		ids := make([]ent.Value, 0, len(m.removedpokemon_to_move))
		for id := range m.removedpokemon_to_move {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PokemonsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedability1 {
		edges = append(edges, pokemons.EdgeAbility1)
	}
	if m.clearedability2 {
		edges = append(edges, pokemons.EdgeAbility2)
	}
	if m.clearedhidden_ability {
		edges = append(edges, pokemons.EdgeHiddenAbility)
	}
	if m.clearedform {
		edges = append(edges, pokemons.EdgeForm)
	}
	if m.clearedto_trained_pokemon {
		edges = append(edges, pokemons.EdgeToTrainedPokemon)
	}
	if m.clearedpokemon_to_move {
		edges = append(edges, pokemons.EdgePokemonToMove)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PokemonsMutation) EdgeCleared(name string) bool {
	switch name {
	case pokemons.EdgeAbility1:
		return m.clearedability1
	case pokemons.EdgeAbility2:
		return m.clearedability2
	case pokemons.EdgeHiddenAbility:
		return m.clearedhidden_ability
	case pokemons.EdgeForm:
		return m.clearedform
	case pokemons.EdgeToTrainedPokemon:
		return m.clearedto_trained_pokemon
	case pokemons.EdgePokemonToMove:
		return m.clearedpokemon_to_move
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PokemonsMutation) ClearEdge(name string) error {
	switch name {
	case pokemons.EdgeAbility1:
		m.ClearAbility1()
		return nil
	case pokemons.EdgeAbility2:
		m.ClearAbility2()
		return nil
	case pokemons.EdgeHiddenAbility:
		m.ClearHiddenAbility()
		return nil
	case pokemons.EdgeForm:
		m.ClearForm()
		return nil
	}
	return fmt.Errorf("unknown Pokemons unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PokemonsMutation) ResetEdge(name string) error {
	switch name {
	case pokemons.EdgeAbility1:
		m.ResetAbility1()
		return nil
	case pokemons.EdgeAbility2:
		m.ResetAbility2()
		return nil
	case pokemons.EdgeHiddenAbility:
		m.ResetHiddenAbility()
		return nil
	case pokemons.EdgeForm:
		m.ResetForm()
		return nil
	case pokemons.EdgeToTrainedPokemon:
		m.ResetToTrainedPokemon()
		return nil
	case pokemons.EdgePokemonToMove:
		m.ResetPokemonToMove()
		return nil
	}
	return fmt.Errorf("unknown Pokemons edge %s", name)
}

// TagsMutation represents an operation that mutates the Tags nodes in the graph.
type TagsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	is_generation_tag   *bool
	is_season_tag       *bool
	clearedFields       map[string]struct{}
	tag_to_party        map[int]struct{}
	removedtag_to_party map[int]struct{}
	clearedtag_to_party bool
	done                bool
	oldValue            func(context.Context) (*Tags, error)
	predicates          []predicate.Tags
}

var _ ent.Mutation = (*TagsMutation)(nil)

// tagsOption allows management of the mutation configuration using functional options.
type tagsOption func(*TagsMutation)

// newTagsMutation creates new mutation for the Tags entity.
func newTagsMutation(c config, op Op, opts ...tagsOption) *TagsMutation {
	m := &TagsMutation{
		config:        c,
		op:            op,
		typ:           TypeTags,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagsID sets the ID field of the mutation.
func withTagsID(id int) tagsOption {
	return func(m *TagsMutation) {
		var (
			err   error
			once  sync.Once
			value *Tags
		)
		m.oldValue = func(ctx context.Context) (*Tags, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tags.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTags sets the old Tags of the mutation.
func withTags(node *Tags) tagsOption {
	return func(m *TagsMutation) {
		m.oldValue = func(context.Context) (*Tags, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *TagsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagsMutation) ResetName() {
	m.name = nil
}

// SetIsGenerationTag sets the "is_generation_tag" field.
func (m *TagsMutation) SetIsGenerationTag(b bool) {
	m.is_generation_tag = &b
}

// IsGenerationTag returns the value of the "is_generation_tag" field in the mutation.
func (m *TagsMutation) IsGenerationTag() (r bool, exists bool) {
	v := m.is_generation_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGenerationTag returns the old "is_generation_tag" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldIsGenerationTag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsGenerationTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsGenerationTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGenerationTag: %w", err)
	}
	return oldValue.IsGenerationTag, nil
}

// ResetIsGenerationTag resets all changes to the "is_generation_tag" field.
func (m *TagsMutation) ResetIsGenerationTag() {
	m.is_generation_tag = nil
}

// SetIsSeasonTag sets the "is_season_tag" field.
func (m *TagsMutation) SetIsSeasonTag(b bool) {
	m.is_season_tag = &b
}

// IsSeasonTag returns the value of the "is_season_tag" field in the mutation.
func (m *TagsMutation) IsSeasonTag() (r bool, exists bool) {
	v := m.is_season_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSeasonTag returns the old "is_season_tag" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldIsSeasonTag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsSeasonTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsSeasonTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSeasonTag: %w", err)
	}
	return oldValue.IsSeasonTag, nil
}

// ResetIsSeasonTag resets all changes to the "is_season_tag" field.
func (m *TagsMutation) ResetIsSeasonTag() {
	m.is_season_tag = nil
}

// AddTagToPartyIDs adds the "tag_to_party" edge to the Party entity by ids.
func (m *TagsMutation) AddTagToPartyIDs(ids ...int) {
	if m.tag_to_party == nil {
		m.tag_to_party = make(map[int]struct{})
	}
	for i := range ids {
		m.tag_to_party[ids[i]] = struct{}{}
	}
}

// ClearTagToParty clears the "tag_to_party" edge to the Party entity.
func (m *TagsMutation) ClearTagToParty() {
	m.clearedtag_to_party = true
}

// TagToPartyCleared reports if the "tag_to_party" edge to the Party entity was cleared.
func (m *TagsMutation) TagToPartyCleared() bool {
	return m.clearedtag_to_party
}

// RemoveTagToPartyIDs removes the "tag_to_party" edge to the Party entity by IDs.
func (m *TagsMutation) RemoveTagToPartyIDs(ids ...int) {
	if m.removedtag_to_party == nil {
		m.removedtag_to_party = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tag_to_party, ids[i])
		m.removedtag_to_party[ids[i]] = struct{}{}
	}
}

// RemovedTagToParty returns the removed IDs of the "tag_to_party" edge to the Party entity.
func (m *TagsMutation) RemovedTagToPartyIDs() (ids []int) {
	for id := range m.removedtag_to_party {
		ids = append(ids, id)
	}
	return
}

// TagToPartyIDs returns the "tag_to_party" edge IDs in the mutation.
func (m *TagsMutation) TagToPartyIDs() (ids []int) {
	for id := range m.tag_to_party {
		ids = append(ids, id)
	}
	return
}

// ResetTagToParty resets all changes to the "tag_to_party" edge.
func (m *TagsMutation) ResetTagToParty() {
	m.tag_to_party = nil
	m.clearedtag_to_party = false
	m.removedtag_to_party = nil
}

// Where appends a list predicates to the TagsMutation builder.
func (m *TagsMutation) Where(ps ...predicate.Tags) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tags).
func (m *TagsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, tags.FieldName)
	}
	if m.is_generation_tag != nil {
		fields = append(fields, tags.FieldIsGenerationTag)
	}
	if m.is_season_tag != nil {
		fields = append(fields, tags.FieldIsSeasonTag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tags.FieldName:
		return m.Name()
	case tags.FieldIsGenerationTag:
		return m.IsGenerationTag()
	case tags.FieldIsSeasonTag:
		return m.IsSeasonTag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tags.FieldName:
		return m.OldName(ctx)
	case tags.FieldIsGenerationTag:
		return m.OldIsGenerationTag(ctx)
	case tags.FieldIsSeasonTag:
		return m.OldIsSeasonTag(ctx)
	}
	return nil, fmt.Errorf("unknown Tags field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tags.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tags.FieldIsGenerationTag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGenerationTag(v)
		return nil
	case tags.FieldIsSeasonTag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSeasonTag(v)
		return nil
	}
	return fmt.Errorf("unknown Tags field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tags numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tags nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagsMutation) ResetField(name string) error {
	switch name {
	case tags.FieldName:
		m.ResetName()
		return nil
	case tags.FieldIsGenerationTag:
		m.ResetIsGenerationTag()
		return nil
	case tags.FieldIsSeasonTag:
		m.ResetIsSeasonTag()
		return nil
	}
	return fmt.Errorf("unknown Tags field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag_to_party != nil {
		edges = append(edges, tags.EdgeTagToParty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tags.EdgeTagToParty:
		ids := make([]ent.Value, 0, len(m.tag_to_party))
		for id := range m.tag_to_party {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag_to_party != nil {
		edges = append(edges, tags.EdgeTagToParty)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tags.EdgeTagToParty:
		ids := make([]ent.Value, 0, len(m.removedtag_to_party))
		for id := range m.removedtag_to_party {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag_to_party {
		edges = append(edges, tags.EdgeTagToParty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagsMutation) EdgeCleared(name string) bool {
	switch name {
	case tags.EdgeTagToParty:
		return m.clearedtag_to_party
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tags unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagsMutation) ResetEdge(name string) error {
	switch name {
	case tags.EdgeTagToParty:
		m.ResetTagToParty()
		return nil
	}
	return fmt.Errorf("unknown Tags edge %s", name)
}

// TrainedPokemonDetailsMutation represents an operation that mutates the TrainedPokemonDetails nodes in the graph.
type TrainedPokemonDetailsMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	nickname                    *string
	gender                      *property.Gender
	clearedFields               map[string]struct{}
	use_ability                 *int
	cleareduse_ability          bool
	use_held_item               *int
	cleareduse_held_item        bool
	use_move1                   *int
	cleareduse_move1            bool
	use_move2                   *int
	cleareduse_move2            bool
	use_move3                   *int
	cleareduse_move3            bool
	use_move4                   *int
	cleareduse_move4            bool
	training_detail_user        *int
	clearedtraining_detail_user bool
	done                        bool
	oldValue                    func(context.Context) (*TrainedPokemonDetails, error)
	predicates                  []predicate.TrainedPokemonDetails
}

var _ ent.Mutation = (*TrainedPokemonDetailsMutation)(nil)

// trainedpokemondetailsOption allows management of the mutation configuration using functional options.
type trainedpokemondetailsOption func(*TrainedPokemonDetailsMutation)

// newTrainedPokemonDetailsMutation creates new mutation for the TrainedPokemonDetails entity.
func newTrainedPokemonDetailsMutation(c config, op Op, opts ...trainedpokemondetailsOption) *TrainedPokemonDetailsMutation {
	m := &TrainedPokemonDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeTrainedPokemonDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrainedPokemonDetailsID sets the ID field of the mutation.
func withTrainedPokemonDetailsID(id int) trainedpokemondetailsOption {
	return func(m *TrainedPokemonDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *TrainedPokemonDetails
		)
		m.oldValue = func(ctx context.Context) (*TrainedPokemonDetails, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrainedPokemonDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrainedPokemonDetails sets the old TrainedPokemonDetails of the mutation.
func withTrainedPokemonDetails(node *TrainedPokemonDetails) trainedpokemondetailsOption {
	return func(m *TrainedPokemonDetailsMutation) {
		m.oldValue = func(context.Context) (*TrainedPokemonDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrainedPokemonDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrainedPokemonDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrainedPokemonDetailsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *TrainedPokemonDetailsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TrainedPokemonDetailsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TrainedPokemonDetailsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TrainedPokemonDetailsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TrainedPokemonDetailsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TrainedPokemonDetailsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNickname sets the "nickname" field.
func (m *TrainedPokemonDetailsMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *TrainedPokemonDetailsMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *TrainedPokemonDetailsMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[trainedpokemondetails.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[trainedpokemondetails.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *TrainedPokemonDetailsMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, trainedpokemondetails.FieldNickname)
}

// SetGender sets the "gender" field.
func (m *TrainedPokemonDetailsMutation) SetGender(pr property.Gender) {
	m.gender = &pr
}

// Gender returns the value of the "gender" field in the mutation.
func (m *TrainedPokemonDetailsMutation) Gender() (r property.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldGender(ctx context.Context) (v property.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *TrainedPokemonDetailsMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[trainedpokemondetails.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) GenderCleared() bool {
	_, ok := m.clearedFields[trainedpokemondetails.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *TrainedPokemonDetailsMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, trainedpokemondetails.FieldGender)
}

// SetAbilityID sets the "ability_id" field.
func (m *TrainedPokemonDetailsMutation) SetAbilityID(i int) {
	m.use_ability = &i
}

// AbilityID returns the value of the "ability_id" field in the mutation.
func (m *TrainedPokemonDetailsMutation) AbilityID() (r int, exists bool) {
	v := m.use_ability
	if v == nil {
		return
	}
	return *v, true
}

// OldAbilityID returns the old "ability_id" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldAbilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbilityID: %w", err)
	}
	return oldValue.AbilityID, nil
}

// ResetAbilityID resets all changes to the "ability_id" field.
func (m *TrainedPokemonDetailsMutation) ResetAbilityID() {
	m.use_ability = nil
}

// SetHeldItemID sets the "held_item_id" field.
func (m *TrainedPokemonDetailsMutation) SetHeldItemID(i int) {
	m.use_held_item = &i
}

// HeldItemID returns the value of the "held_item_id" field in the mutation.
func (m *TrainedPokemonDetailsMutation) HeldItemID() (r int, exists bool) {
	v := m.use_held_item
	if v == nil {
		return
	}
	return *v, true
}

// OldHeldItemID returns the old "held_item_id" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldHeldItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeldItemID: %w", err)
	}
	return oldValue.HeldItemID, nil
}

// ResetHeldItemID resets all changes to the "held_item_id" field.
func (m *TrainedPokemonDetailsMutation) ResetHeldItemID() {
	m.use_held_item = nil
}

// SetMoveId1 sets the "move_id1" field.
func (m *TrainedPokemonDetailsMutation) SetMoveId1(i int) {
	m.use_move1 = &i
}

// MoveId1 returns the value of the "move_id1" field in the mutation.
func (m *TrainedPokemonDetailsMutation) MoveId1() (r int, exists bool) {
	v := m.use_move1
	if v == nil {
		return
	}
	return *v, true
}

// OldMoveId1 returns the old "move_id1" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldMoveId1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMoveId1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMoveId1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoveId1: %w", err)
	}
	return oldValue.MoveId1, nil
}

// ResetMoveId1 resets all changes to the "move_id1" field.
func (m *TrainedPokemonDetailsMutation) ResetMoveId1() {
	m.use_move1 = nil
}

// SetMoveId2 sets the "move_id2" field.
func (m *TrainedPokemonDetailsMutation) SetMoveId2(i int) {
	m.use_move2 = &i
}

// MoveId2 returns the value of the "move_id2" field in the mutation.
func (m *TrainedPokemonDetailsMutation) MoveId2() (r int, exists bool) {
	v := m.use_move2
	if v == nil {
		return
	}
	return *v, true
}

// OldMoveId2 returns the old "move_id2" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldMoveId2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMoveId2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMoveId2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoveId2: %w", err)
	}
	return oldValue.MoveId2, nil
}

// ClearMoveId2 clears the value of the "move_id2" field.
func (m *TrainedPokemonDetailsMutation) ClearMoveId2() {
	m.use_move2 = nil
	m.clearedFields[trainedpokemondetails.FieldMoveId2] = struct{}{}
}

// MoveId2Cleared returns if the "move_id2" field was cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) MoveId2Cleared() bool {
	_, ok := m.clearedFields[trainedpokemondetails.FieldMoveId2]
	return ok
}

// ResetMoveId2 resets all changes to the "move_id2" field.
func (m *TrainedPokemonDetailsMutation) ResetMoveId2() {
	m.use_move2 = nil
	delete(m.clearedFields, trainedpokemondetails.FieldMoveId2)
}

// SetMoveId3 sets the "move_id3" field.
func (m *TrainedPokemonDetailsMutation) SetMoveId3(i int) {
	m.use_move3 = &i
}

// MoveId3 returns the value of the "move_id3" field in the mutation.
func (m *TrainedPokemonDetailsMutation) MoveId3() (r int, exists bool) {
	v := m.use_move3
	if v == nil {
		return
	}
	return *v, true
}

// OldMoveId3 returns the old "move_id3" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldMoveId3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMoveId3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMoveId3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoveId3: %w", err)
	}
	return oldValue.MoveId3, nil
}

// ClearMoveId3 clears the value of the "move_id3" field.
func (m *TrainedPokemonDetailsMutation) ClearMoveId3() {
	m.use_move3 = nil
	m.clearedFields[trainedpokemondetails.FieldMoveId3] = struct{}{}
}

// MoveId3Cleared returns if the "move_id3" field was cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) MoveId3Cleared() bool {
	_, ok := m.clearedFields[trainedpokemondetails.FieldMoveId3]
	return ok
}

// ResetMoveId3 resets all changes to the "move_id3" field.
func (m *TrainedPokemonDetailsMutation) ResetMoveId3() {
	m.use_move3 = nil
	delete(m.clearedFields, trainedpokemondetails.FieldMoveId3)
}

// SetMoveId4 sets the "move_id4" field.
func (m *TrainedPokemonDetailsMutation) SetMoveId4(i int) {
	m.use_move4 = &i
}

// MoveId4 returns the value of the "move_id4" field in the mutation.
func (m *TrainedPokemonDetailsMutation) MoveId4() (r int, exists bool) {
	v := m.use_move4
	if v == nil {
		return
	}
	return *v, true
}

// OldMoveId4 returns the old "move_id4" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldMoveId4(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMoveId4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMoveId4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoveId4: %w", err)
	}
	return oldValue.MoveId4, nil
}

// ClearMoveId4 clears the value of the "move_id4" field.
func (m *TrainedPokemonDetailsMutation) ClearMoveId4() {
	m.use_move4 = nil
	m.clearedFields[trainedpokemondetails.FieldMoveId4] = struct{}{}
}

// MoveId4Cleared returns if the "move_id4" field was cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) MoveId4Cleared() bool {
	_, ok := m.clearedFields[trainedpokemondetails.FieldMoveId4]
	return ok
}

// ResetMoveId4 resets all changes to the "move_id4" field.
func (m *TrainedPokemonDetailsMutation) ResetMoveId4() {
	m.use_move4 = nil
	delete(m.clearedFields, trainedpokemondetails.FieldMoveId4)
}

// SetUserID sets the "user_id" field.
func (m *TrainedPokemonDetailsMutation) SetUserID(i int) {
	m.training_detail_user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TrainedPokemonDetailsMutation) UserID() (r int, exists bool) {
	v := m.training_detail_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TrainedPokemonDetails entity.
// If the TrainedPokemonDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonDetailsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TrainedPokemonDetailsMutation) ResetUserID() {
	m.training_detail_user = nil
}

// SetUseAbilityID sets the "use_ability" edge to the Abilities entity by id.
func (m *TrainedPokemonDetailsMutation) SetUseAbilityID(id int) {
	m.use_ability = &id
}

// ClearUseAbility clears the "use_ability" edge to the Abilities entity.
func (m *TrainedPokemonDetailsMutation) ClearUseAbility() {
	m.cleareduse_ability = true
}

// UseAbilityCleared reports if the "use_ability" edge to the Abilities entity was cleared.
func (m *TrainedPokemonDetailsMutation) UseAbilityCleared() bool {
	return m.cleareduse_ability
}

// UseAbilityID returns the "use_ability" edge ID in the mutation.
func (m *TrainedPokemonDetailsMutation) UseAbilityID() (id int, exists bool) {
	if m.use_ability != nil {
		return *m.use_ability, true
	}
	return
}

// UseAbilityIDs returns the "use_ability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseAbilityID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonDetailsMutation) UseAbilityIDs() (ids []int) {
	if id := m.use_ability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseAbility resets all changes to the "use_ability" edge.
func (m *TrainedPokemonDetailsMutation) ResetUseAbility() {
	m.use_ability = nil
	m.cleareduse_ability = false
}

// SetUseHeldItemID sets the "use_held_item" edge to the HeldItems entity by id.
func (m *TrainedPokemonDetailsMutation) SetUseHeldItemID(id int) {
	m.use_held_item = &id
}

// ClearUseHeldItem clears the "use_held_item" edge to the HeldItems entity.
func (m *TrainedPokemonDetailsMutation) ClearUseHeldItem() {
	m.cleareduse_held_item = true
}

// UseHeldItemCleared reports if the "use_held_item" edge to the HeldItems entity was cleared.
func (m *TrainedPokemonDetailsMutation) UseHeldItemCleared() bool {
	return m.cleareduse_held_item
}

// UseHeldItemID returns the "use_held_item" edge ID in the mutation.
func (m *TrainedPokemonDetailsMutation) UseHeldItemID() (id int, exists bool) {
	if m.use_held_item != nil {
		return *m.use_held_item, true
	}
	return
}

// UseHeldItemIDs returns the "use_held_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseHeldItemID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonDetailsMutation) UseHeldItemIDs() (ids []int) {
	if id := m.use_held_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseHeldItem resets all changes to the "use_held_item" edge.
func (m *TrainedPokemonDetailsMutation) ResetUseHeldItem() {
	m.use_held_item = nil
	m.cleareduse_held_item = false
}

// SetUseMove1ID sets the "use_move1" edge to the Moves entity by id.
func (m *TrainedPokemonDetailsMutation) SetUseMove1ID(id int) {
	m.use_move1 = &id
}

// ClearUseMove1 clears the "use_move1" edge to the Moves entity.
func (m *TrainedPokemonDetailsMutation) ClearUseMove1() {
	m.cleareduse_move1 = true
}

// UseMove1Cleared reports if the "use_move1" edge to the Moves entity was cleared.
func (m *TrainedPokemonDetailsMutation) UseMove1Cleared() bool {
	return m.cleareduse_move1
}

// UseMove1ID returns the "use_move1" edge ID in the mutation.
func (m *TrainedPokemonDetailsMutation) UseMove1ID() (id int, exists bool) {
	if m.use_move1 != nil {
		return *m.use_move1, true
	}
	return
}

// UseMove1IDs returns the "use_move1" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseMove1ID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonDetailsMutation) UseMove1IDs() (ids []int) {
	if id := m.use_move1; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseMove1 resets all changes to the "use_move1" edge.
func (m *TrainedPokemonDetailsMutation) ResetUseMove1() {
	m.use_move1 = nil
	m.cleareduse_move1 = false
}

// SetUseMove2ID sets the "use_move2" edge to the Moves entity by id.
func (m *TrainedPokemonDetailsMutation) SetUseMove2ID(id int) {
	m.use_move2 = &id
}

// ClearUseMove2 clears the "use_move2" edge to the Moves entity.
func (m *TrainedPokemonDetailsMutation) ClearUseMove2() {
	m.cleareduse_move2 = true
}

// UseMove2Cleared reports if the "use_move2" edge to the Moves entity was cleared.
func (m *TrainedPokemonDetailsMutation) UseMove2Cleared() bool {
	return m.MoveId2Cleared() || m.cleareduse_move2
}

// UseMove2ID returns the "use_move2" edge ID in the mutation.
func (m *TrainedPokemonDetailsMutation) UseMove2ID() (id int, exists bool) {
	if m.use_move2 != nil {
		return *m.use_move2, true
	}
	return
}

// UseMove2IDs returns the "use_move2" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseMove2ID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonDetailsMutation) UseMove2IDs() (ids []int) {
	if id := m.use_move2; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseMove2 resets all changes to the "use_move2" edge.
func (m *TrainedPokemonDetailsMutation) ResetUseMove2() {
	m.use_move2 = nil
	m.cleareduse_move2 = false
}

// SetUseMove3ID sets the "use_move3" edge to the Moves entity by id.
func (m *TrainedPokemonDetailsMutation) SetUseMove3ID(id int) {
	m.use_move3 = &id
}

// ClearUseMove3 clears the "use_move3" edge to the Moves entity.
func (m *TrainedPokemonDetailsMutation) ClearUseMove3() {
	m.cleareduse_move3 = true
}

// UseMove3Cleared reports if the "use_move3" edge to the Moves entity was cleared.
func (m *TrainedPokemonDetailsMutation) UseMove3Cleared() bool {
	return m.MoveId3Cleared() || m.cleareduse_move3
}

// UseMove3ID returns the "use_move3" edge ID in the mutation.
func (m *TrainedPokemonDetailsMutation) UseMove3ID() (id int, exists bool) {
	if m.use_move3 != nil {
		return *m.use_move3, true
	}
	return
}

// UseMove3IDs returns the "use_move3" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseMove3ID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonDetailsMutation) UseMove3IDs() (ids []int) {
	if id := m.use_move3; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseMove3 resets all changes to the "use_move3" edge.
func (m *TrainedPokemonDetailsMutation) ResetUseMove3() {
	m.use_move3 = nil
	m.cleareduse_move3 = false
}

// SetUseMove4ID sets the "use_move4" edge to the Moves entity by id.
func (m *TrainedPokemonDetailsMutation) SetUseMove4ID(id int) {
	m.use_move4 = &id
}

// ClearUseMove4 clears the "use_move4" edge to the Moves entity.
func (m *TrainedPokemonDetailsMutation) ClearUseMove4() {
	m.cleareduse_move4 = true
}

// UseMove4Cleared reports if the "use_move4" edge to the Moves entity was cleared.
func (m *TrainedPokemonDetailsMutation) UseMove4Cleared() bool {
	return m.MoveId4Cleared() || m.cleareduse_move4
}

// UseMove4ID returns the "use_move4" edge ID in the mutation.
func (m *TrainedPokemonDetailsMutation) UseMove4ID() (id int, exists bool) {
	if m.use_move4 != nil {
		return *m.use_move4, true
	}
	return
}

// UseMove4IDs returns the "use_move4" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseMove4ID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonDetailsMutation) UseMove4IDs() (ids []int) {
	if id := m.use_move4; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseMove4 resets all changes to the "use_move4" edge.
func (m *TrainedPokemonDetailsMutation) ResetUseMove4() {
	m.use_move4 = nil
	m.cleareduse_move4 = false
}

// SetTrainingDetailUserID sets the "training_detail_user" edge to the Users entity by id.
func (m *TrainedPokemonDetailsMutation) SetTrainingDetailUserID(id int) {
	m.training_detail_user = &id
}

// ClearTrainingDetailUser clears the "training_detail_user" edge to the Users entity.
func (m *TrainedPokemonDetailsMutation) ClearTrainingDetailUser() {
	m.clearedtraining_detail_user = true
}

// TrainingDetailUserCleared reports if the "training_detail_user" edge to the Users entity was cleared.
func (m *TrainedPokemonDetailsMutation) TrainingDetailUserCleared() bool {
	return m.clearedtraining_detail_user
}

// TrainingDetailUserID returns the "training_detail_user" edge ID in the mutation.
func (m *TrainedPokemonDetailsMutation) TrainingDetailUserID() (id int, exists bool) {
	if m.training_detail_user != nil {
		return *m.training_detail_user, true
	}
	return
}

// TrainingDetailUserIDs returns the "training_detail_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrainingDetailUserID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonDetailsMutation) TrainingDetailUserIDs() (ids []int) {
	if id := m.training_detail_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrainingDetailUser resets all changes to the "training_detail_user" edge.
func (m *TrainedPokemonDetailsMutation) ResetTrainingDetailUser() {
	m.training_detail_user = nil
	m.clearedtraining_detail_user = false
}

// Where appends a list predicates to the TrainedPokemonDetailsMutation builder.
func (m *TrainedPokemonDetailsMutation) Where(ps ...predicate.TrainedPokemonDetails) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TrainedPokemonDetailsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TrainedPokemonDetails).
func (m *TrainedPokemonDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrainedPokemonDetailsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, trainedpokemondetails.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, trainedpokemondetails.FieldUpdateTime)
	}
	if m.nickname != nil {
		fields = append(fields, trainedpokemondetails.FieldNickname)
	}
	if m.gender != nil {
		fields = append(fields, trainedpokemondetails.FieldGender)
	}
	if m.use_ability != nil {
		fields = append(fields, trainedpokemondetails.FieldAbilityID)
	}
	if m.use_held_item != nil {
		fields = append(fields, trainedpokemondetails.FieldHeldItemID)
	}
	if m.use_move1 != nil {
		fields = append(fields, trainedpokemondetails.FieldMoveId1)
	}
	if m.use_move2 != nil {
		fields = append(fields, trainedpokemondetails.FieldMoveId2)
	}
	if m.use_move3 != nil {
		fields = append(fields, trainedpokemondetails.FieldMoveId3)
	}
	if m.use_move4 != nil {
		fields = append(fields, trainedpokemondetails.FieldMoveId4)
	}
	if m.training_detail_user != nil {
		fields = append(fields, trainedpokemondetails.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrainedPokemonDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trainedpokemondetails.FieldCreateTime:
		return m.CreateTime()
	case trainedpokemondetails.FieldUpdateTime:
		return m.UpdateTime()
	case trainedpokemondetails.FieldNickname:
		return m.Nickname()
	case trainedpokemondetails.FieldGender:
		return m.Gender()
	case trainedpokemondetails.FieldAbilityID:
		return m.AbilityID()
	case trainedpokemondetails.FieldHeldItemID:
		return m.HeldItemID()
	case trainedpokemondetails.FieldMoveId1:
		return m.MoveId1()
	case trainedpokemondetails.FieldMoveId2:
		return m.MoveId2()
	case trainedpokemondetails.FieldMoveId3:
		return m.MoveId3()
	case trainedpokemondetails.FieldMoveId4:
		return m.MoveId4()
	case trainedpokemondetails.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrainedPokemonDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trainedpokemondetails.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case trainedpokemondetails.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case trainedpokemondetails.FieldNickname:
		return m.OldNickname(ctx)
	case trainedpokemondetails.FieldGender:
		return m.OldGender(ctx)
	case trainedpokemondetails.FieldAbilityID:
		return m.OldAbilityID(ctx)
	case trainedpokemondetails.FieldHeldItemID:
		return m.OldHeldItemID(ctx)
	case trainedpokemondetails.FieldMoveId1:
		return m.OldMoveId1(ctx)
	case trainedpokemondetails.FieldMoveId2:
		return m.OldMoveId2(ctx)
	case trainedpokemondetails.FieldMoveId3:
		return m.OldMoveId3(ctx)
	case trainedpokemondetails.FieldMoveId4:
		return m.OldMoveId4(ctx)
	case trainedpokemondetails.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown TrainedPokemonDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainedPokemonDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trainedpokemondetails.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case trainedpokemondetails.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case trainedpokemondetails.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case trainedpokemondetails.FieldGender:
		v, ok := value.(property.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case trainedpokemondetails.FieldAbilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbilityID(v)
		return nil
	case trainedpokemondetails.FieldHeldItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeldItemID(v)
		return nil
	case trainedpokemondetails.FieldMoveId1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoveId1(v)
		return nil
	case trainedpokemondetails.FieldMoveId2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoveId2(v)
		return nil
	case trainedpokemondetails.FieldMoveId3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoveId3(v)
		return nil
	case trainedpokemondetails.FieldMoveId4:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoveId4(v)
		return nil
	case trainedpokemondetails.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemonDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrainedPokemonDetailsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrainedPokemonDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainedPokemonDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrainedPokemonDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrainedPokemonDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trainedpokemondetails.FieldNickname) {
		fields = append(fields, trainedpokemondetails.FieldNickname)
	}
	if m.FieldCleared(trainedpokemondetails.FieldGender) {
		fields = append(fields, trainedpokemondetails.FieldGender)
	}
	if m.FieldCleared(trainedpokemondetails.FieldMoveId2) {
		fields = append(fields, trainedpokemondetails.FieldMoveId2)
	}
	if m.FieldCleared(trainedpokemondetails.FieldMoveId3) {
		fields = append(fields, trainedpokemondetails.FieldMoveId3)
	}
	if m.FieldCleared(trainedpokemondetails.FieldMoveId4) {
		fields = append(fields, trainedpokemondetails.FieldMoveId4)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrainedPokemonDetailsMutation) ClearField(name string) error {
	switch name {
	case trainedpokemondetails.FieldNickname:
		m.ClearNickname()
		return nil
	case trainedpokemondetails.FieldGender:
		m.ClearGender()
		return nil
	case trainedpokemondetails.FieldMoveId2:
		m.ClearMoveId2()
		return nil
	case trainedpokemondetails.FieldMoveId3:
		m.ClearMoveId3()
		return nil
	case trainedpokemondetails.FieldMoveId4:
		m.ClearMoveId4()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemonDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrainedPokemonDetailsMutation) ResetField(name string) error {
	switch name {
	case trainedpokemondetails.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case trainedpokemondetails.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case trainedpokemondetails.FieldNickname:
		m.ResetNickname()
		return nil
	case trainedpokemondetails.FieldGender:
		m.ResetGender()
		return nil
	case trainedpokemondetails.FieldAbilityID:
		m.ResetAbilityID()
		return nil
	case trainedpokemondetails.FieldHeldItemID:
		m.ResetHeldItemID()
		return nil
	case trainedpokemondetails.FieldMoveId1:
		m.ResetMoveId1()
		return nil
	case trainedpokemondetails.FieldMoveId2:
		m.ResetMoveId2()
		return nil
	case trainedpokemondetails.FieldMoveId3:
		m.ResetMoveId3()
		return nil
	case trainedpokemondetails.FieldMoveId4:
		m.ResetMoveId4()
		return nil
	case trainedpokemondetails.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemonDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrainedPokemonDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.use_ability != nil {
		edges = append(edges, trainedpokemondetails.EdgeUseAbility)
	}
	if m.use_held_item != nil {
		edges = append(edges, trainedpokemondetails.EdgeUseHeldItem)
	}
	if m.use_move1 != nil {
		edges = append(edges, trainedpokemondetails.EdgeUseMove1)
	}
	if m.use_move2 != nil {
		edges = append(edges, trainedpokemondetails.EdgeUseMove2)
	}
	if m.use_move3 != nil {
		edges = append(edges, trainedpokemondetails.EdgeUseMove3)
	}
	if m.use_move4 != nil {
		edges = append(edges, trainedpokemondetails.EdgeUseMove4)
	}
	if m.training_detail_user != nil {
		edges = append(edges, trainedpokemondetails.EdgeTrainingDetailUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrainedPokemonDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trainedpokemondetails.EdgeUseAbility:
		if id := m.use_ability; id != nil {
			return []ent.Value{*id}
		}
	case trainedpokemondetails.EdgeUseHeldItem:
		if id := m.use_held_item; id != nil {
			return []ent.Value{*id}
		}
	case trainedpokemondetails.EdgeUseMove1:
		if id := m.use_move1; id != nil {
			return []ent.Value{*id}
		}
	case trainedpokemondetails.EdgeUseMove2:
		if id := m.use_move2; id != nil {
			return []ent.Value{*id}
		}
	case trainedpokemondetails.EdgeUseMove3:
		if id := m.use_move3; id != nil {
			return []ent.Value{*id}
		}
	case trainedpokemondetails.EdgeUseMove4:
		if id := m.use_move4; id != nil {
			return []ent.Value{*id}
		}
	case trainedpokemondetails.EdgeTrainingDetailUser:
		if id := m.training_detail_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrainedPokemonDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrainedPokemonDetailsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareduse_ability {
		edges = append(edges, trainedpokemondetails.EdgeUseAbility)
	}
	if m.cleareduse_held_item {
		edges = append(edges, trainedpokemondetails.EdgeUseHeldItem)
	}
	if m.cleareduse_move1 {
		edges = append(edges, trainedpokemondetails.EdgeUseMove1)
	}
	if m.cleareduse_move2 {
		edges = append(edges, trainedpokemondetails.EdgeUseMove2)
	}
	if m.cleareduse_move3 {
		edges = append(edges, trainedpokemondetails.EdgeUseMove3)
	}
	if m.cleareduse_move4 {
		edges = append(edges, trainedpokemondetails.EdgeUseMove4)
	}
	if m.clearedtraining_detail_user {
		edges = append(edges, trainedpokemondetails.EdgeTrainingDetailUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrainedPokemonDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case trainedpokemondetails.EdgeUseAbility:
		return m.cleareduse_ability
	case trainedpokemondetails.EdgeUseHeldItem:
		return m.cleareduse_held_item
	case trainedpokemondetails.EdgeUseMove1:
		return m.cleareduse_move1
	case trainedpokemondetails.EdgeUseMove2:
		return m.cleareduse_move2
	case trainedpokemondetails.EdgeUseMove3:
		return m.cleareduse_move3
	case trainedpokemondetails.EdgeUseMove4:
		return m.cleareduse_move4
	case trainedpokemondetails.EdgeTrainingDetailUser:
		return m.clearedtraining_detail_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrainedPokemonDetailsMutation) ClearEdge(name string) error {
	switch name {
	case trainedpokemondetails.EdgeUseAbility:
		m.ClearUseAbility()
		return nil
	case trainedpokemondetails.EdgeUseHeldItem:
		m.ClearUseHeldItem()
		return nil
	case trainedpokemondetails.EdgeUseMove1:
		m.ClearUseMove1()
		return nil
	case trainedpokemondetails.EdgeUseMove2:
		m.ClearUseMove2()
		return nil
	case trainedpokemondetails.EdgeUseMove3:
		m.ClearUseMove3()
		return nil
	case trainedpokemondetails.EdgeUseMove4:
		m.ClearUseMove4()
		return nil
	case trainedpokemondetails.EdgeTrainingDetailUser:
		m.ClearTrainingDetailUser()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemonDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrainedPokemonDetailsMutation) ResetEdge(name string) error {
	switch name {
	case trainedpokemondetails.EdgeUseAbility:
		m.ResetUseAbility()
		return nil
	case trainedpokemondetails.EdgeUseHeldItem:
		m.ResetUseHeldItem()
		return nil
	case trainedpokemondetails.EdgeUseMove1:
		m.ResetUseMove1()
		return nil
	case trainedpokemondetails.EdgeUseMove2:
		m.ResetUseMove2()
		return nil
	case trainedpokemondetails.EdgeUseMove3:
		m.ResetUseMove3()
		return nil
	case trainedpokemondetails.EdgeUseMove4:
		m.ResetUseMove4()
		return nil
	case trainedpokemondetails.EdgeTrainingDetailUser:
		m.ResetTrainingDetailUser()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemonDetails edge %s", name)
}

// TrainedPokemonsMutation represents an operation that mutates the TrainedPokemons nodes in the graph.
type TrainedPokemonsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	nature               *property.Nature
	effort_value_h       *int
	addeffort_value_h    *int
	effort_value_a       *int
	addeffort_value_a    *int
	effort_value_b       *int
	addeffort_value_b    *int
	effort_value_c       *int
	addeffort_value_c    *int
	effort_value_d       *int
	addeffort_value_d    *int
	effort_value_s       *int
	addeffort_value_s    *int
	clearedFields        map[string]struct{}
	use_pokemon          *int
	cleareduse_pokemon   bool
	training_user        *int
	clearedtraining_user bool
	done                 bool
	oldValue             func(context.Context) (*TrainedPokemons, error)
	predicates           []predicate.TrainedPokemons
}

var _ ent.Mutation = (*TrainedPokemonsMutation)(nil)

// trainedpokemonsOption allows management of the mutation configuration using functional options.
type trainedpokemonsOption func(*TrainedPokemonsMutation)

// newTrainedPokemonsMutation creates new mutation for the TrainedPokemons entity.
func newTrainedPokemonsMutation(c config, op Op, opts ...trainedpokemonsOption) *TrainedPokemonsMutation {
	m := &TrainedPokemonsMutation{
		config:        c,
		op:            op,
		typ:           TypeTrainedPokemons,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrainedPokemonsID sets the ID field of the mutation.
func withTrainedPokemonsID(id int) trainedpokemonsOption {
	return func(m *TrainedPokemonsMutation) {
		var (
			err   error
			once  sync.Once
			value *TrainedPokemons
		)
		m.oldValue = func(ctx context.Context) (*TrainedPokemons, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrainedPokemons.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrainedPokemons sets the old TrainedPokemons of the mutation.
func withTrainedPokemons(node *TrainedPokemons) trainedpokemonsOption {
	return func(m *TrainedPokemonsMutation) {
		m.oldValue = func(context.Context) (*TrainedPokemons, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrainedPokemonsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrainedPokemonsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrainedPokemonsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *TrainedPokemonsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TrainedPokemonsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TrainedPokemonsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TrainedPokemonsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TrainedPokemonsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TrainedPokemonsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPokemonID sets the "pokemon_id" field.
func (m *TrainedPokemonsMutation) SetPokemonID(i int) {
	m.use_pokemon = &i
}

// PokemonID returns the value of the "pokemon_id" field in the mutation.
func (m *TrainedPokemonsMutation) PokemonID() (r int, exists bool) {
	v := m.use_pokemon
	if v == nil {
		return
	}
	return *v, true
}

// OldPokemonID returns the old "pokemon_id" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldPokemonID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPokemonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPokemonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPokemonID: %w", err)
	}
	return oldValue.PokemonID, nil
}

// ResetPokemonID resets all changes to the "pokemon_id" field.
func (m *TrainedPokemonsMutation) ResetPokemonID() {
	m.use_pokemon = nil
}

// SetCreateUserID sets the "create_user_id" field.
func (m *TrainedPokemonsMutation) SetCreateUserID(i int) {
	m.training_user = &i
}

// CreateUserID returns the value of the "create_user_id" field in the mutation.
func (m *TrainedPokemonsMutation) CreateUserID() (r int, exists bool) {
	v := m.training_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUserID returns the old "create_user_id" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldCreateUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUserID: %w", err)
	}
	return oldValue.CreateUserID, nil
}

// ClearCreateUserID clears the value of the "create_user_id" field.
func (m *TrainedPokemonsMutation) ClearCreateUserID() {
	m.training_user = nil
	m.clearedFields[trainedpokemons.FieldCreateUserID] = struct{}{}
}

// CreateUserIDCleared returns if the "create_user_id" field was cleared in this mutation.
func (m *TrainedPokemonsMutation) CreateUserIDCleared() bool {
	_, ok := m.clearedFields[trainedpokemons.FieldCreateUserID]
	return ok
}

// ResetCreateUserID resets all changes to the "create_user_id" field.
func (m *TrainedPokemonsMutation) ResetCreateUserID() {
	m.training_user = nil
	delete(m.clearedFields, trainedpokemons.FieldCreateUserID)
}

// SetNature sets the "nature" field.
func (m *TrainedPokemonsMutation) SetNature(pr property.Nature) {
	m.nature = &pr
}

// Nature returns the value of the "nature" field in the mutation.
func (m *TrainedPokemonsMutation) Nature() (r property.Nature, exists bool) {
	v := m.nature
	if v == nil {
		return
	}
	return *v, true
}

// OldNature returns the old "nature" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldNature(ctx context.Context) (v property.Nature, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNature: %w", err)
	}
	return oldValue.Nature, nil
}

// ResetNature resets all changes to the "nature" field.
func (m *TrainedPokemonsMutation) ResetNature() {
	m.nature = nil
}

// SetEffortValueH sets the "effort_value_h" field.
func (m *TrainedPokemonsMutation) SetEffortValueH(i int) {
	m.effort_value_h = &i
	m.addeffort_value_h = nil
}

// EffortValueH returns the value of the "effort_value_h" field in the mutation.
func (m *TrainedPokemonsMutation) EffortValueH() (r int, exists bool) {
	v := m.effort_value_h
	if v == nil {
		return
	}
	return *v, true
}

// OldEffortValueH returns the old "effort_value_h" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldEffortValueH(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEffortValueH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEffortValueH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffortValueH: %w", err)
	}
	return oldValue.EffortValueH, nil
}

// AddEffortValueH adds i to the "effort_value_h" field.
func (m *TrainedPokemonsMutation) AddEffortValueH(i int) {
	if m.addeffort_value_h != nil {
		*m.addeffort_value_h += i
	} else {
		m.addeffort_value_h = &i
	}
}

// AddedEffortValueH returns the value that was added to the "effort_value_h" field in this mutation.
func (m *TrainedPokemonsMutation) AddedEffortValueH() (r int, exists bool) {
	v := m.addeffort_value_h
	if v == nil {
		return
	}
	return *v, true
}

// ResetEffortValueH resets all changes to the "effort_value_h" field.
func (m *TrainedPokemonsMutation) ResetEffortValueH() {
	m.effort_value_h = nil
	m.addeffort_value_h = nil
}

// SetEffortValueA sets the "effort_value_a" field.
func (m *TrainedPokemonsMutation) SetEffortValueA(i int) {
	m.effort_value_a = &i
	m.addeffort_value_a = nil
}

// EffortValueA returns the value of the "effort_value_a" field in the mutation.
func (m *TrainedPokemonsMutation) EffortValueA() (r int, exists bool) {
	v := m.effort_value_a
	if v == nil {
		return
	}
	return *v, true
}

// OldEffortValueA returns the old "effort_value_a" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldEffortValueA(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEffortValueA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEffortValueA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffortValueA: %w", err)
	}
	return oldValue.EffortValueA, nil
}

// AddEffortValueA adds i to the "effort_value_a" field.
func (m *TrainedPokemonsMutation) AddEffortValueA(i int) {
	if m.addeffort_value_a != nil {
		*m.addeffort_value_a += i
	} else {
		m.addeffort_value_a = &i
	}
}

// AddedEffortValueA returns the value that was added to the "effort_value_a" field in this mutation.
func (m *TrainedPokemonsMutation) AddedEffortValueA() (r int, exists bool) {
	v := m.addeffort_value_a
	if v == nil {
		return
	}
	return *v, true
}

// ResetEffortValueA resets all changes to the "effort_value_a" field.
func (m *TrainedPokemonsMutation) ResetEffortValueA() {
	m.effort_value_a = nil
	m.addeffort_value_a = nil
}

// SetEffortValueB sets the "effort_value_b" field.
func (m *TrainedPokemonsMutation) SetEffortValueB(i int) {
	m.effort_value_b = &i
	m.addeffort_value_b = nil
}

// EffortValueB returns the value of the "effort_value_b" field in the mutation.
func (m *TrainedPokemonsMutation) EffortValueB() (r int, exists bool) {
	v := m.effort_value_b
	if v == nil {
		return
	}
	return *v, true
}

// OldEffortValueB returns the old "effort_value_b" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldEffortValueB(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEffortValueB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEffortValueB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffortValueB: %w", err)
	}
	return oldValue.EffortValueB, nil
}

// AddEffortValueB adds i to the "effort_value_b" field.
func (m *TrainedPokemonsMutation) AddEffortValueB(i int) {
	if m.addeffort_value_b != nil {
		*m.addeffort_value_b += i
	} else {
		m.addeffort_value_b = &i
	}
}

// AddedEffortValueB returns the value that was added to the "effort_value_b" field in this mutation.
func (m *TrainedPokemonsMutation) AddedEffortValueB() (r int, exists bool) {
	v := m.addeffort_value_b
	if v == nil {
		return
	}
	return *v, true
}

// ResetEffortValueB resets all changes to the "effort_value_b" field.
func (m *TrainedPokemonsMutation) ResetEffortValueB() {
	m.effort_value_b = nil
	m.addeffort_value_b = nil
}

// SetEffortValueC sets the "effort_value_c" field.
func (m *TrainedPokemonsMutation) SetEffortValueC(i int) {
	m.effort_value_c = &i
	m.addeffort_value_c = nil
}

// EffortValueC returns the value of the "effort_value_c" field in the mutation.
func (m *TrainedPokemonsMutation) EffortValueC() (r int, exists bool) {
	v := m.effort_value_c
	if v == nil {
		return
	}
	return *v, true
}

// OldEffortValueC returns the old "effort_value_c" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldEffortValueC(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEffortValueC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEffortValueC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffortValueC: %w", err)
	}
	return oldValue.EffortValueC, nil
}

// AddEffortValueC adds i to the "effort_value_c" field.
func (m *TrainedPokemonsMutation) AddEffortValueC(i int) {
	if m.addeffort_value_c != nil {
		*m.addeffort_value_c += i
	} else {
		m.addeffort_value_c = &i
	}
}

// AddedEffortValueC returns the value that was added to the "effort_value_c" field in this mutation.
func (m *TrainedPokemonsMutation) AddedEffortValueC() (r int, exists bool) {
	v := m.addeffort_value_c
	if v == nil {
		return
	}
	return *v, true
}

// ResetEffortValueC resets all changes to the "effort_value_c" field.
func (m *TrainedPokemonsMutation) ResetEffortValueC() {
	m.effort_value_c = nil
	m.addeffort_value_c = nil
}

// SetEffortValueD sets the "effort_value_d" field.
func (m *TrainedPokemonsMutation) SetEffortValueD(i int) {
	m.effort_value_d = &i
	m.addeffort_value_d = nil
}

// EffortValueD returns the value of the "effort_value_d" field in the mutation.
func (m *TrainedPokemonsMutation) EffortValueD() (r int, exists bool) {
	v := m.effort_value_d
	if v == nil {
		return
	}
	return *v, true
}

// OldEffortValueD returns the old "effort_value_d" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldEffortValueD(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEffortValueD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEffortValueD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffortValueD: %w", err)
	}
	return oldValue.EffortValueD, nil
}

// AddEffortValueD adds i to the "effort_value_d" field.
func (m *TrainedPokemonsMutation) AddEffortValueD(i int) {
	if m.addeffort_value_d != nil {
		*m.addeffort_value_d += i
	} else {
		m.addeffort_value_d = &i
	}
}

// AddedEffortValueD returns the value that was added to the "effort_value_d" field in this mutation.
func (m *TrainedPokemonsMutation) AddedEffortValueD() (r int, exists bool) {
	v := m.addeffort_value_d
	if v == nil {
		return
	}
	return *v, true
}

// ResetEffortValueD resets all changes to the "effort_value_d" field.
func (m *TrainedPokemonsMutation) ResetEffortValueD() {
	m.effort_value_d = nil
	m.addeffort_value_d = nil
}

// SetEffortValueS sets the "effort_value_s" field.
func (m *TrainedPokemonsMutation) SetEffortValueS(i int) {
	m.effort_value_s = &i
	m.addeffort_value_s = nil
}

// EffortValueS returns the value of the "effort_value_s" field in the mutation.
func (m *TrainedPokemonsMutation) EffortValueS() (r int, exists bool) {
	v := m.effort_value_s
	if v == nil {
		return
	}
	return *v, true
}

// OldEffortValueS returns the old "effort_value_s" field's value of the TrainedPokemons entity.
// If the TrainedPokemons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainedPokemonsMutation) OldEffortValueS(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEffortValueS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEffortValueS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffortValueS: %w", err)
	}
	return oldValue.EffortValueS, nil
}

// AddEffortValueS adds i to the "effort_value_s" field.
func (m *TrainedPokemonsMutation) AddEffortValueS(i int) {
	if m.addeffort_value_s != nil {
		*m.addeffort_value_s += i
	} else {
		m.addeffort_value_s = &i
	}
}

// AddedEffortValueS returns the value that was added to the "effort_value_s" field in this mutation.
func (m *TrainedPokemonsMutation) AddedEffortValueS() (r int, exists bool) {
	v := m.addeffort_value_s
	if v == nil {
		return
	}
	return *v, true
}

// ResetEffortValueS resets all changes to the "effort_value_s" field.
func (m *TrainedPokemonsMutation) ResetEffortValueS() {
	m.effort_value_s = nil
	m.addeffort_value_s = nil
}

// SetUsePokemonID sets the "use_pokemon" edge to the Pokemons entity by id.
func (m *TrainedPokemonsMutation) SetUsePokemonID(id int) {
	m.use_pokemon = &id
}

// ClearUsePokemon clears the "use_pokemon" edge to the Pokemons entity.
func (m *TrainedPokemonsMutation) ClearUsePokemon() {
	m.cleareduse_pokemon = true
}

// UsePokemonCleared reports if the "use_pokemon" edge to the Pokemons entity was cleared.
func (m *TrainedPokemonsMutation) UsePokemonCleared() bool {
	return m.cleareduse_pokemon
}

// UsePokemonID returns the "use_pokemon" edge ID in the mutation.
func (m *TrainedPokemonsMutation) UsePokemonID() (id int, exists bool) {
	if m.use_pokemon != nil {
		return *m.use_pokemon, true
	}
	return
}

// UsePokemonIDs returns the "use_pokemon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsePokemonID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonsMutation) UsePokemonIDs() (ids []int) {
	if id := m.use_pokemon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsePokemon resets all changes to the "use_pokemon" edge.
func (m *TrainedPokemonsMutation) ResetUsePokemon() {
	m.use_pokemon = nil
	m.cleareduse_pokemon = false
}

// SetTrainingUserID sets the "training_user" edge to the Users entity by id.
func (m *TrainedPokemonsMutation) SetTrainingUserID(id int) {
	m.training_user = &id
}

// ClearTrainingUser clears the "training_user" edge to the Users entity.
func (m *TrainedPokemonsMutation) ClearTrainingUser() {
	m.clearedtraining_user = true
}

// TrainingUserCleared reports if the "training_user" edge to the Users entity was cleared.
func (m *TrainedPokemonsMutation) TrainingUserCleared() bool {
	return m.CreateUserIDCleared() || m.clearedtraining_user
}

// TrainingUserID returns the "training_user" edge ID in the mutation.
func (m *TrainedPokemonsMutation) TrainingUserID() (id int, exists bool) {
	if m.training_user != nil {
		return *m.training_user, true
	}
	return
}

// TrainingUserIDs returns the "training_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrainingUserID instead. It exists only for internal usage by the builders.
func (m *TrainedPokemonsMutation) TrainingUserIDs() (ids []int) {
	if id := m.training_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrainingUser resets all changes to the "training_user" edge.
func (m *TrainedPokemonsMutation) ResetTrainingUser() {
	m.training_user = nil
	m.clearedtraining_user = false
}

// Where appends a list predicates to the TrainedPokemonsMutation builder.
func (m *TrainedPokemonsMutation) Where(ps ...predicate.TrainedPokemons) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TrainedPokemonsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TrainedPokemons).
func (m *TrainedPokemonsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrainedPokemonsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, trainedpokemons.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, trainedpokemons.FieldUpdateTime)
	}
	if m.use_pokemon != nil {
		fields = append(fields, trainedpokemons.FieldPokemonID)
	}
	if m.training_user != nil {
		fields = append(fields, trainedpokemons.FieldCreateUserID)
	}
	if m.nature != nil {
		fields = append(fields, trainedpokemons.FieldNature)
	}
	if m.effort_value_h != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueH)
	}
	if m.effort_value_a != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueA)
	}
	if m.effort_value_b != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueB)
	}
	if m.effort_value_c != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueC)
	}
	if m.effort_value_d != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueD)
	}
	if m.effort_value_s != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrainedPokemonsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trainedpokemons.FieldCreateTime:
		return m.CreateTime()
	case trainedpokemons.FieldUpdateTime:
		return m.UpdateTime()
	case trainedpokemons.FieldPokemonID:
		return m.PokemonID()
	case trainedpokemons.FieldCreateUserID:
		return m.CreateUserID()
	case trainedpokemons.FieldNature:
		return m.Nature()
	case trainedpokemons.FieldEffortValueH:
		return m.EffortValueH()
	case trainedpokemons.FieldEffortValueA:
		return m.EffortValueA()
	case trainedpokemons.FieldEffortValueB:
		return m.EffortValueB()
	case trainedpokemons.FieldEffortValueC:
		return m.EffortValueC()
	case trainedpokemons.FieldEffortValueD:
		return m.EffortValueD()
	case trainedpokemons.FieldEffortValueS:
		return m.EffortValueS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrainedPokemonsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trainedpokemons.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case trainedpokemons.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case trainedpokemons.FieldPokemonID:
		return m.OldPokemonID(ctx)
	case trainedpokemons.FieldCreateUserID:
		return m.OldCreateUserID(ctx)
	case trainedpokemons.FieldNature:
		return m.OldNature(ctx)
	case trainedpokemons.FieldEffortValueH:
		return m.OldEffortValueH(ctx)
	case trainedpokemons.FieldEffortValueA:
		return m.OldEffortValueA(ctx)
	case trainedpokemons.FieldEffortValueB:
		return m.OldEffortValueB(ctx)
	case trainedpokemons.FieldEffortValueC:
		return m.OldEffortValueC(ctx)
	case trainedpokemons.FieldEffortValueD:
		return m.OldEffortValueD(ctx)
	case trainedpokemons.FieldEffortValueS:
		return m.OldEffortValueS(ctx)
	}
	return nil, fmt.Errorf("unknown TrainedPokemons field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainedPokemonsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trainedpokemons.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case trainedpokemons.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case trainedpokemons.FieldPokemonID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPokemonID(v)
		return nil
	case trainedpokemons.FieldCreateUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUserID(v)
		return nil
	case trainedpokemons.FieldNature:
		v, ok := value.(property.Nature)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNature(v)
		return nil
	case trainedpokemons.FieldEffortValueH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffortValueH(v)
		return nil
	case trainedpokemons.FieldEffortValueA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffortValueA(v)
		return nil
	case trainedpokemons.FieldEffortValueB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffortValueB(v)
		return nil
	case trainedpokemons.FieldEffortValueC:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffortValueC(v)
		return nil
	case trainedpokemons.FieldEffortValueD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffortValueD(v)
		return nil
	case trainedpokemons.FieldEffortValueS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffortValueS(v)
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemons field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrainedPokemonsMutation) AddedFields() []string {
	var fields []string
	if m.addeffort_value_h != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueH)
	}
	if m.addeffort_value_a != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueA)
	}
	if m.addeffort_value_b != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueB)
	}
	if m.addeffort_value_c != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueC)
	}
	if m.addeffort_value_d != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueD)
	}
	if m.addeffort_value_s != nil {
		fields = append(fields, trainedpokemons.FieldEffortValueS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrainedPokemonsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trainedpokemons.FieldEffortValueH:
		return m.AddedEffortValueH()
	case trainedpokemons.FieldEffortValueA:
		return m.AddedEffortValueA()
	case trainedpokemons.FieldEffortValueB:
		return m.AddedEffortValueB()
	case trainedpokemons.FieldEffortValueC:
		return m.AddedEffortValueC()
	case trainedpokemons.FieldEffortValueD:
		return m.AddedEffortValueD()
	case trainedpokemons.FieldEffortValueS:
		return m.AddedEffortValueS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainedPokemonsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trainedpokemons.FieldEffortValueH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffortValueH(v)
		return nil
	case trainedpokemons.FieldEffortValueA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffortValueA(v)
		return nil
	case trainedpokemons.FieldEffortValueB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffortValueB(v)
		return nil
	case trainedpokemons.FieldEffortValueC:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffortValueC(v)
		return nil
	case trainedpokemons.FieldEffortValueD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffortValueD(v)
		return nil
	case trainedpokemons.FieldEffortValueS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffortValueS(v)
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemons numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrainedPokemonsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trainedpokemons.FieldCreateUserID) {
		fields = append(fields, trainedpokemons.FieldCreateUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrainedPokemonsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrainedPokemonsMutation) ClearField(name string) error {
	switch name {
	case trainedpokemons.FieldCreateUserID:
		m.ClearCreateUserID()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemons nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrainedPokemonsMutation) ResetField(name string) error {
	switch name {
	case trainedpokemons.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case trainedpokemons.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case trainedpokemons.FieldPokemonID:
		m.ResetPokemonID()
		return nil
	case trainedpokemons.FieldCreateUserID:
		m.ResetCreateUserID()
		return nil
	case trainedpokemons.FieldNature:
		m.ResetNature()
		return nil
	case trainedpokemons.FieldEffortValueH:
		m.ResetEffortValueH()
		return nil
	case trainedpokemons.FieldEffortValueA:
		m.ResetEffortValueA()
		return nil
	case trainedpokemons.FieldEffortValueB:
		m.ResetEffortValueB()
		return nil
	case trainedpokemons.FieldEffortValueC:
		m.ResetEffortValueC()
		return nil
	case trainedpokemons.FieldEffortValueD:
		m.ResetEffortValueD()
		return nil
	case trainedpokemons.FieldEffortValueS:
		m.ResetEffortValueS()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemons field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrainedPokemonsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.use_pokemon != nil {
		edges = append(edges, trainedpokemons.EdgeUsePokemon)
	}
	if m.training_user != nil {
		edges = append(edges, trainedpokemons.EdgeTrainingUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrainedPokemonsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trainedpokemons.EdgeUsePokemon:
		if id := m.use_pokemon; id != nil {
			return []ent.Value{*id}
		}
	case trainedpokemons.EdgeTrainingUser:
		if id := m.training_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrainedPokemonsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrainedPokemonsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrainedPokemonsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduse_pokemon {
		edges = append(edges, trainedpokemons.EdgeUsePokemon)
	}
	if m.clearedtraining_user {
		edges = append(edges, trainedpokemons.EdgeTrainingUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrainedPokemonsMutation) EdgeCleared(name string) bool {
	switch name {
	case trainedpokemons.EdgeUsePokemon:
		return m.cleareduse_pokemon
	case trainedpokemons.EdgeTrainingUser:
		return m.clearedtraining_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrainedPokemonsMutation) ClearEdge(name string) error {
	switch name {
	case trainedpokemons.EdgeUsePokemon:
		m.ClearUsePokemon()
		return nil
	case trainedpokemons.EdgeTrainingUser:
		m.ClearTrainingUser()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemons unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrainedPokemonsMutation) ResetEdge(name string) error {
	switch name {
	case trainedpokemons.EdgeUsePokemon:
		m.ResetUsePokemon()
		return nil
	case trainedpokemons.EdgeTrainingUser:
		m.ResetTrainingUser()
		return nil
	}
	return fmt.Errorf("unknown TrainedPokemons edge %s", name)
}

// TypeCompatibilityMutation represents an operation that mutates the TypeCompatibility nodes in the graph.
type TypeCompatibilityMutation struct {
	config
	op               Op
	typ              string
	id               *int
	attack_type      *property.Types
	defence_type     *property.Types
	compatibility    *int
	addcompatibility *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TypeCompatibility, error)
	predicates       []predicate.TypeCompatibility
}

var _ ent.Mutation = (*TypeCompatibilityMutation)(nil)

// typecompatibilityOption allows management of the mutation configuration using functional options.
type typecompatibilityOption func(*TypeCompatibilityMutation)

// newTypeCompatibilityMutation creates new mutation for the TypeCompatibility entity.
func newTypeCompatibilityMutation(c config, op Op, opts ...typecompatibilityOption) *TypeCompatibilityMutation {
	m := &TypeCompatibilityMutation{
		config:        c,
		op:            op,
		typ:           TypeTypeCompatibility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypeCompatibilityID sets the ID field of the mutation.
func withTypeCompatibilityID(id int) typecompatibilityOption {
	return func(m *TypeCompatibilityMutation) {
		var (
			err   error
			once  sync.Once
			value *TypeCompatibility
		)
		m.oldValue = func(ctx context.Context) (*TypeCompatibility, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TypeCompatibility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypeCompatibility sets the old TypeCompatibility of the mutation.
func withTypeCompatibility(node *TypeCompatibility) typecompatibilityOption {
	return func(m *TypeCompatibilityMutation) {
		m.oldValue = func(context.Context) (*TypeCompatibility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypeCompatibilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypeCompatibilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TypeCompatibilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAttackType sets the "attack_type" field.
func (m *TypeCompatibilityMutation) SetAttackType(pr property.Types) {
	m.attack_type = &pr
}

// AttackType returns the value of the "attack_type" field in the mutation.
func (m *TypeCompatibilityMutation) AttackType() (r property.Types, exists bool) {
	v := m.attack_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAttackType returns the old "attack_type" field's value of the TypeCompatibility entity.
// If the TypeCompatibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeCompatibilityMutation) OldAttackType(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttackType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttackType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttackType: %w", err)
	}
	return oldValue.AttackType, nil
}

// ResetAttackType resets all changes to the "attack_type" field.
func (m *TypeCompatibilityMutation) ResetAttackType() {
	m.attack_type = nil
}

// SetDefenceType sets the "defence_type" field.
func (m *TypeCompatibilityMutation) SetDefenceType(pr property.Types) {
	m.defence_type = &pr
}

// DefenceType returns the value of the "defence_type" field in the mutation.
func (m *TypeCompatibilityMutation) DefenceType() (r property.Types, exists bool) {
	v := m.defence_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDefenceType returns the old "defence_type" field's value of the TypeCompatibility entity.
// If the TypeCompatibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeCompatibilityMutation) OldDefenceType(ctx context.Context) (v property.Types, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefenceType: %w", err)
	}
	return oldValue.DefenceType, nil
}

// ResetDefenceType resets all changes to the "defence_type" field.
func (m *TypeCompatibilityMutation) ResetDefenceType() {
	m.defence_type = nil
}

// SetCompatibility sets the "compatibility" field.
func (m *TypeCompatibilityMutation) SetCompatibility(i int) {
	m.compatibility = &i
	m.addcompatibility = nil
}

// Compatibility returns the value of the "compatibility" field in the mutation.
func (m *TypeCompatibilityMutation) Compatibility() (r int, exists bool) {
	v := m.compatibility
	if v == nil {
		return
	}
	return *v, true
}

// OldCompatibility returns the old "compatibility" field's value of the TypeCompatibility entity.
// If the TypeCompatibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeCompatibilityMutation) OldCompatibility(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompatibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompatibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompatibility: %w", err)
	}
	return oldValue.Compatibility, nil
}

// AddCompatibility adds i to the "compatibility" field.
func (m *TypeCompatibilityMutation) AddCompatibility(i int) {
	if m.addcompatibility != nil {
		*m.addcompatibility += i
	} else {
		m.addcompatibility = &i
	}
}

// AddedCompatibility returns the value that was added to the "compatibility" field in this mutation.
func (m *TypeCompatibilityMutation) AddedCompatibility() (r int, exists bool) {
	v := m.addcompatibility
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompatibility resets all changes to the "compatibility" field.
func (m *TypeCompatibilityMutation) ResetCompatibility() {
	m.compatibility = nil
	m.addcompatibility = nil
}

// Where appends a list predicates to the TypeCompatibilityMutation builder.
func (m *TypeCompatibilityMutation) Where(ps ...predicate.TypeCompatibility) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TypeCompatibilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TypeCompatibility).
func (m *TypeCompatibilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TypeCompatibilityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.attack_type != nil {
		fields = append(fields, typecompatibility.FieldAttackType)
	}
	if m.defence_type != nil {
		fields = append(fields, typecompatibility.FieldDefenceType)
	}
	if m.compatibility != nil {
		fields = append(fields, typecompatibility.FieldCompatibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TypeCompatibilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typecompatibility.FieldAttackType:
		return m.AttackType()
	case typecompatibility.FieldDefenceType:
		return m.DefenceType()
	case typecompatibility.FieldCompatibility:
		return m.Compatibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TypeCompatibilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typecompatibility.FieldAttackType:
		return m.OldAttackType(ctx)
	case typecompatibility.FieldDefenceType:
		return m.OldDefenceType(ctx)
	case typecompatibility.FieldCompatibility:
		return m.OldCompatibility(ctx)
	}
	return nil, fmt.Errorf("unknown TypeCompatibility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeCompatibilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typecompatibility.FieldAttackType:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttackType(v)
		return nil
	case typecompatibility.FieldDefenceType:
		v, ok := value.(property.Types)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefenceType(v)
		return nil
	case typecompatibility.FieldCompatibility:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompatibility(v)
		return nil
	}
	return fmt.Errorf("unknown TypeCompatibility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TypeCompatibilityMutation) AddedFields() []string {
	var fields []string
	if m.addcompatibility != nil {
		fields = append(fields, typecompatibility.FieldCompatibility)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TypeCompatibilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case typecompatibility.FieldCompatibility:
		return m.AddedCompatibility()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeCompatibilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case typecompatibility.FieldCompatibility:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompatibility(v)
		return nil
	}
	return fmt.Errorf("unknown TypeCompatibility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TypeCompatibilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TypeCompatibilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypeCompatibilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TypeCompatibility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TypeCompatibilityMutation) ResetField(name string) error {
	switch name {
	case typecompatibility.FieldAttackType:
		m.ResetAttackType()
		return nil
	case typecompatibility.FieldDefenceType:
		m.ResetDefenceType()
		return nil
	case typecompatibility.FieldCompatibility:
		m.ResetCompatibility()
		return nil
	}
	return fmt.Errorf("unknown TypeCompatibility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TypeCompatibilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TypeCompatibilityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TypeCompatibilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TypeCompatibilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TypeCompatibilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TypeCompatibilityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TypeCompatibilityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TypeCompatibility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TypeCompatibilityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TypeCompatibility edge %s", name)
}

// UsersMutation represents an operation that mutates the Users nodes in the graph.
type UsersMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	name                               *string
	display_name                       *string
	email                              *string
	role                               *property.Role
	profile                            *string
	clearedFields                      map[string]struct{}
	user_trained_pokemon               map[int]struct{}
	removeduser_trained_pokemon        map[int]struct{}
	cleareduser_trained_pokemon        bool
	user_trained_pokemon_detail        map[int]struct{}
	removeduser_trained_pokemon_detail map[int]struct{}
	cleareduser_trained_pokemon_detail bool
	done                               bool
	oldValue                           func(context.Context) (*Users, error)
	predicates                         []predicate.Users
}

var _ ent.Mutation = (*UsersMutation)(nil)

// usersOption allows management of the mutation configuration using functional options.
type usersOption func(*UsersMutation)

// newUsersMutation creates new mutation for the Users entity.
func newUsersMutation(c config, op Op, opts ...usersOption) *UsersMutation {
	m := &UsersMutation{
		config:        c,
		op:            op,
		typ:           TypeUsers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsersID sets the ID field of the mutation.
func withUsersID(id int) usersOption {
	return func(m *UsersMutation) {
		var (
			err   error
			once  sync.Once
			value *Users
		)
		m.oldValue = func(ctx context.Context) (*Users, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Users.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsers sets the old Users of the mutation.
func withUsers(node *Users) usersOption {
	return func(m *UsersMutation) {
		m.oldValue = func(context.Context) (*Users, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *UsersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UsersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UsersMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UsersMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UsersMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UsersMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[users.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UsersMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[users.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UsersMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, users.FieldDisplayName)
}

// SetEmail sets the "email" field.
func (m *UsersMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UsersMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UsersMutation) ResetEmail() {
	m.email = nil
}

// SetRole sets the "role" field.
func (m *UsersMutation) SetRole(pr property.Role) {
	m.role = &pr
}

// Role returns the value of the "role" field in the mutation.
func (m *UsersMutation) Role() (r property.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldRole(ctx context.Context) (v property.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UsersMutation) ResetRole() {
	m.role = nil
}

// SetProfile sets the "profile" field.
func (m *UsersMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *UsersMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *UsersMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[users.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *UsersMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[users.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *UsersMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, users.FieldProfile)
}

// AddUserTrainedPokemonIDs adds the "user_trained_pokemon" edge to the TrainedPokemons entity by ids.
func (m *UsersMutation) AddUserTrainedPokemonIDs(ids ...int) {
	if m.user_trained_pokemon == nil {
		m.user_trained_pokemon = make(map[int]struct{})
	}
	for i := range ids {
		m.user_trained_pokemon[ids[i]] = struct{}{}
	}
}

// ClearUserTrainedPokemon clears the "user_trained_pokemon" edge to the TrainedPokemons entity.
func (m *UsersMutation) ClearUserTrainedPokemon() {
	m.cleareduser_trained_pokemon = true
}

// UserTrainedPokemonCleared reports if the "user_trained_pokemon" edge to the TrainedPokemons entity was cleared.
func (m *UsersMutation) UserTrainedPokemonCleared() bool {
	return m.cleareduser_trained_pokemon
}

// RemoveUserTrainedPokemonIDs removes the "user_trained_pokemon" edge to the TrainedPokemons entity by IDs.
func (m *UsersMutation) RemoveUserTrainedPokemonIDs(ids ...int) {
	if m.removeduser_trained_pokemon == nil {
		m.removeduser_trained_pokemon = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_trained_pokemon, ids[i])
		m.removeduser_trained_pokemon[ids[i]] = struct{}{}
	}
}

// RemovedUserTrainedPokemon returns the removed IDs of the "user_trained_pokemon" edge to the TrainedPokemons entity.
func (m *UsersMutation) RemovedUserTrainedPokemonIDs() (ids []int) {
	for id := range m.removeduser_trained_pokemon {
		ids = append(ids, id)
	}
	return
}

// UserTrainedPokemonIDs returns the "user_trained_pokemon" edge IDs in the mutation.
func (m *UsersMutation) UserTrainedPokemonIDs() (ids []int) {
	for id := range m.user_trained_pokemon {
		ids = append(ids, id)
	}
	return
}

// ResetUserTrainedPokemon resets all changes to the "user_trained_pokemon" edge.
func (m *UsersMutation) ResetUserTrainedPokemon() {
	m.user_trained_pokemon = nil
	m.cleareduser_trained_pokemon = false
	m.removeduser_trained_pokemon = nil
}

// AddUserTrainedPokemonDetailIDs adds the "user_trained_pokemon_detail" edge to the TrainedPokemonDetails entity by ids.
func (m *UsersMutation) AddUserTrainedPokemonDetailIDs(ids ...int) {
	if m.user_trained_pokemon_detail == nil {
		m.user_trained_pokemon_detail = make(map[int]struct{})
	}
	for i := range ids {
		m.user_trained_pokemon_detail[ids[i]] = struct{}{}
	}
}

// ClearUserTrainedPokemonDetail clears the "user_trained_pokemon_detail" edge to the TrainedPokemonDetails entity.
func (m *UsersMutation) ClearUserTrainedPokemonDetail() {
	m.cleareduser_trained_pokemon_detail = true
}

// UserTrainedPokemonDetailCleared reports if the "user_trained_pokemon_detail" edge to the TrainedPokemonDetails entity was cleared.
func (m *UsersMutation) UserTrainedPokemonDetailCleared() bool {
	return m.cleareduser_trained_pokemon_detail
}

// RemoveUserTrainedPokemonDetailIDs removes the "user_trained_pokemon_detail" edge to the TrainedPokemonDetails entity by IDs.
func (m *UsersMutation) RemoveUserTrainedPokemonDetailIDs(ids ...int) {
	if m.removeduser_trained_pokemon_detail == nil {
		m.removeduser_trained_pokemon_detail = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_trained_pokemon_detail, ids[i])
		m.removeduser_trained_pokemon_detail[ids[i]] = struct{}{}
	}
}

// RemovedUserTrainedPokemonDetail returns the removed IDs of the "user_trained_pokemon_detail" edge to the TrainedPokemonDetails entity.
func (m *UsersMutation) RemovedUserTrainedPokemonDetailIDs() (ids []int) {
	for id := range m.removeduser_trained_pokemon_detail {
		ids = append(ids, id)
	}
	return
}

// UserTrainedPokemonDetailIDs returns the "user_trained_pokemon_detail" edge IDs in the mutation.
func (m *UsersMutation) UserTrainedPokemonDetailIDs() (ids []int) {
	for id := range m.user_trained_pokemon_detail {
		ids = append(ids, id)
	}
	return
}

// ResetUserTrainedPokemonDetail resets all changes to the "user_trained_pokemon_detail" edge.
func (m *UsersMutation) ResetUserTrainedPokemonDetail() {
	m.user_trained_pokemon_detail = nil
	m.cleareduser_trained_pokemon_detail = false
	m.removeduser_trained_pokemon_detail = nil
}

// Where appends a list predicates to the UsersMutation builder.
func (m *UsersMutation) Where(ps ...predicate.Users) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UsersMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Users).
func (m *UsersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsersMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, users.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, users.FieldDisplayName)
	}
	if m.email != nil {
		fields = append(fields, users.FieldEmail)
	}
	if m.role != nil {
		fields = append(fields, users.FieldRole)
	}
	if m.profile != nil {
		fields = append(fields, users.FieldProfile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case users.FieldName:
		return m.Name()
	case users.FieldDisplayName:
		return m.DisplayName()
	case users.FieldEmail:
		return m.Email()
	case users.FieldRole:
		return m.Role()
	case users.FieldProfile:
		return m.Profile()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case users.FieldName:
		return m.OldName(ctx)
	case users.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case users.FieldEmail:
		return m.OldEmail(ctx)
	case users.FieldRole:
		return m.OldRole(ctx)
	case users.FieldProfile:
		return m.OldProfile(ctx)
	}
	return nil, fmt.Errorf("unknown Users field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case users.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case users.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case users.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case users.FieldRole:
		v, ok := value.(property.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case users.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Users numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(users.FieldDisplayName) {
		fields = append(fields, users.FieldDisplayName)
	}
	if m.FieldCleared(users.FieldProfile) {
		fields = append(fields, users.FieldProfile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsersMutation) ClearField(name string) error {
	switch name {
	case users.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case users.FieldProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Users nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsersMutation) ResetField(name string) error {
	switch name {
	case users.FieldName:
		m.ResetName()
		return nil
	case users.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case users.FieldEmail:
		m.ResetEmail()
		return nil
	case users.FieldRole:
		m.ResetRole()
		return nil
	case users.FieldProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsersMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_trained_pokemon != nil {
		edges = append(edges, users.EdgeUserTrainedPokemon)
	}
	if m.user_trained_pokemon_detail != nil {
		edges = append(edges, users.EdgeUserTrainedPokemonDetail)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case users.EdgeUserTrainedPokemon:
		ids := make([]ent.Value, 0, len(m.user_trained_pokemon))
		for id := range m.user_trained_pokemon {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeUserTrainedPokemonDetail:
		ids := make([]ent.Value, 0, len(m.user_trained_pokemon_detail))
		for id := range m.user_trained_pokemon_detail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_trained_pokemon != nil {
		edges = append(edges, users.EdgeUserTrainedPokemon)
	}
	if m.removeduser_trained_pokemon_detail != nil {
		edges = append(edges, users.EdgeUserTrainedPokemonDetail)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsersMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case users.EdgeUserTrainedPokemon:
		ids := make([]ent.Value, 0, len(m.removeduser_trained_pokemon))
		for id := range m.removeduser_trained_pokemon {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeUserTrainedPokemonDetail:
		ids := make([]ent.Value, 0, len(m.removeduser_trained_pokemon_detail))
		for id := range m.removeduser_trained_pokemon_detail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_trained_pokemon {
		edges = append(edges, users.EdgeUserTrainedPokemon)
	}
	if m.cleareduser_trained_pokemon_detail {
		edges = append(edges, users.EdgeUserTrainedPokemonDetail)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsersMutation) EdgeCleared(name string) bool {
	switch name {
	case users.EdgeUserTrainedPokemon:
		return m.cleareduser_trained_pokemon
	case users.EdgeUserTrainedPokemonDetail:
		return m.cleareduser_trained_pokemon_detail
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsersMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Users unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsersMutation) ResetEdge(name string) error {
	switch name {
	case users.EdgeUserTrainedPokemon:
		m.ResetUserTrainedPokemon()
		return nil
	case users.EdgeUserTrainedPokemonDetail:
		m.ResetUserTrainedPokemonDetail()
		return nil
	}
	return fmt.Errorf("unknown Users edge %s", name)
}
