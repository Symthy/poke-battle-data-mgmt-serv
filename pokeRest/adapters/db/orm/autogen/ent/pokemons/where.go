// Code generated by entc, DO NOT EDIT.

package pokemons

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/autogen/ent/predicate"
	"github.com/Symthy/PokeRest/pokeRest/adapters/orm/property"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// PokedexNo applies equality check predicate on the "pokedex_no" field. It's identical to PokedexNoEQ.
func PokedexNo(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPokedexNo), v))
	})
}

// FormNo applies equality check predicate on the "form_no" field. It's identical to FormNoEQ.
func FormNo(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFormNo), v))
	})
}

// FormName applies equality check predicate on the "form_name" field. It's identical to FormNameEQ.
func FormName(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFormName), v))
	})
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// EnglishName applies equality check predicate on the "english_name" field. It's identical to EnglishNameEQ.
func EnglishName(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEnglishName), v))
	})
}

// AbilityId1 applies equality check predicate on the "ability_id1" field. It's identical to AbilityId1EQ.
func AbilityId1(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAbilityId1), v))
	})
}

// AbilityId2 applies equality check predicate on the "ability_id2" field. It's identical to AbilityId2EQ.
func AbilityId2(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAbilityId2), v))
	})
}

// HiddenAbilityID applies equality check predicate on the "hidden_ability_id" field. It's identical to HiddenAbilityIDEQ.
func HiddenAbilityID(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHiddenAbilityID), v))
	})
}

// IsFinalEvolution applies equality check predicate on the "is_final_evolution" field. It's identical to IsFinalEvolutionEQ.
func IsFinalEvolution(v bool) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsFinalEvolution), v))
	})
}

// BaseStatsH applies equality check predicate on the "base_stats_h" field. It's identical to BaseStatsHEQ.
func BaseStatsH(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsH), v))
	})
}

// BaseStatsA applies equality check predicate on the "base_stats_a" field. It's identical to BaseStatsAEQ.
func BaseStatsA(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsA), v))
	})
}

// BaseStatsB applies equality check predicate on the "base_stats_b" field. It's identical to BaseStatsBEQ.
func BaseStatsB(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsB), v))
	})
}

// BaseStatsC applies equality check predicate on the "base_stats_c" field. It's identical to BaseStatsCEQ.
func BaseStatsC(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsC), v))
	})
}

// BaseStatsD applies equality check predicate on the "base_stats_d" field. It's identical to BaseStatsDEQ.
func BaseStatsD(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsD), v))
	})
}

// BaseStatsS applies equality check predicate on the "base_stats_s" field. It's identical to BaseStatsSEQ.
func BaseStatsS(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsS), v))
	})
}

// PokedexNoEQ applies the EQ predicate on the "pokedex_no" field.
func PokedexNoEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPokedexNo), v))
	})
}

// PokedexNoNEQ applies the NEQ predicate on the "pokedex_no" field.
func PokedexNoNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPokedexNo), v))
	})
}

// PokedexNoIn applies the In predicate on the "pokedex_no" field.
func PokedexNoIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPokedexNo), v...))
	})
}

// PokedexNoNotIn applies the NotIn predicate on the "pokedex_no" field.
func PokedexNoNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPokedexNo), v...))
	})
}

// PokedexNoGT applies the GT predicate on the "pokedex_no" field.
func PokedexNoGT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPokedexNo), v))
	})
}

// PokedexNoGTE applies the GTE predicate on the "pokedex_no" field.
func PokedexNoGTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPokedexNo), v))
	})
}

// PokedexNoLT applies the LT predicate on the "pokedex_no" field.
func PokedexNoLT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPokedexNo), v))
	})
}

// PokedexNoLTE applies the LTE predicate on the "pokedex_no" field.
func PokedexNoLTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPokedexNo), v))
	})
}

// FormNoEQ applies the EQ predicate on the "form_no" field.
func FormNoEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFormNo), v))
	})
}

// FormNoNEQ applies the NEQ predicate on the "form_no" field.
func FormNoNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFormNo), v))
	})
}

// FormNoIn applies the In predicate on the "form_no" field.
func FormNoIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFormNo), v...))
	})
}

// FormNoNotIn applies the NotIn predicate on the "form_no" field.
func FormNoNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFormNo), v...))
	})
}

// FormNameEQ applies the EQ predicate on the "form_name" field.
func FormNameEQ(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFormName), v))
	})
}

// FormNameNEQ applies the NEQ predicate on the "form_name" field.
func FormNameNEQ(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFormName), v))
	})
}

// FormNameIn applies the In predicate on the "form_name" field.
func FormNameIn(vs ...string) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFormName), v...))
	})
}

// FormNameNotIn applies the NotIn predicate on the "form_name" field.
func FormNameNotIn(vs ...string) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFormName), v...))
	})
}

// FormNameGT applies the GT predicate on the "form_name" field.
func FormNameGT(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFormName), v))
	})
}

// FormNameGTE applies the GTE predicate on the "form_name" field.
func FormNameGTE(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFormName), v))
	})
}

// FormNameLT applies the LT predicate on the "form_name" field.
func FormNameLT(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFormName), v))
	})
}

// FormNameLTE applies the LTE predicate on the "form_name" field.
func FormNameLTE(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFormName), v))
	})
}

// FormNameContains applies the Contains predicate on the "form_name" field.
func FormNameContains(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFormName), v))
	})
}

// FormNameHasPrefix applies the HasPrefix predicate on the "form_name" field.
func FormNameHasPrefix(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFormName), v))
	})
}

// FormNameHasSuffix applies the HasSuffix predicate on the "form_name" field.
func FormNameHasSuffix(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFormName), v))
	})
}

// FormNameEqualFold applies the EqualFold predicate on the "form_name" field.
func FormNameEqualFold(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFormName), v))
	})
}

// FormNameContainsFold applies the ContainsFold predicate on the "form_name" field.
func FormNameContainsFold(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFormName), v))
	})
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldName), v))
	})
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldName), v...))
	})
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldName), v...))
	})
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldName), v))
	})
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldName), v))
	})
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldName), v))
	})
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldName), v))
	})
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldName), v))
	})
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldName), v))
	})
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldName), v))
	})
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldName), v))
	})
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldName), v))
	})
}

// EnglishNameEQ applies the EQ predicate on the "english_name" field.
func EnglishNameEQ(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEnglishName), v))
	})
}

// EnglishNameNEQ applies the NEQ predicate on the "english_name" field.
func EnglishNameNEQ(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEnglishName), v))
	})
}

// EnglishNameIn applies the In predicate on the "english_name" field.
func EnglishNameIn(vs ...string) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEnglishName), v...))
	})
}

// EnglishNameNotIn applies the NotIn predicate on the "english_name" field.
func EnglishNameNotIn(vs ...string) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEnglishName), v...))
	})
}

// EnglishNameGT applies the GT predicate on the "english_name" field.
func EnglishNameGT(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEnglishName), v))
	})
}

// EnglishNameGTE applies the GTE predicate on the "english_name" field.
func EnglishNameGTE(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEnglishName), v))
	})
}

// EnglishNameLT applies the LT predicate on the "english_name" field.
func EnglishNameLT(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEnglishName), v))
	})
}

// EnglishNameLTE applies the LTE predicate on the "english_name" field.
func EnglishNameLTE(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEnglishName), v))
	})
}

// EnglishNameContains applies the Contains predicate on the "english_name" field.
func EnglishNameContains(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldEnglishName), v))
	})
}

// EnglishNameHasPrefix applies the HasPrefix predicate on the "english_name" field.
func EnglishNameHasPrefix(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldEnglishName), v))
	})
}

// EnglishNameHasSuffix applies the HasSuffix predicate on the "english_name" field.
func EnglishNameHasSuffix(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldEnglishName), v))
	})
}

// EnglishNameEqualFold applies the EqualFold predicate on the "english_name" field.
func EnglishNameEqualFold(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldEnglishName), v))
	})
}

// EnglishNameContainsFold applies the ContainsFold predicate on the "english_name" field.
func EnglishNameContainsFold(v string) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldEnglishName), v))
	})
}

// Type1EQ applies the EQ predicate on the "type1" field.
func Type1EQ(v property.Types) predicate.Pokemons {
	vc := v
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType1), vc))
	})
}

// Type1NEQ applies the NEQ predicate on the "type1" field.
func Type1NEQ(v property.Types) predicate.Pokemons {
	vc := v
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType1), vc))
	})
}

// Type1In applies the In predicate on the "type1" field.
func Type1In(vs ...property.Types) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldType1), v...))
	})
}

// Type1NotIn applies the NotIn predicate on the "type1" field.
func Type1NotIn(vs ...property.Types) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldType1), v...))
	})
}

// Type2EQ applies the EQ predicate on the "type2" field.
func Type2EQ(v property.Types) predicate.Pokemons {
	vc := v
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType2), vc))
	})
}

// Type2NEQ applies the NEQ predicate on the "type2" field.
func Type2NEQ(v property.Types) predicate.Pokemons {
	vc := v
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType2), vc))
	})
}

// Type2In applies the In predicate on the "type2" field.
func Type2In(vs ...property.Types) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldType2), v...))
	})
}

// Type2NotIn applies the NotIn predicate on the "type2" field.
func Type2NotIn(vs ...property.Types) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldType2), v...))
	})
}

// Type2IsNil applies the IsNil predicate on the "type2" field.
func Type2IsNil() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldType2)))
	})
}

// Type2NotNil applies the NotNil predicate on the "type2" field.
func Type2NotNil() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldType2)))
	})
}

// AbilityId1EQ applies the EQ predicate on the "ability_id1" field.
func AbilityId1EQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAbilityId1), v))
	})
}

// AbilityId1NEQ applies the NEQ predicate on the "ability_id1" field.
func AbilityId1NEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAbilityId1), v))
	})
}

// AbilityId1In applies the In predicate on the "ability_id1" field.
func AbilityId1In(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAbilityId1), v...))
	})
}

// AbilityId1NotIn applies the NotIn predicate on the "ability_id1" field.
func AbilityId1NotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAbilityId1), v...))
	})
}

// AbilityId2EQ applies the EQ predicate on the "ability_id2" field.
func AbilityId2EQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAbilityId2), v))
	})
}

// AbilityId2NEQ applies the NEQ predicate on the "ability_id2" field.
func AbilityId2NEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAbilityId2), v))
	})
}

// AbilityId2In applies the In predicate on the "ability_id2" field.
func AbilityId2In(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAbilityId2), v...))
	})
}

// AbilityId2NotIn applies the NotIn predicate on the "ability_id2" field.
func AbilityId2NotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAbilityId2), v...))
	})
}

// AbilityId2IsNil applies the IsNil predicate on the "ability_id2" field.
func AbilityId2IsNil() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAbilityId2)))
	})
}

// AbilityId2NotNil applies the NotNil predicate on the "ability_id2" field.
func AbilityId2NotNil() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAbilityId2)))
	})
}

// HiddenAbilityIDEQ applies the EQ predicate on the "hidden_ability_id" field.
func HiddenAbilityIDEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHiddenAbilityID), v))
	})
}

// HiddenAbilityIDNEQ applies the NEQ predicate on the "hidden_ability_id" field.
func HiddenAbilityIDNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHiddenAbilityID), v))
	})
}

// HiddenAbilityIDIn applies the In predicate on the "hidden_ability_id" field.
func HiddenAbilityIDIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHiddenAbilityID), v...))
	})
}

// HiddenAbilityIDNotIn applies the NotIn predicate on the "hidden_ability_id" field.
func HiddenAbilityIDNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHiddenAbilityID), v...))
	})
}

// HiddenAbilityIDIsNil applies the IsNil predicate on the "hidden_ability_id" field.
func HiddenAbilityIDIsNil() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldHiddenAbilityID)))
	})
}

// HiddenAbilityIDNotNil applies the NotNil predicate on the "hidden_ability_id" field.
func HiddenAbilityIDNotNil() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldHiddenAbilityID)))
	})
}

// IsFinalEvolutionEQ applies the EQ predicate on the "is_final_evolution" field.
func IsFinalEvolutionEQ(v bool) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsFinalEvolution), v))
	})
}

// IsFinalEvolutionNEQ applies the NEQ predicate on the "is_final_evolution" field.
func IsFinalEvolutionNEQ(v bool) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIsFinalEvolution), v))
	})
}

// BaseStatsHEQ applies the EQ predicate on the "base_stats_h" field.
func BaseStatsHEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsH), v))
	})
}

// BaseStatsHNEQ applies the NEQ predicate on the "base_stats_h" field.
func BaseStatsHNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBaseStatsH), v))
	})
}

// BaseStatsHIn applies the In predicate on the "base_stats_h" field.
func BaseStatsHIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBaseStatsH), v...))
	})
}

// BaseStatsHNotIn applies the NotIn predicate on the "base_stats_h" field.
func BaseStatsHNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBaseStatsH), v...))
	})
}

// BaseStatsHGT applies the GT predicate on the "base_stats_h" field.
func BaseStatsHGT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBaseStatsH), v))
	})
}

// BaseStatsHGTE applies the GTE predicate on the "base_stats_h" field.
func BaseStatsHGTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBaseStatsH), v))
	})
}

// BaseStatsHLT applies the LT predicate on the "base_stats_h" field.
func BaseStatsHLT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBaseStatsH), v))
	})
}

// BaseStatsHLTE applies the LTE predicate on the "base_stats_h" field.
func BaseStatsHLTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBaseStatsH), v))
	})
}

// BaseStatsAEQ applies the EQ predicate on the "base_stats_a" field.
func BaseStatsAEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsA), v))
	})
}

// BaseStatsANEQ applies the NEQ predicate on the "base_stats_a" field.
func BaseStatsANEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBaseStatsA), v))
	})
}

// BaseStatsAIn applies the In predicate on the "base_stats_a" field.
func BaseStatsAIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBaseStatsA), v...))
	})
}

// BaseStatsANotIn applies the NotIn predicate on the "base_stats_a" field.
func BaseStatsANotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBaseStatsA), v...))
	})
}

// BaseStatsAGT applies the GT predicate on the "base_stats_a" field.
func BaseStatsAGT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBaseStatsA), v))
	})
}

// BaseStatsAGTE applies the GTE predicate on the "base_stats_a" field.
func BaseStatsAGTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBaseStatsA), v))
	})
}

// BaseStatsALT applies the LT predicate on the "base_stats_a" field.
func BaseStatsALT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBaseStatsA), v))
	})
}

// BaseStatsALTE applies the LTE predicate on the "base_stats_a" field.
func BaseStatsALTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBaseStatsA), v))
	})
}

// BaseStatsBEQ applies the EQ predicate on the "base_stats_b" field.
func BaseStatsBEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsB), v))
	})
}

// BaseStatsBNEQ applies the NEQ predicate on the "base_stats_b" field.
func BaseStatsBNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBaseStatsB), v))
	})
}

// BaseStatsBIn applies the In predicate on the "base_stats_b" field.
func BaseStatsBIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBaseStatsB), v...))
	})
}

// BaseStatsBNotIn applies the NotIn predicate on the "base_stats_b" field.
func BaseStatsBNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBaseStatsB), v...))
	})
}

// BaseStatsBGT applies the GT predicate on the "base_stats_b" field.
func BaseStatsBGT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBaseStatsB), v))
	})
}

// BaseStatsBGTE applies the GTE predicate on the "base_stats_b" field.
func BaseStatsBGTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBaseStatsB), v))
	})
}

// BaseStatsBLT applies the LT predicate on the "base_stats_b" field.
func BaseStatsBLT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBaseStatsB), v))
	})
}

// BaseStatsBLTE applies the LTE predicate on the "base_stats_b" field.
func BaseStatsBLTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBaseStatsB), v))
	})
}

// BaseStatsCEQ applies the EQ predicate on the "base_stats_c" field.
func BaseStatsCEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsC), v))
	})
}

// BaseStatsCNEQ applies the NEQ predicate on the "base_stats_c" field.
func BaseStatsCNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBaseStatsC), v))
	})
}

// BaseStatsCIn applies the In predicate on the "base_stats_c" field.
func BaseStatsCIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBaseStatsC), v...))
	})
}

// BaseStatsCNotIn applies the NotIn predicate on the "base_stats_c" field.
func BaseStatsCNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBaseStatsC), v...))
	})
}

// BaseStatsCGT applies the GT predicate on the "base_stats_c" field.
func BaseStatsCGT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBaseStatsC), v))
	})
}

// BaseStatsCGTE applies the GTE predicate on the "base_stats_c" field.
func BaseStatsCGTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBaseStatsC), v))
	})
}

// BaseStatsCLT applies the LT predicate on the "base_stats_c" field.
func BaseStatsCLT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBaseStatsC), v))
	})
}

// BaseStatsCLTE applies the LTE predicate on the "base_stats_c" field.
func BaseStatsCLTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBaseStatsC), v))
	})
}

// BaseStatsDEQ applies the EQ predicate on the "base_stats_d" field.
func BaseStatsDEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsD), v))
	})
}

// BaseStatsDNEQ applies the NEQ predicate on the "base_stats_d" field.
func BaseStatsDNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBaseStatsD), v))
	})
}

// BaseStatsDIn applies the In predicate on the "base_stats_d" field.
func BaseStatsDIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBaseStatsD), v...))
	})
}

// BaseStatsDNotIn applies the NotIn predicate on the "base_stats_d" field.
func BaseStatsDNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBaseStatsD), v...))
	})
}

// BaseStatsDGT applies the GT predicate on the "base_stats_d" field.
func BaseStatsDGT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBaseStatsD), v))
	})
}

// BaseStatsDGTE applies the GTE predicate on the "base_stats_d" field.
func BaseStatsDGTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBaseStatsD), v))
	})
}

// BaseStatsDLT applies the LT predicate on the "base_stats_d" field.
func BaseStatsDLT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBaseStatsD), v))
	})
}

// BaseStatsDLTE applies the LTE predicate on the "base_stats_d" field.
func BaseStatsDLTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBaseStatsD), v))
	})
}

// BaseStatsSEQ applies the EQ predicate on the "base_stats_s" field.
func BaseStatsSEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseStatsS), v))
	})
}

// BaseStatsSNEQ applies the NEQ predicate on the "base_stats_s" field.
func BaseStatsSNEQ(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBaseStatsS), v))
	})
}

// BaseStatsSIn applies the In predicate on the "base_stats_s" field.
func BaseStatsSIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBaseStatsS), v...))
	})
}

// BaseStatsSNotIn applies the NotIn predicate on the "base_stats_s" field.
func BaseStatsSNotIn(vs ...int) predicate.Pokemons {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pokemons(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBaseStatsS), v...))
	})
}

// BaseStatsSGT applies the GT predicate on the "base_stats_s" field.
func BaseStatsSGT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBaseStatsS), v))
	})
}

// BaseStatsSGTE applies the GTE predicate on the "base_stats_s" field.
func BaseStatsSGTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBaseStatsS), v))
	})
}

// BaseStatsSLT applies the LT predicate on the "base_stats_s" field.
func BaseStatsSLT(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBaseStatsS), v))
	})
}

// BaseStatsSLTE applies the LTE predicate on the "base_stats_s" field.
func BaseStatsSLTE(v int) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBaseStatsS), v))
	})
}

// HasAbility1 applies the HasEdge predicate on the "ability1" edge.
func HasAbility1() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(Ability1Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, Ability1Table, Ability1Column),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAbility1With applies the HasEdge predicate on the "ability1" edge with a given conditions (other predicates).
func HasAbility1With(preds ...predicate.Abilities) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(Ability1InverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, Ability1Table, Ability1Column),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAbility2 applies the HasEdge predicate on the "ability2" edge.
func HasAbility2() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(Ability2Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, Ability2Table, Ability2Column),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAbility2With applies the HasEdge predicate on the "ability2" edge with a given conditions (other predicates).
func HasAbility2With(preds ...predicate.Abilities) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(Ability2InverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, Ability2Table, Ability2Column),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasHiddenAbility applies the HasEdge predicate on the "hidden_ability" edge.
func HasHiddenAbility() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(HiddenAbilityTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, HiddenAbilityTable, HiddenAbilityColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasHiddenAbilityWith applies the HasEdge predicate on the "hidden_ability" edge with a given conditions (other predicates).
func HasHiddenAbilityWith(preds ...predicate.Abilities) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(HiddenAbilityInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, HiddenAbilityTable, HiddenAbilityColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasForm applies the HasEdge predicate on the "form" edge.
func HasForm() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FormTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, FormTable, FormColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasFormWith applies the HasEdge predicate on the "form" edge with a given conditions (other predicates).
func HasFormWith(preds ...predicate.Forms) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FormInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, FormTable, FormColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasToTrainedPokemon applies the HasEdge predicate on the "to_trained_pokemon" edge.
func HasToTrainedPokemon() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ToTrainedPokemonTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, ToTrainedPokemonTable, ToTrainedPokemonColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasToTrainedPokemonWith applies the HasEdge predicate on the "to_trained_pokemon" edge with a given conditions (other predicates).
func HasToTrainedPokemonWith(preds ...predicate.TrainedPokemons) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ToTrainedPokemonInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, ToTrainedPokemonTable, ToTrainedPokemonColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasPokemonToMove applies the HasEdge predicate on the "pokemon_to_move" edge.
func HasPokemonToMove() predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PokemonToMoveTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, PokemonToMoveTable, PokemonToMovePrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasPokemonToMoveWith applies the HasEdge predicate on the "pokemon_to_move" edge with a given conditions (other predicates).
func HasPokemonToMoveWith(preds ...predicate.Moves) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PokemonToMoveInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, PokemonToMoveTable, PokemonToMovePrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Pokemons) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Pokemons) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Pokemons) predicate.Pokemons {
	return predicate.Pokemons(func(s *sql.Selector) {
		p(s.Not())
	})
}
